--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require(script.Parent.Parent.Parent.Parent.Parent.proto)
local typeRegistry = require(script.Parent.Parent.Parent.Parent.Parent.proto.typeRegistry)

type _Messages = {
	TemplateEntry: _TemplateEntryMessage,
}
local messages: _Messages = {} :: _Messages

local _roblox_apppageplatform_shared_v1beta1_roblox_component_type = require(script.Parent.roblox_component_type)
local _roblox_apppageplatform_shared_v1beta1_ui_component_schema = require(script.Parent.ui_component_schema)

type _TemplateEntryImpl = {
	__index: _TemplateEntryImpl,
	new: (fields: _TemplateEntryPartialFields?) -> TemplateEntry,
	encode: (self: TemplateEntry) -> buffer,
	decode: (input: buffer) -> TemplateEntry,
	jsonEncode: (self: TemplateEntry) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> TemplateEntry,
	descriptor: proto.Descriptor,
}

type _TemplateEntryFields = {
	template: _roblox_apppageplatform_shared_v1beta1_ui_component_schema.UiComponentSchema?,
	roblox_component: _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType,
}

type _TemplateEntryPartialFields = {
	template: _roblox_apppageplatform_shared_v1beta1_ui_component_schema.UiComponentSchema?,
	roblox_component: _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType?,
}

export type TemplateEntry = typeof(setmetatable({} :: _TemplateEntryFields, {} :: _TemplateEntryImpl))
type _TemplateEntryMessage = proto.Message<TemplateEntry, _TemplateEntryPartialFields>

do
	local _TemplateEntryImpl = {}
	_TemplateEntryImpl.__index = _TemplateEntryImpl

	function _TemplateEntryImpl.new(data: _TemplateEntryPartialFields?): TemplateEntry
		return setmetatable({
			template = if data == nil or data.template == nil then nil else data.template,
			roblox_component = if data == nil or data.roblox_component == nil
				then assert(
					_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(0),
					"Enum has no 0 default"
				)
				else data.roblox_component,
		}, _TemplateEntryImpl :: _TemplateEntryImpl)
	end

	function _TemplateEntryImpl.encode(self: TemplateEntry): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.template ~= nil then
			local encoded = self.template:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if
			self.roblox_component ~= nil
			and (
				self.roblox_component ~= nil and self.roblox_component ~= 0
				or self.roblox_component
					~= _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(
				output,
				cursor,
				_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.toNumber(
					self.roblox_component :: any
				)
			)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _TemplateEntryImpl.decode(input: buffer): TemplateEntry
		local self = _TemplateEntryImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 2 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.roblox_component = (
						_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(
							value
						) or value
					) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.template =
						_roblox_apppageplatform_shared_v1beta1_ui_component_schema.UiComponentSchema.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _TemplateEntryImpl.jsonEncode(self: TemplateEntry): any
		local output = {}

		if self.template ~= nil then
			output.template = self.template:jsonEncode()
		end

		if
			self.roblox_component ~= nil
			and (
				self.roblox_component ~= nil and self.roblox_component ~= 0
				or self.roblox_component
					~= _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(0)
			)
		then
			output.robloxComponent = if typeof(self.roblox_component) == "number"
				then self.roblox_component
				else _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.toNumber(
					self.roblox_component :: any
				)
		end

		return output
	end

	function _TemplateEntryImpl.jsonDecode(input: { [string]: any }): TemplateEntry
		local self = _TemplateEntryImpl.new()

		if input.template ~= nil then
			self.template =
				_roblox_apppageplatform_shared_v1beta1_ui_component_schema.UiComponentSchema.jsonDecode(input.template)
		end

		if input.roblox_component ~= nil then
			self.roblox_component = if typeof(input.roblox_component) == "number"
				then (_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(
					input.roblox_component
				) or input.roblox_component)
				else (_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromName(
					input.roblox_component
				) or input.roblox_component)
		end

		if input.robloxComponent ~= nil then
			self.roblox_component = if typeof(input.robloxComponent) == "number"
				then (_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(
					input.robloxComponent
				) or input.robloxComponent)
				else (_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromName(
					input.robloxComponent
				) or input.robloxComponent)
		end

		return self
	end

	_TemplateEntryImpl.descriptor = {
		name = "TemplateEntry",
		fullName = "roblox.apppageplatform.shared.v1beta1.TemplateEntry",
	}

	messages.TemplateEntry = _TemplateEntryImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.TemplateEntry)
end

return {
	TemplateEntry = messages.TemplateEntry,
}
