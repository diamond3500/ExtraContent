--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require(script.Parent.Parent.Parent.Parent.Parent.proto)
local typeRegistry = require(script.Parent.Parent.Parent.Parent.Parent.proto.typeRegistry)

type _Messages = {
	HoldToPlaySchema: _HoldToPlaySchemaMessage,
	HoldToPlaySchema_Props: _HoldToPlaySchema_PropsMessage,
}
local messages: _Messages = {} :: _Messages

local _roblox_apppageplatform_shared_v1beta1_prop_types = require(script.Parent.prop_types)
local _roblox_apppageplatform_shared_v1beta1_component_shared = require(script.Parent.component_shared)

type _HoldToPlaySchemaImpl = {
	__index: _HoldToPlaySchemaImpl,
	new: (fields: _HoldToPlaySchemaPartialFields?) -> HoldToPlaySchema,
	encode: (self: HoldToPlaySchema) -> buffer,
	decode: (input: buffer) -> HoldToPlaySchema,
	jsonEncode: (self: HoldToPlaySchema) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> HoldToPlaySchema,
	descriptor: proto.Descriptor,
}

type _HoldToPlaySchemaFields = {
	props: HoldToPlaySchema_Props?,
	shared: _roblox_apppageplatform_shared_v1beta1_component_shared.ComponentShared?,
}

type _HoldToPlaySchemaPartialFields = {
	props: HoldToPlaySchema_Props?,
	shared: _roblox_apppageplatform_shared_v1beta1_component_shared.ComponentShared?,
}

export type HoldToPlaySchema = typeof(setmetatable({} :: _HoldToPlaySchemaFields, {} :: _HoldToPlaySchemaImpl))
type _HoldToPlaySchemaMessage = proto.Message<HoldToPlaySchema, _HoldToPlaySchemaPartialFields>

type _HoldToPlaySchema_PropsImpl = {
	__index: _HoldToPlaySchema_PropsImpl,
	new: (fields: _HoldToPlaySchema_PropsPartialFields?) -> HoldToPlaySchema_Props,
	encode: (self: HoldToPlaySchema_Props) -> buffer,
	decode: (input: buffer) -> HoldToPlaySchema_Props,
	jsonEncode: (self: HoldToPlaySchema_Props) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> HoldToPlaySchema_Props,
	descriptor: proto.Descriptor,
}

type _HoldToPlaySchema_PropsFields = {
	universe_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	place_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

type _HoldToPlaySchema_PropsPartialFields = {
	universe_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	place_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

export type HoldToPlaySchema_Props = typeof(setmetatable(
	{} :: _HoldToPlaySchema_PropsFields,
	{} :: _HoldToPlaySchema_PropsImpl
))
type _HoldToPlaySchema_PropsMessage = proto.Message<HoldToPlaySchema_Props, _HoldToPlaySchema_PropsPartialFields>

do
	local _HoldToPlaySchemaImpl = {}
	_HoldToPlaySchemaImpl.__index = _HoldToPlaySchemaImpl

	function _HoldToPlaySchemaImpl.new(data: _HoldToPlaySchemaPartialFields?): HoldToPlaySchema
		return setmetatable({
			props = if data == nil or data.props == nil then nil else data.props,
			shared = if data == nil or data.shared == nil then nil else data.shared,
		}, _HoldToPlaySchemaImpl :: _HoldToPlaySchemaImpl)
	end

	function _HoldToPlaySchemaImpl.encode(self: HoldToPlaySchema): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.props ~= nil then
			local encoded = self.props:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.shared ~= nil then
			local encoded = self.shared:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _HoldToPlaySchemaImpl.decode(input: buffer): HoldToPlaySchema
		local self = _HoldToPlaySchemaImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.props = messages.HoldToPlaySchema_Props.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.shared = _roblox_apppageplatform_shared_v1beta1_component_shared.ComponentShared.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _HoldToPlaySchemaImpl.jsonEncode(self: HoldToPlaySchema): any
		local output = {}

		if self.props ~= nil then
			output.props = self.props:jsonEncode()
		end

		if self.shared ~= nil then
			output.shared = self.shared:jsonEncode()
		end

		return output
	end

	function _HoldToPlaySchemaImpl.jsonDecode(input: { [string]: any }): HoldToPlaySchema
		local self = _HoldToPlaySchemaImpl.new()

		if input.props ~= nil then
			self.props = messages.HoldToPlaySchema_Props.jsonDecode(input.props)
		end

		if input.shared ~= nil then
			self.shared =
				_roblox_apppageplatform_shared_v1beta1_component_shared.ComponentShared.jsonDecode(input.shared)
		end

		return self
	end

	_HoldToPlaySchemaImpl.descriptor = {
		name = "HoldToPlaySchema",
		fullName = "roblox.apppageplatform.shared.v1beta1.HoldToPlaySchema",
	}

	messages.HoldToPlaySchema = _HoldToPlaySchemaImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.HoldToPlaySchema)
end

do
	local _HoldToPlaySchema_PropsImpl = {}
	_HoldToPlaySchema_PropsImpl.__index = _HoldToPlaySchema_PropsImpl

	function _HoldToPlaySchema_PropsImpl.new(data: _HoldToPlaySchema_PropsPartialFields?): HoldToPlaySchema_Props
		return setmetatable({
			universe_id = if data == nil or data.universe_id == nil then nil else data.universe_id,
			place_id = if data == nil or data.place_id == nil then nil else data.place_id,
		}, _HoldToPlaySchema_PropsImpl :: _HoldToPlaySchema_PropsImpl)
	end

	function _HoldToPlaySchema_PropsImpl.encode(self: HoldToPlaySchema_Props): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.universe_id ~= nil then
			local encoded = self.universe_id:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.place_id ~= nil then
			local encoded = self.place_id:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _HoldToPlaySchema_PropsImpl.decode(input: buffer): HoldToPlaySchema_Props
		local self = _HoldToPlaySchema_PropsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.universe_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.place_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _HoldToPlaySchema_PropsImpl.jsonEncode(self: HoldToPlaySchema_Props): any
		local output = {}

		if self.universe_id ~= nil then
			output.universeId = self.universe_id:jsonEncode()
		end

		if self.place_id ~= nil then
			output.placeId = self.place_id:jsonEncode()
		end

		return output
	end

	function _HoldToPlaySchema_PropsImpl.jsonDecode(input: { [string]: any }): HoldToPlaySchema_Props
		local self = _HoldToPlaySchema_PropsImpl.new()

		if input.universe_id ~= nil then
			self.universe_id =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.universe_id)
		end

		if input.universeId ~= nil then
			self.universe_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.universeId)
		end

		if input.place_id ~= nil then
			self.place_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.place_id)
		end

		if input.placeId ~= nil then
			self.place_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.placeId)
		end

		return self
	end

	_HoldToPlaySchema_PropsImpl.descriptor = {
		name = "HoldToPlaySchema_Props",
		fullName = "roblox.apppageplatform.shared.v1beta1.Props",
	}

	messages.HoldToPlaySchema_Props = _HoldToPlaySchema_PropsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.HoldToPlaySchema_Props)
end

return {
	HoldToPlaySchema = messages.HoldToPlaySchema,
	HoldToPlaySchema_Props = messages.HoldToPlaySchema_Props,
}
