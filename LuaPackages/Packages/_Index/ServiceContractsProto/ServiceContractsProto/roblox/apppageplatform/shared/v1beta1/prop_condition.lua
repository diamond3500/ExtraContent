--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require(script.Parent.Parent.Parent.Parent.Parent.proto)
local typeRegistry = require(script.Parent.Parent.Parent.Parent.Parent.proto.typeRegistry)

type _Messages = {
	PropCondition: _PropConditionMessage,
	ComparisonCondition: _ComparisonConditionMessage,
	ComparisonCondition_Op: _ComparisonCondition_OpMessage,
	IsNullCondition: _IsNullConditionMessage,
	IsNotNullCondition: _IsNotNullConditionMessage,
	AndCondition: _AndConditionMessage,
	OrCondition: _OrConditionMessage,
}
local messages: _Messages = {} :: _Messages

type _PropConditionImpl = {
	__index: _PropConditionImpl,
	new: (fields: _PropConditionPartialFields?) -> PropCondition,
	encode: (self: PropCondition) -> buffer,
	decode: (input: buffer) -> PropCondition,
	jsonEncode: (self: PropCondition) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> PropCondition,
	descriptor: proto.Descriptor,
}

type _PropConditionFields = {
	kind: (
		{ type: "comparison", value: ComparisonCondition }
		| { type: "is_null", value: IsNullCondition }
		| { type: "is_not_null", value: IsNotNullCondition }
		| { type: "and_condition", value: AndCondition }
		| { type: "or_condition", value: OrCondition }
	)?,
}

type _PropConditionPartialFields = {
	kind: (
		{ type: "comparison", value: ComparisonCondition }
		| { type: "is_null", value: IsNullCondition }
		| { type: "is_not_null", value: IsNotNullCondition }
		| { type: "and_condition", value: AndCondition }
		| { type: "or_condition", value: OrCondition }
	)?,
}

export type PropCondition = typeof(setmetatable({} :: _PropConditionFields, {} :: _PropConditionImpl))
type _PropConditionMessage = proto.Message<PropCondition, _PropConditionPartialFields>

type _ComparisonConditionImpl = {
	__index: _ComparisonConditionImpl,
	new: (fields: _ComparisonConditionPartialFields?) -> ComparisonCondition,
	encode: (self: ComparisonCondition) -> buffer,
	decode: (input: buffer) -> ComparisonCondition,
	jsonEncode: (self: ComparisonCondition) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ComparisonCondition,
	descriptor: proto.Descriptor,
}

type _ComparisonConditionFields = {
	field: string,
	op: ComparisonCondition_Op,
	kind: (
		{ type: "string_value", value: string }
		| { type: "bool_value", value: boolean }
		| { type: "int32_value", value: number }
		| { type: "int64_value", value: number }
		| { type: "float_value", value: number }
		| { type: "double_value", value: number }
	)?,
}

type _ComparisonConditionPartialFields = {
	field: string?,
	op: ComparisonCondition_Op?,
	kind: (
		{ type: "string_value", value: string }
		| { type: "bool_value", value: boolean }
		| { type: "int32_value", value: number }
		| { type: "int64_value", value: number }
		| { type: "float_value", value: number }
		| { type: "double_value", value: number }
	)?,
}

export type ComparisonCondition = typeof(setmetatable({} :: _ComparisonConditionFields, {} :: _ComparisonConditionImpl))
type _ComparisonConditionMessage = proto.Message<ComparisonCondition, _ComparisonConditionPartialFields>

type _ComparisonCondition_OpMessage = proto.Enum<ComparisonCondition_Op>
export type ComparisonCondition_Op = "OP_INVALID" | "OP_LT" | "OP_LTE" | "OP_GT" | "OP_GTE" | "OP_E" | "OP_NE" | number -- Unknown

type _IsNullConditionImpl = {
	__index: _IsNullConditionImpl,
	new: (fields: _IsNullConditionPartialFields?) -> IsNullCondition,
	encode: (self: IsNullCondition) -> buffer,
	decode: (input: buffer) -> IsNullCondition,
	jsonEncode: (self: IsNullCondition) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> IsNullCondition,
	descriptor: proto.Descriptor,
}

type _IsNullConditionFields = {
	field: string,
}

type _IsNullConditionPartialFields = {
	field: string?,
}

export type IsNullCondition = typeof(setmetatable({} :: _IsNullConditionFields, {} :: _IsNullConditionImpl))
type _IsNullConditionMessage = proto.Message<IsNullCondition, _IsNullConditionPartialFields>

type _IsNotNullConditionImpl = {
	__index: _IsNotNullConditionImpl,
	new: (fields: _IsNotNullConditionPartialFields?) -> IsNotNullCondition,
	encode: (self: IsNotNullCondition) -> buffer,
	decode: (input: buffer) -> IsNotNullCondition,
	jsonEncode: (self: IsNotNullCondition) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> IsNotNullCondition,
	descriptor: proto.Descriptor,
}

type _IsNotNullConditionFields = {
	field: string,
}

type _IsNotNullConditionPartialFields = {
	field: string?,
}

export type IsNotNullCondition = typeof(setmetatable({} :: _IsNotNullConditionFields, {} :: _IsNotNullConditionImpl))
type _IsNotNullConditionMessage = proto.Message<IsNotNullCondition, _IsNotNullConditionPartialFields>

type _AndConditionImpl = {
	__index: _AndConditionImpl,
	new: (fields: _AndConditionPartialFields?) -> AndCondition,
	encode: (self: AndCondition) -> buffer,
	decode: (input: buffer) -> AndCondition,
	jsonEncode: (self: AndCondition) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> AndCondition,
	descriptor: proto.Descriptor,
}

type _AndConditionFields = {
	conditions: { PropCondition },
}

type _AndConditionPartialFields = {
	conditions: { PropCondition }?,
}

export type AndCondition = typeof(setmetatable({} :: _AndConditionFields, {} :: _AndConditionImpl))
type _AndConditionMessage = proto.Message<AndCondition, _AndConditionPartialFields>

type _OrConditionImpl = {
	__index: _OrConditionImpl,
	new: (fields: _OrConditionPartialFields?) -> OrCondition,
	encode: (self: OrCondition) -> buffer,
	decode: (input: buffer) -> OrCondition,
	jsonEncode: (self: OrCondition) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OrCondition,
	descriptor: proto.Descriptor,
}

type _OrConditionFields = {
	conditions: { PropCondition },
}

type _OrConditionPartialFields = {
	conditions: { PropCondition }?,
}

export type OrCondition = typeof(setmetatable({} :: _OrConditionFields, {} :: _OrConditionImpl))
type _OrConditionMessage = proto.Message<OrCondition, _OrConditionPartialFields>

do
	local _PropConditionImpl = {}
	_PropConditionImpl.__index = _PropConditionImpl

	function _PropConditionImpl.new(data: _PropConditionPartialFields?): PropCondition
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _PropConditionImpl :: _PropConditionImpl)
	end

	function _PropConditionImpl.encode(self: PropCondition): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "comparison" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "is_null" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "is_not_null" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "and_condition" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "or_condition" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _PropConditionImpl.decode(input: buffer): PropCondition
		local self = _PropConditionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "comparison", value = messages.ComparisonCondition.decode(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "is_null", value = messages.IsNullCondition.decode(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "is_not_null", value = messages.IsNotNullCondition.decode(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "and_condition", value = messages.AndCondition.decode(value) }
					continue
				elseif field == 5 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "or_condition", value = messages.OrCondition.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _PropConditionImpl.jsonEncode(self: PropCondition): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "comparison" then
				output.comparison = self.kind.value:jsonEncode()
			elseif self.kind.type == "is_null" then
				output.isNull = self.kind.value:jsonEncode()
			elseif self.kind.type == "is_not_null" then
				output.isNotNull = self.kind.value:jsonEncode()
			elseif self.kind.type == "and_condition" then
				output.andCondition = self.kind.value:jsonEncode()
			elseif self.kind.type == "or_condition" then
				output.orCondition = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _PropConditionImpl.jsonDecode(input: { [string]: any }): PropCondition
		local self = _PropConditionImpl.new()

		if input.comparison ~= nil then
			self.kind = { type = "comparison", value = messages.ComparisonCondition.jsonDecode(input.comparison) }
		end

		if input.is_null ~= nil then
			self.kind = { type = "is_null", value = messages.IsNullCondition.jsonDecode(input.is_null) }
		end

		if input.isNull ~= nil then
			self.kind = { type = "is_null", value = messages.IsNullCondition.jsonDecode(input.isNull) }
		end

		if input.is_not_null ~= nil then
			self.kind = { type = "is_not_null", value = messages.IsNotNullCondition.jsonDecode(input.is_not_null) }
		end

		if input.isNotNull ~= nil then
			self.kind = { type = "is_not_null", value = messages.IsNotNullCondition.jsonDecode(input.isNotNull) }
		end

		if input.and_condition ~= nil then
			self.kind = { type = "and_condition", value = messages.AndCondition.jsonDecode(input.and_condition) }
		end

		if input.andCondition ~= nil then
			self.kind = { type = "and_condition", value = messages.AndCondition.jsonDecode(input.andCondition) }
		end

		if input.or_condition ~= nil then
			self.kind = { type = "or_condition", value = messages.OrCondition.jsonDecode(input.or_condition) }
		end

		if input.orCondition ~= nil then
			self.kind = { type = "or_condition", value = messages.OrCondition.jsonDecode(input.orCondition) }
		end

		return self
	end

	_PropConditionImpl.descriptor = {
		name = "PropCondition",
		fullName = "roblox.apppageplatform.shared.v1beta1.PropCondition",
	}

	messages.PropCondition = _PropConditionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.PropCondition)
end

do
	local _ComparisonConditionImpl = {}
	_ComparisonConditionImpl.__index = _ComparisonConditionImpl

	function _ComparisonConditionImpl.new(data: _ComparisonConditionPartialFields?): ComparisonCondition
		return setmetatable({
			field = if data == nil or data.field == nil then "" else data.field,
			op = if data == nil or data.op == nil
				then assert(messages.ComparisonCondition_Op.fromNumber(0), "Enum has no 0 default")
				else data.op,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _ComparisonConditionImpl :: _ComparisonConditionImpl)
	end

	function _ComparisonConditionImpl.encode(self: ComparisonCondition): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.field ~= nil and self.field ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.field)
		end

		if
			self.op ~= nil
			and (self.op ~= nil and self.op ~= 0 or self.op ~= messages.ComparisonCondition_Op.fromNumber(0))
		then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.ComparisonCondition_Op.toNumber(self.op :: any))
		end

		if self.kind ~= nil then
			if self.kind.type == "string_value" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "bool_value" then
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.varint)
				output, cursor = proto.writeVarInt(output, cursor, if self.kind.value then 1 else 0)
			elseif self.kind.type == "int32_value" then
				output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.varint)
				output, cursor = proto.writeVarInt(output, cursor, self.kind.value)
			elseif self.kind.type == "int64_value" then
				output, cursor = proto.writeTag(output, cursor, 6, proto.wireTypes.varint)
				output, cursor = proto.writeVarInt(output, cursor, self.kind.value)
			elseif self.kind.type == "float_value" then
				output, cursor = proto.writeTag(output, cursor, 7, proto.wireTypes.i32)
				output, cursor = proto.writeFloat(output, cursor, self.kind.value)
			elseif self.kind.type == "double_value" then
				output, cursor = proto.writeTag(output, cursor, 8, proto.wireTypes.i64)
				output, cursor = proto.writeDouble(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ComparisonConditionImpl.decode(input: buffer): ComparisonCondition
		local self = _ComparisonConditionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 2 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.op = (messages.ComparisonCondition_Op.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readVarInt(input, cursor)
					self.kind = { type = "bool_value", value = value ~= 0 }
					continue
				elseif field == 5 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.kind = { type = "int32_value", value = value }
					continue
				elseif field == 6 then
					local value
					value, cursor = proto.readVarIntI64(input, cursor)
					self.kind = { type = "int64_value", value = value }
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.field = buffer.tostring(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "string_value", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				if field == 7 then
					local value
					value, cursor = proto.readFloat(input, cursor)
					self.kind = { type = "float_value", value = value }
					continue
				end

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				if field == 8 then
					local value
					value, cursor = proto.readDouble(input, cursor)
					self.kind = { type = "double_value", value = value }
					continue
				end

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ComparisonConditionImpl.jsonEncode(self: ComparisonCondition): any
		local output = {}

		if self.field ~= nil and self.field ~= "" then
			output.field = self.field
		end

		if
			self.op ~= nil
			and (self.op ~= nil and self.op ~= 0 or self.op ~= messages.ComparisonCondition_Op.fromNumber(0))
		then
			output.op = if typeof(self.op) == "number"
				then self.op
				else messages.ComparisonCondition_Op.toNumber(self.op :: any)
		end

		if self.kind ~= nil then
			if self.kind.type == "string_value" then
				output.stringValue = self.kind.value
			elseif self.kind.type == "bool_value" then
				output.boolValue = self.kind.value
			elseif self.kind.type == "int32_value" then
				output.int32Value = self.kind.value
			elseif self.kind.type == "int64_value" then
				output.int64Value = self.kind.value
			elseif self.kind.type == "float_value" then
				output.floatValue = proto.json.serializeNumber(self.kind.value)
			elseif self.kind.type == "double_value" then
				output.doubleValue = proto.json.serializeNumber(self.kind.value)
			end
		end

		return output
	end

	function _ComparisonConditionImpl.jsonDecode(input: { [string]: any }): ComparisonCondition
		local self = _ComparisonConditionImpl.new()

		if input.field ~= nil then
			self.field = input.field
		end

		if input.op ~= nil then
			self.op = if typeof(input.op) == "number"
				then (messages.ComparisonCondition_Op.fromNumber(input.op) or input.op)
				else (messages.ComparisonCondition_Op.fromName(input.op) or input.op)
		end

		if input.string_value ~= nil then
			self.kind = { type = "string_value", value = input.string_value }
		end

		if input.stringValue ~= nil then
			self.kind = { type = "string_value", value = input.stringValue }
		end

		if input.bool_value ~= nil then
			self.kind = { type = "bool_value", value = input.bool_value }
		end

		if input.boolValue ~= nil then
			self.kind = { type = "bool_value", value = input.boolValue }
		end

		if input.int32_value ~= nil then
			self.kind = { type = "int32_value", value = input.int32_value }
		end

		if input.int32Value ~= nil then
			self.kind = { type = "int32_value", value = input.int32Value }
		end

		if input.int64_value ~= nil then
			self.kind = { type = "int64_value", value = input.int64_value }
		end

		if input.int64Value ~= nil then
			self.kind = { type = "int64_value", value = input.int64Value }
		end

		if input.float_value ~= nil then
			self.kind = { type = "float_value", value = proto.json.deserializeNumber(input.float_value) }
		end

		if input.floatValue ~= nil then
			self.kind = { type = "float_value", value = proto.json.deserializeNumber(input.floatValue) }
		end

		if input.double_value ~= nil then
			self.kind = { type = "double_value", value = proto.json.deserializeNumber(input.double_value) }
		end

		if input.doubleValue ~= nil then
			self.kind = { type = "double_value", value = proto.json.deserializeNumber(input.doubleValue) }
		end

		return self
	end

	_ComparisonConditionImpl.descriptor = {
		name = "ComparisonCondition",
		fullName = "roblox.apppageplatform.shared.v1beta1.ComparisonCondition",
	}

	messages.ComparisonCondition = _ComparisonConditionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ComparisonCondition)
end

messages.ComparisonCondition_Op = {
	fromNumber = function(value: number): ComparisonCondition_Op?
		if value == 0 then
			return "OP_INVALID"
		elseif value == 1 then
			return "OP_LT"
		elseif value == 2 then
			return "OP_LTE"
		elseif value == 3 then
			return "OP_GT"
		elseif value == 4 then
			return "OP_GTE"
		elseif value == 5 then
			return "OP_E"
		elseif value == 6 then
			return "OP_NE"
		else
			return nil
		end
	end,

	toNumber = function(self: ComparisonCondition_Op): number
		if self == "OP_INVALID" then
			return 0
		elseif self == "OP_LT" then
			return 1
		elseif self == "OP_LTE" then
			return 2
		elseif self == "OP_GT" then
			return 3
		elseif self == "OP_GTE" then
			return 4
		elseif self == "OP_E" then
			return 5
		elseif self == "OP_NE" then
			return 6
		else
			return self
		end
	end,

	fromName = function(name: string): ComparisonCondition_Op?
		if name == "OP_INVALID" then
			return "OP_INVALID"
		elseif name == "OP_LT" then
			return "OP_LT"
		elseif name == "OP_LTE" then
			return "OP_LTE"
		elseif name == "OP_GT" then
			return "OP_GT"
		elseif name == "OP_GTE" then
			return "OP_GTE"
		elseif name == "OP_E" then
			return "OP_E"
		elseif name == "OP_NE" then
			return "OP_NE"
		else
			return nil
		end
	end,
}

do
	local _IsNullConditionImpl = {}
	_IsNullConditionImpl.__index = _IsNullConditionImpl

	function _IsNullConditionImpl.new(data: _IsNullConditionPartialFields?): IsNullCondition
		return setmetatable({
			field = if data == nil or data.field == nil then "" else data.field,
		}, _IsNullConditionImpl :: _IsNullConditionImpl)
	end

	function _IsNullConditionImpl.encode(self: IsNullCondition): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.field ~= nil and self.field ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.field)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _IsNullConditionImpl.decode(input: buffer): IsNullCondition
		local self = _IsNullConditionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.field = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _IsNullConditionImpl.jsonEncode(self: IsNullCondition): any
		local output = {}

		if self.field ~= nil and self.field ~= "" then
			output.field = self.field
		end

		return output
	end

	function _IsNullConditionImpl.jsonDecode(input: { [string]: any }): IsNullCondition
		local self = _IsNullConditionImpl.new()

		if input.field ~= nil then
			self.field = input.field
		end

		return self
	end

	_IsNullConditionImpl.descriptor = {
		name = "IsNullCondition",
		fullName = "roblox.apppageplatform.shared.v1beta1.IsNullCondition",
	}

	messages.IsNullCondition = _IsNullConditionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.IsNullCondition)
end

do
	local _IsNotNullConditionImpl = {}
	_IsNotNullConditionImpl.__index = _IsNotNullConditionImpl

	function _IsNotNullConditionImpl.new(data: _IsNotNullConditionPartialFields?): IsNotNullCondition
		return setmetatable({
			field = if data == nil or data.field == nil then "" else data.field,
		}, _IsNotNullConditionImpl :: _IsNotNullConditionImpl)
	end

	function _IsNotNullConditionImpl.encode(self: IsNotNullCondition): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.field ~= nil and self.field ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.field)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _IsNotNullConditionImpl.decode(input: buffer): IsNotNullCondition
		local self = _IsNotNullConditionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.field = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _IsNotNullConditionImpl.jsonEncode(self: IsNotNullCondition): any
		local output = {}

		if self.field ~= nil and self.field ~= "" then
			output.field = self.field
		end

		return output
	end

	function _IsNotNullConditionImpl.jsonDecode(input: { [string]: any }): IsNotNullCondition
		local self = _IsNotNullConditionImpl.new()

		if input.field ~= nil then
			self.field = input.field
		end

		return self
	end

	_IsNotNullConditionImpl.descriptor = {
		name = "IsNotNullCondition",
		fullName = "roblox.apppageplatform.shared.v1beta1.IsNotNullCondition",
	}

	messages.IsNotNullCondition = _IsNotNullConditionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.IsNotNullCondition)
end

do
	local _AndConditionImpl = {}
	_AndConditionImpl.__index = _AndConditionImpl

	function _AndConditionImpl.new(data: _AndConditionPartialFields?): AndCondition
		return setmetatable({
			conditions = if data == nil or data.conditions == nil then {} else data.conditions,
		}, _AndConditionImpl :: _AndConditionImpl)
	end

	function _AndConditionImpl.encode(self: AndCondition): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.conditions ~= nil and #self.conditions > 0 then
			for _, value in self.conditions do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _AndConditionImpl.decode(input: buffer): AndCondition
		local self = _AndConditionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.conditions, messages.PropCondition.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _AndConditionImpl.jsonEncode(self: AndCondition): any
		local output = {}

		if self.conditions ~= nil and #self.conditions > 0 then
			local newOutput = {}
			for _, value in self.conditions do
				table.insert(newOutput, value:jsonEncode())
			end
			output.conditions = newOutput
		end

		return output
	end

	function _AndConditionImpl.jsonDecode(input: { [string]: any }): AndCondition
		local self = _AndConditionImpl.new()

		if input.conditions ~= nil then
			local newOutput: { PropCondition } = {}
			for _, value in input.conditions do
				table.insert(newOutput, messages.PropCondition.jsonDecode(value))
			end

			self.conditions = newOutput
		end

		return self
	end

	_AndConditionImpl.descriptor = {
		name = "AndCondition",
		fullName = "roblox.apppageplatform.shared.v1beta1.AndCondition",
	}

	messages.AndCondition = _AndConditionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.AndCondition)
end

do
	local _OrConditionImpl = {}
	_OrConditionImpl.__index = _OrConditionImpl

	function _OrConditionImpl.new(data: _OrConditionPartialFields?): OrCondition
		return setmetatable({
			conditions = if data == nil or data.conditions == nil then {} else data.conditions,
		}, _OrConditionImpl :: _OrConditionImpl)
	end

	function _OrConditionImpl.encode(self: OrCondition): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.conditions ~= nil and #self.conditions > 0 then
			for _, value in self.conditions do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OrConditionImpl.decode(input: buffer): OrCondition
		local self = _OrConditionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.conditions, messages.PropCondition.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OrConditionImpl.jsonEncode(self: OrCondition): any
		local output = {}

		if self.conditions ~= nil and #self.conditions > 0 then
			local newOutput = {}
			for _, value in self.conditions do
				table.insert(newOutput, value:jsonEncode())
			end
			output.conditions = newOutput
		end

		return output
	end

	function _OrConditionImpl.jsonDecode(input: { [string]: any }): OrCondition
		local self = _OrConditionImpl.new()

		if input.conditions ~= nil then
			local newOutput: { PropCondition } = {}
			for _, value in input.conditions do
				table.insert(newOutput, messages.PropCondition.jsonDecode(value))
			end

			self.conditions = newOutput
		end

		return self
	end

	_OrConditionImpl.descriptor = {
		name = "OrCondition",
		fullName = "roblox.apppageplatform.shared.v1beta1.OrCondition",
	}

	messages.OrCondition = _OrConditionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OrCondition)
end

return {
	PropCondition = messages.PropCondition,
	ComparisonCondition = messages.ComparisonCondition,
	ComparisonCondition_Op = messages.ComparisonCondition_Op,
	IsNullCondition = messages.IsNullCondition,
	IsNotNullCondition = messages.IsNotNullCondition,
	AndCondition = messages.AndCondition,
	OrCondition = messages.OrCondition,
}
