--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require(script.Parent.Parent.Parent.Parent.Parent.proto)
local typeRegistry = require(script.Parent.Parent.Parent.Parent.Parent.proto.typeRegistry)

type _Messages = {
	DismissDialogAction: _DismissDialogActionMessage,
	DismissDialogAction_Params: _DismissDialogAction_ParamsMessage,
	LinkAction: _LinkActionMessage,
	LinkAction_Params: _LinkAction_ParamsMessage,
	OpenGameDetailsAction: _OpenGameDetailsActionMessage,
	OpenGameDetailsAction_Params: _OpenGameDetailsAction_ParamsMessage,
	OpenJoinFriendsAction: _OpenJoinFriendsActionMessage,
	OpenJoinFriendsAction_Params: _OpenJoinFriendsAction_ParamsMessage,
	OpenMarketplaceTryOnAction: _OpenMarketplaceTryOnActionMessage,
	OpenMarketplaceTryOnAction_Params: _OpenMarketplaceTryOnAction_ParamsMessage,
	OpenSeeAllAction: _OpenSeeAllActionMessage,
	OpenSeeAllAction_Params: _OpenSeeAllAction_ParamsMessage,
	OpenSponsoredTooltipAction: _OpenSponsoredTooltipActionMessage,
	OpenSponsoredTooltipAction_Params: _OpenSponsoredTooltipAction_ParamsMessage,
	PlayButtonClickAction: _PlayButtonClickActionMessage,
	PlayButtonClickAction_Params: _PlayButtonClickAction_ParamsMessage,
	UpdateUserSettingsAction: _UpdateUserSettingsActionMessage,
	UpdateUserSettingsAction_Params: _UpdateUserSettingsAction_ParamsMessage,
	OpenTooltipAction: _OpenTooltipActionMessage,
	OpenTooltipAction_Params: _OpenTooltipAction_ParamsMessage,
	OpenBadgeDetailsAction: _OpenBadgeDetailsActionMessage,
	OpenBadgeDetailsAction_Params: _OpenBadgeDetailsAction_ParamsMessage,
	Action: _ActionMessage,
	ActionProp: _ActionPropMessage,
	ActionProp_ConditionalOption: _ActionProp_ConditionalOptionMessage,
	ActionProp_ConditionalOptions: _ActionProp_ConditionalOptionsMessage,
	FocusNavActionsProp: _FocusNavActionsPropMessage,
	FocusNavActionsProp_ConditionalOption: _FocusNavActionsProp_ConditionalOptionMessage,
	FocusNavActionsProp_ConditionalOptions: _FocusNavActionsProp_ConditionalOptionsMessage,
	FocusNavActionsProp_FocusNavData: _FocusNavActionsProp_FocusNavDataMessage,
	FocusNavActionsProp_FocusNavData_KeysEntry: _FocusNavActionsProp_FocusNavData_KeysEntryMessage,
	FocusNavActionsProp_FocusNavData_EventsEntry: _FocusNavActionsProp_FocusNavData_EventsEntryMessage,
	ActionType: _ActionTypeMessage,
}
local messages: _Messages = {} :: _Messages

local _google_protobuf_struct = require(script.Parent.Parent.Parent.Parent.Parent.google.protobuf.struct)
local _roblox_apppageplatform_shared_v1beta1_prop_condition = require(script.Parent.prop_condition)
local _roblox_apppageplatform_shared_v1beta1_prop_types = require(script.Parent.prop_types)

type _DismissDialogActionImpl = {
	__index: _DismissDialogActionImpl,
	new: (fields: _DismissDialogActionPartialFields?) -> DismissDialogAction,
	encode: (self: DismissDialogAction) -> buffer,
	decode: (input: buffer) -> DismissDialogAction,
	jsonEncode: (self: DismissDialogAction) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> DismissDialogAction,
	descriptor: proto.Descriptor,
}

type _DismissDialogActionFields = {
	action_type: ActionType,
	action_params: DismissDialogAction_Params?,
}

type _DismissDialogActionPartialFields = {
	action_type: ActionType?,
	action_params: DismissDialogAction_Params?,
}

export type DismissDialogAction = typeof(setmetatable({} :: _DismissDialogActionFields, {} :: _DismissDialogActionImpl))
type _DismissDialogActionMessage = proto.Message<DismissDialogAction, _DismissDialogActionPartialFields>

type _DismissDialogAction_ParamsImpl = {
	__index: _DismissDialogAction_ParamsImpl,
	new: (fields: _DismissDialogAction_ParamsPartialFields?) -> DismissDialogAction_Params,
	encode: (self: DismissDialogAction_Params) -> buffer,
	decode: (input: buffer) -> DismissDialogAction_Params,
	jsonEncode: (self: DismissDialogAction_Params) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> DismissDialogAction_Params,
	descriptor: proto.Descriptor,
}

type _DismissDialogAction_ParamsFields = {
	dialog_type: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

type _DismissDialogAction_ParamsPartialFields = {
	dialog_type: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

export type DismissDialogAction_Params = typeof(setmetatable(
	{} :: _DismissDialogAction_ParamsFields,
	{} :: _DismissDialogAction_ParamsImpl
))
type _DismissDialogAction_ParamsMessage = proto.Message<
	DismissDialogAction_Params,
	_DismissDialogAction_ParamsPartialFields
>

type _LinkActionImpl = {
	__index: _LinkActionImpl,
	new: (fields: _LinkActionPartialFields?) -> LinkAction,
	encode: (self: LinkAction) -> buffer,
	decode: (input: buffer) -> LinkAction,
	jsonEncode: (self: LinkAction) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> LinkAction,
	descriptor: proto.Descriptor,
}

type _LinkActionFields = {
	action_type: ActionType,
	action_params: LinkAction_Params?,
}

type _LinkActionPartialFields = {
	action_type: ActionType?,
	action_params: LinkAction_Params?,
}

export type LinkAction = typeof(setmetatable({} :: _LinkActionFields, {} :: _LinkActionImpl))
type _LinkActionMessage = proto.Message<LinkAction, _LinkActionPartialFields>

type _LinkAction_ParamsImpl = {
	__index: _LinkAction_ParamsImpl,
	new: (fields: _LinkAction_ParamsPartialFields?) -> LinkAction_Params,
	encode: (self: LinkAction_Params) -> buffer,
	decode: (input: buffer) -> LinkAction_Params,
	jsonEncode: (self: LinkAction_Params) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> LinkAction_Params,
	descriptor: proto.Descriptor,
}

type _LinkAction_ParamsFields = {
	url: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

type _LinkAction_ParamsPartialFields = {
	url: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

export type LinkAction_Params = typeof(setmetatable({} :: _LinkAction_ParamsFields, {} :: _LinkAction_ParamsImpl))
type _LinkAction_ParamsMessage = proto.Message<LinkAction_Params, _LinkAction_ParamsPartialFields>

type _OpenGameDetailsActionImpl = {
	__index: _OpenGameDetailsActionImpl,
	new: (fields: _OpenGameDetailsActionPartialFields?) -> OpenGameDetailsAction,
	encode: (self: OpenGameDetailsAction) -> buffer,
	decode: (input: buffer) -> OpenGameDetailsAction,
	jsonEncode: (self: OpenGameDetailsAction) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenGameDetailsAction,
	descriptor: proto.Descriptor,
}

type _OpenGameDetailsActionFields = {
	action_type: ActionType,
	action_params: OpenGameDetailsAction_Params?,
}

type _OpenGameDetailsActionPartialFields = {
	action_type: ActionType?,
	action_params: OpenGameDetailsAction_Params?,
}

export type OpenGameDetailsAction = typeof(setmetatable(
	{} :: _OpenGameDetailsActionFields,
	{} :: _OpenGameDetailsActionImpl
))
type _OpenGameDetailsActionMessage = proto.Message<OpenGameDetailsAction, _OpenGameDetailsActionPartialFields>

type _OpenGameDetailsAction_ParamsImpl = {
	__index: _OpenGameDetailsAction_ParamsImpl,
	new: (fields: _OpenGameDetailsAction_ParamsPartialFields?) -> OpenGameDetailsAction_Params,
	encode: (self: OpenGameDetailsAction_Params) -> buffer,
	decode: (input: buffer) -> OpenGameDetailsAction_Params,
	jsonEncode: (self: OpenGameDetailsAction_Params) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenGameDetailsAction_Params,
	descriptor: proto.Descriptor,
}

type _OpenGameDetailsAction_ParamsFields = {
	place_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	universe_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

type _OpenGameDetailsAction_ParamsPartialFields = {
	place_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	universe_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

export type OpenGameDetailsAction_Params = typeof(setmetatable(
	{} :: _OpenGameDetailsAction_ParamsFields,
	{} :: _OpenGameDetailsAction_ParamsImpl
))
type _OpenGameDetailsAction_ParamsMessage = proto.Message<
	OpenGameDetailsAction_Params,
	_OpenGameDetailsAction_ParamsPartialFields
>

type _OpenJoinFriendsActionImpl = {
	__index: _OpenJoinFriendsActionImpl,
	new: (fields: _OpenJoinFriendsActionPartialFields?) -> OpenJoinFriendsAction,
	encode: (self: OpenJoinFriendsAction) -> buffer,
	decode: (input: buffer) -> OpenJoinFriendsAction,
	jsonEncode: (self: OpenJoinFriendsAction) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenJoinFriendsAction,
	descriptor: proto.Descriptor,
}

type _OpenJoinFriendsActionFields = {
	action_type: ActionType,
	action_params: OpenJoinFriendsAction_Params?,
}

type _OpenJoinFriendsActionPartialFields = {
	action_type: ActionType?,
	action_params: OpenJoinFriendsAction_Params?,
}

export type OpenJoinFriendsAction = typeof(setmetatable(
	{} :: _OpenJoinFriendsActionFields,
	{} :: _OpenJoinFriendsActionImpl
))
type _OpenJoinFriendsActionMessage = proto.Message<OpenJoinFriendsAction, _OpenJoinFriendsActionPartialFields>

type _OpenJoinFriendsAction_ParamsImpl = {
	__index: _OpenJoinFriendsAction_ParamsImpl,
	new: (fields: _OpenJoinFriendsAction_ParamsPartialFields?) -> OpenJoinFriendsAction_Params,
	encode: (self: OpenJoinFriendsAction_Params) -> buffer,
	decode: (input: buffer) -> OpenJoinFriendsAction_Params,
	jsonEncode: (self: OpenJoinFriendsAction_Params) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenJoinFriendsAction_Params,
	descriptor: proto.Descriptor,
}

type _OpenJoinFriendsAction_ParamsFields = {
	place_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	universe_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

type _OpenJoinFriendsAction_ParamsPartialFields = {
	place_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	universe_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

export type OpenJoinFriendsAction_Params = typeof(setmetatable(
	{} :: _OpenJoinFriendsAction_ParamsFields,
	{} :: _OpenJoinFriendsAction_ParamsImpl
))
type _OpenJoinFriendsAction_ParamsMessage = proto.Message<
	OpenJoinFriendsAction_Params,
	_OpenJoinFriendsAction_ParamsPartialFields
>

type _OpenMarketplaceTryOnActionImpl = {
	__index: _OpenMarketplaceTryOnActionImpl,
	new: (fields: _OpenMarketplaceTryOnActionPartialFields?) -> OpenMarketplaceTryOnAction,
	encode: (self: OpenMarketplaceTryOnAction) -> buffer,
	decode: (input: buffer) -> OpenMarketplaceTryOnAction,
	jsonEncode: (self: OpenMarketplaceTryOnAction) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenMarketplaceTryOnAction,
	descriptor: proto.Descriptor,
}

type _OpenMarketplaceTryOnActionFields = {
	action_type: ActionType,
	action_params: OpenMarketplaceTryOnAction_Params?,
}

type _OpenMarketplaceTryOnActionPartialFields = {
	action_type: ActionType?,
	action_params: OpenMarketplaceTryOnAction_Params?,
}

export type OpenMarketplaceTryOnAction = typeof(setmetatable(
	{} :: _OpenMarketplaceTryOnActionFields,
	{} :: _OpenMarketplaceTryOnActionImpl
))
type _OpenMarketplaceTryOnActionMessage = proto.Message<
	OpenMarketplaceTryOnAction,
	_OpenMarketplaceTryOnActionPartialFields
>

type _OpenMarketplaceTryOnAction_ParamsImpl = {
	__index: _OpenMarketplaceTryOnAction_ParamsImpl,
	new: (fields: _OpenMarketplaceTryOnAction_ParamsPartialFields?) -> OpenMarketplaceTryOnAction_Params,
	encode: (self: OpenMarketplaceTryOnAction_Params) -> buffer,
	decode: (input: buffer) -> OpenMarketplaceTryOnAction_Params,
	jsonEncode: (self: OpenMarketplaceTryOnAction_Params) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenMarketplaceTryOnAction_Params,
	descriptor: proto.Descriptor,
}

type _OpenMarketplaceTryOnAction_ParamsFields = {
	item_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	item_type: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	item_sub_type_name: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

type _OpenMarketplaceTryOnAction_ParamsPartialFields = {
	item_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	item_type: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	item_sub_type_name: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

export type OpenMarketplaceTryOnAction_Params = typeof(setmetatable(
	{} :: _OpenMarketplaceTryOnAction_ParamsFields,
	{} :: _OpenMarketplaceTryOnAction_ParamsImpl
))
type _OpenMarketplaceTryOnAction_ParamsMessage = proto.Message<
	OpenMarketplaceTryOnAction_Params,
	_OpenMarketplaceTryOnAction_ParamsPartialFields
>

type _OpenSeeAllActionImpl = {
	__index: _OpenSeeAllActionImpl,
	new: (fields: _OpenSeeAllActionPartialFields?) -> OpenSeeAllAction,
	encode: (self: OpenSeeAllAction) -> buffer,
	decode: (input: buffer) -> OpenSeeAllAction,
	jsonEncode: (self: OpenSeeAllAction) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenSeeAllAction,
	descriptor: proto.Descriptor,
}

type _OpenSeeAllActionFields = {
	action_type: ActionType,
	action_params: OpenSeeAllAction_Params?,
}

type _OpenSeeAllActionPartialFields = {
	action_type: ActionType?,
	action_params: OpenSeeAllAction_Params?,
}

export type OpenSeeAllAction = typeof(setmetatable({} :: _OpenSeeAllActionFields, {} :: _OpenSeeAllActionImpl))
type _OpenSeeAllActionMessage = proto.Message<OpenSeeAllAction, _OpenSeeAllActionPartialFields>

type _OpenSeeAllAction_ParamsImpl = {
	__index: _OpenSeeAllAction_ParamsImpl,
	new: (fields: _OpenSeeAllAction_ParamsPartialFields?) -> OpenSeeAllAction_Params,
	encode: (self: OpenSeeAllAction_Params) -> buffer,
	decode: (input: buffer) -> OpenSeeAllAction_Params,
	jsonEncode: (self: OpenSeeAllAction_Params) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenSeeAllAction_Params,
	descriptor: proto.Descriptor,
}

type _OpenSeeAllAction_ParamsFields = {
	collection_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	game_set_target_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	collection_position: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

type _OpenSeeAllAction_ParamsPartialFields = {
	collection_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	game_set_target_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	collection_position: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

export type OpenSeeAllAction_Params = typeof(setmetatable(
	{} :: _OpenSeeAllAction_ParamsFields,
	{} :: _OpenSeeAllAction_ParamsImpl
))
type _OpenSeeAllAction_ParamsMessage = proto.Message<OpenSeeAllAction_Params, _OpenSeeAllAction_ParamsPartialFields>

type _OpenSponsoredTooltipActionImpl = {
	__index: _OpenSponsoredTooltipActionImpl,
	new: (fields: _OpenSponsoredTooltipActionPartialFields?) -> OpenSponsoredTooltipAction,
	encode: (self: OpenSponsoredTooltipAction) -> buffer,
	decode: (input: buffer) -> OpenSponsoredTooltipAction,
	jsonEncode: (self: OpenSponsoredTooltipAction) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenSponsoredTooltipAction,
	descriptor: proto.Descriptor,
}

type _OpenSponsoredTooltipActionFields = {
	action_type: ActionType,
	action_params: OpenSponsoredTooltipAction_Params?,
}

type _OpenSponsoredTooltipActionPartialFields = {
	action_type: ActionType?,
	action_params: OpenSponsoredTooltipAction_Params?,
}

export type OpenSponsoredTooltipAction = typeof(setmetatable(
	{} :: _OpenSponsoredTooltipActionFields,
	{} :: _OpenSponsoredTooltipActionImpl
))
type _OpenSponsoredTooltipActionMessage = proto.Message<
	OpenSponsoredTooltipAction,
	_OpenSponsoredTooltipActionPartialFields
>

type _OpenSponsoredTooltipAction_ParamsImpl = {
	__index: _OpenSponsoredTooltipAction_ParamsImpl,
	new: (fields: _OpenSponsoredTooltipAction_ParamsPartialFields?) -> OpenSponsoredTooltipAction_Params,
	encode: (self: OpenSponsoredTooltipAction_Params) -> buffer,
	decode: (input: buffer) -> OpenSponsoredTooltipAction_Params,
	jsonEncode: (self: OpenSponsoredTooltipAction_Params) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenSponsoredTooltipAction_Params,
	descriptor: proto.Descriptor,
}

type _OpenSponsoredTooltipAction_ParamsFields = {}

type _OpenSponsoredTooltipAction_ParamsPartialFields = {}

export type OpenSponsoredTooltipAction_Params = typeof(setmetatable(
	{} :: _OpenSponsoredTooltipAction_ParamsFields,
	{} :: _OpenSponsoredTooltipAction_ParamsImpl
))
type _OpenSponsoredTooltipAction_ParamsMessage = proto.Message<
	OpenSponsoredTooltipAction_Params,
	_OpenSponsoredTooltipAction_ParamsPartialFields
>

type _PlayButtonClickActionImpl = {
	__index: _PlayButtonClickActionImpl,
	new: (fields: _PlayButtonClickActionPartialFields?) -> PlayButtonClickAction,
	encode: (self: PlayButtonClickAction) -> buffer,
	decode: (input: buffer) -> PlayButtonClickAction,
	jsonEncode: (self: PlayButtonClickAction) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> PlayButtonClickAction,
	descriptor: proto.Descriptor,
}

type _PlayButtonClickActionFields = {
	action_type: ActionType,
	action_params: PlayButtonClickAction_Params?,
}

type _PlayButtonClickActionPartialFields = {
	action_type: ActionType?,
	action_params: PlayButtonClickAction_Params?,
}

export type PlayButtonClickAction = typeof(setmetatable(
	{} :: _PlayButtonClickActionFields,
	{} :: _PlayButtonClickActionImpl
))
type _PlayButtonClickActionMessage = proto.Message<PlayButtonClickAction, _PlayButtonClickActionPartialFields>

type _PlayButtonClickAction_ParamsImpl = {
	__index: _PlayButtonClickAction_ParamsImpl,
	new: (fields: _PlayButtonClickAction_ParamsPartialFields?) -> PlayButtonClickAction_Params,
	encode: (self: PlayButtonClickAction_Params) -> buffer,
	decode: (input: buffer) -> PlayButtonClickAction_Params,
	jsonEncode: (self: PlayButtonClickAction_Params) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> PlayButtonClickAction_Params,
	descriptor: proto.Descriptor,
}

type _PlayButtonClickAction_ParamsFields = {}

type _PlayButtonClickAction_ParamsPartialFields = {}

export type PlayButtonClickAction_Params = typeof(setmetatable(
	{} :: _PlayButtonClickAction_ParamsFields,
	{} :: _PlayButtonClickAction_ParamsImpl
))
type _PlayButtonClickAction_ParamsMessage = proto.Message<
	PlayButtonClickAction_Params,
	_PlayButtonClickAction_ParamsPartialFields
>

type _UpdateUserSettingsActionImpl = {
	__index: _UpdateUserSettingsActionImpl,
	new: (fields: _UpdateUserSettingsActionPartialFields?) -> UpdateUserSettingsAction,
	encode: (self: UpdateUserSettingsAction) -> buffer,
	decode: (input: buffer) -> UpdateUserSettingsAction,
	jsonEncode: (self: UpdateUserSettingsAction) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> UpdateUserSettingsAction,
	descriptor: proto.Descriptor,
}

type _UpdateUserSettingsActionFields = {
	action_type: ActionType,
	action_params: UpdateUserSettingsAction_Params?,
}

type _UpdateUserSettingsActionPartialFields = {
	action_type: ActionType?,
	action_params: UpdateUserSettingsAction_Params?,
}

export type UpdateUserSettingsAction = typeof(setmetatable(
	{} :: _UpdateUserSettingsActionFields,
	{} :: _UpdateUserSettingsActionImpl
))
type _UpdateUserSettingsActionMessage = proto.Message<UpdateUserSettingsAction, _UpdateUserSettingsActionPartialFields>

type _UpdateUserSettingsAction_ParamsImpl = {
	__index: _UpdateUserSettingsAction_ParamsImpl,
	new: (fields: _UpdateUserSettingsAction_ParamsPartialFields?) -> UpdateUserSettingsAction_Params,
	encode: (self: UpdateUserSettingsAction_Params) -> buffer,
	decode: (input: buffer) -> UpdateUserSettingsAction_Params,
	jsonEncode: (self: UpdateUserSettingsAction_Params) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> UpdateUserSettingsAction_Params,
	descriptor: proto.Descriptor,
}

type _UpdateUserSettingsAction_ParamsFields = {
	settings: _roblox_apppageplatform_shared_v1beta1_prop_types.StructProp?,
	audit_data: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

type _UpdateUserSettingsAction_ParamsPartialFields = {
	settings: _roblox_apppageplatform_shared_v1beta1_prop_types.StructProp?,
	audit_data: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

export type UpdateUserSettingsAction_Params = typeof(setmetatable(
	{} :: _UpdateUserSettingsAction_ParamsFields,
	{} :: _UpdateUserSettingsAction_ParamsImpl
))
type _UpdateUserSettingsAction_ParamsMessage = proto.Message<
	UpdateUserSettingsAction_Params,
	_UpdateUserSettingsAction_ParamsPartialFields
>

type _OpenTooltipActionImpl = {
	__index: _OpenTooltipActionImpl,
	new: (fields: _OpenTooltipActionPartialFields?) -> OpenTooltipAction,
	encode: (self: OpenTooltipAction) -> buffer,
	decode: (input: buffer) -> OpenTooltipAction,
	jsonEncode: (self: OpenTooltipAction) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenTooltipAction,
	descriptor: proto.Descriptor,
}

type _OpenTooltipActionFields = {
	action_type: ActionType,
	action_params: OpenTooltipAction_Params?,
}

type _OpenTooltipActionPartialFields = {
	action_type: ActionType?,
	action_params: OpenTooltipAction_Params?,
}

export type OpenTooltipAction = typeof(setmetatable({} :: _OpenTooltipActionFields, {} :: _OpenTooltipActionImpl))
type _OpenTooltipActionMessage = proto.Message<OpenTooltipAction, _OpenTooltipActionPartialFields>

type _OpenTooltipAction_ParamsImpl = {
	__index: _OpenTooltipAction_ParamsImpl,
	new: (fields: _OpenTooltipAction_ParamsPartialFields?) -> OpenTooltipAction_Params,
	encode: (self: OpenTooltipAction_Params) -> buffer,
	decode: (input: buffer) -> OpenTooltipAction_Params,
	jsonEncode: (self: OpenTooltipAction_Params) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenTooltipAction_Params,
	descriptor: proto.Descriptor,
}

type _OpenTooltipAction_ParamsFields = {
	tooltip_title: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	tooltip_info_text: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

type _OpenTooltipAction_ParamsPartialFields = {
	tooltip_title: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	tooltip_info_text: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

export type OpenTooltipAction_Params = typeof(setmetatable(
	{} :: _OpenTooltipAction_ParamsFields,
	{} :: _OpenTooltipAction_ParamsImpl
))
type _OpenTooltipAction_ParamsMessage = proto.Message<OpenTooltipAction_Params, _OpenTooltipAction_ParamsPartialFields>

type _OpenBadgeDetailsActionImpl = {
	__index: _OpenBadgeDetailsActionImpl,
	new: (fields: _OpenBadgeDetailsActionPartialFields?) -> OpenBadgeDetailsAction,
	encode: (self: OpenBadgeDetailsAction) -> buffer,
	decode: (input: buffer) -> OpenBadgeDetailsAction,
	jsonEncode: (self: OpenBadgeDetailsAction) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenBadgeDetailsAction,
	descriptor: proto.Descriptor,
}

type _OpenBadgeDetailsActionFields = {
	action_type: ActionType,
	action_params: OpenBadgeDetailsAction_Params?,
}

type _OpenBadgeDetailsActionPartialFields = {
	action_type: ActionType?,
	action_params: OpenBadgeDetailsAction_Params?,
}

export type OpenBadgeDetailsAction = typeof(setmetatable(
	{} :: _OpenBadgeDetailsActionFields,
	{} :: _OpenBadgeDetailsActionImpl
))
type _OpenBadgeDetailsActionMessage = proto.Message<OpenBadgeDetailsAction, _OpenBadgeDetailsActionPartialFields>

type _OpenBadgeDetailsAction_ParamsImpl = {
	__index: _OpenBadgeDetailsAction_ParamsImpl,
	new: (fields: _OpenBadgeDetailsAction_ParamsPartialFields?) -> OpenBadgeDetailsAction_Params,
	encode: (self: OpenBadgeDetailsAction_Params) -> buffer,
	decode: (input: buffer) -> OpenBadgeDetailsAction_Params,
	jsonEncode: (self: OpenBadgeDetailsAction_Params) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> OpenBadgeDetailsAction_Params,
	descriptor: proto.Descriptor,
}

type _OpenBadgeDetailsAction_ParamsFields = {
	badge_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	title_text: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

type _OpenBadgeDetailsAction_ParamsPartialFields = {
	badge_id: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
	title_text: _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp?,
}

export type OpenBadgeDetailsAction_Params = typeof(setmetatable(
	{} :: _OpenBadgeDetailsAction_ParamsFields,
	{} :: _OpenBadgeDetailsAction_ParamsImpl
))
type _OpenBadgeDetailsAction_ParamsMessage = proto.Message<
	OpenBadgeDetailsAction_Params,
	_OpenBadgeDetailsAction_ParamsPartialFields
>

type _ActionImpl = {
	__index: _ActionImpl,
	new: (fields: _ActionPartialFields?) -> Action,
	encode: (self: Action) -> buffer,
	decode: (input: buffer) -> Action,
	jsonEncode: (self: Action) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Action,
	descriptor: proto.Descriptor,
}

type _ActionFields = {
	kind: (
		{ type: "dismiss_dialog_action", value: DismissDialogAction }
		| { type: "link_action", value: LinkAction }
		| { type: "open_game_details_action", value: OpenGameDetailsAction }
		| { type: "open_join_friends_action", value: OpenJoinFriendsAction }
		| { type: "open_marketplace_try_on_action", value: OpenMarketplaceTryOnAction }
		| { type: "open_see_all_action", value: OpenSeeAllAction }
		| { type: "open_sponsored_tooltip_action", value: OpenSponsoredTooltipAction }
		| { type: "play_button_click_action", value: PlayButtonClickAction }
		| { type: "update_user_settings_action", value: UpdateUserSettingsAction }
		| { type: "open_tooltip_action", value: OpenTooltipAction }
		| { type: "open_badge_details_action", value: OpenBadgeDetailsAction }
	)?,
}

type _ActionPartialFields = {
	kind: (
		{ type: "dismiss_dialog_action", value: DismissDialogAction }
		| { type: "link_action", value: LinkAction }
		| { type: "open_game_details_action", value: OpenGameDetailsAction }
		| { type: "open_join_friends_action", value: OpenJoinFriendsAction }
		| { type: "open_marketplace_try_on_action", value: OpenMarketplaceTryOnAction }
		| { type: "open_see_all_action", value: OpenSeeAllAction }
		| { type: "open_sponsored_tooltip_action", value: OpenSponsoredTooltipAction }
		| { type: "play_button_click_action", value: PlayButtonClickAction }
		| { type: "update_user_settings_action", value: UpdateUserSettingsAction }
		| { type: "open_tooltip_action", value: OpenTooltipAction }
		| { type: "open_badge_details_action", value: OpenBadgeDetailsAction }
	)?,
}

export type Action = typeof(setmetatable({} :: _ActionFields, {} :: _ActionImpl))
type _ActionMessage = proto.Message<Action, _ActionPartialFields>

type _ActionPropImpl = {
	__index: _ActionPropImpl,
	new: (fields: _ActionPropPartialFields?) -> ActionProp,
	encode: (self: ActionProp) -> buffer,
	decode: (input: buffer) -> ActionProp,
	jsonEncode: (self: ActionProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ActionProp,
	descriptor: proto.Descriptor,
}

type _ActionPropFields = {
	kind: ({ type: "value", value: Action } | { type: "conditional", value: ActionProp_ConditionalOptions })?,
}

type _ActionPropPartialFields = {
	kind: ({ type: "value", value: Action } | { type: "conditional", value: ActionProp_ConditionalOptions })?,
}

export type ActionProp = typeof(setmetatable({} :: _ActionPropFields, {} :: _ActionPropImpl))
type _ActionPropMessage = proto.Message<ActionProp, _ActionPropPartialFields>

type _ActionProp_ConditionalOptionImpl = {
	__index: _ActionProp_ConditionalOptionImpl,
	new: (fields: _ActionProp_ConditionalOptionPartialFields?) -> ActionProp_ConditionalOption,
	encode: (self: ActionProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> ActionProp_ConditionalOption,
	jsonEncode: (self: ActionProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ActionProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _ActionProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	value: Action?,
}

type _ActionProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	value: Action?,
}

export type ActionProp_ConditionalOption = typeof(setmetatable(
	{} :: _ActionProp_ConditionalOptionFields,
	{} :: _ActionProp_ConditionalOptionImpl
))
type _ActionProp_ConditionalOptionMessage = proto.Message<
	ActionProp_ConditionalOption,
	_ActionProp_ConditionalOptionPartialFields
>

type _ActionProp_ConditionalOptionsImpl = {
	__index: _ActionProp_ConditionalOptionsImpl,
	new: (fields: _ActionProp_ConditionalOptionsPartialFields?) -> ActionProp_ConditionalOptions,
	encode: (self: ActionProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> ActionProp_ConditionalOptions,
	jsonEncode: (self: ActionProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ActionProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _ActionProp_ConditionalOptionsFields = {
	options: { ActionProp_ConditionalOption },
}

type _ActionProp_ConditionalOptionsPartialFields = {
	options: { ActionProp_ConditionalOption }?,
}

export type ActionProp_ConditionalOptions = typeof(setmetatable(
	{} :: _ActionProp_ConditionalOptionsFields,
	{} :: _ActionProp_ConditionalOptionsImpl
))
type _ActionProp_ConditionalOptionsMessage = proto.Message<
	ActionProp_ConditionalOptions,
	_ActionProp_ConditionalOptionsPartialFields
>

type _FocusNavActionsPropImpl = {
	__index: _FocusNavActionsPropImpl,
	new: (fields: _FocusNavActionsPropPartialFields?) -> FocusNavActionsProp,
	encode: (self: FocusNavActionsProp) -> buffer,
	decode: (input: buffer) -> FocusNavActionsProp,
	jsonEncode: (self: FocusNavActionsProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> FocusNavActionsProp,
	descriptor: proto.Descriptor,
}

type _FocusNavActionsPropFields = {
	kind: (
		{ type: "value", value: FocusNavActionsProp_FocusNavData }
		| { type: "conditional", value: FocusNavActionsProp_ConditionalOptions }
	)?,
}

type _FocusNavActionsPropPartialFields = {
	kind: (
		{ type: "value", value: FocusNavActionsProp_FocusNavData }
		| { type: "conditional", value: FocusNavActionsProp_ConditionalOptions }
	)?,
}

export type FocusNavActionsProp = typeof(setmetatable({} :: _FocusNavActionsPropFields, {} :: _FocusNavActionsPropImpl))
type _FocusNavActionsPropMessage = proto.Message<FocusNavActionsProp, _FocusNavActionsPropPartialFields>

type _FocusNavActionsProp_ConditionalOptionImpl = {
	__index: _FocusNavActionsProp_ConditionalOptionImpl,
	new: (fields: _FocusNavActionsProp_ConditionalOptionPartialFields?) -> FocusNavActionsProp_ConditionalOption,
	encode: (self: FocusNavActionsProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> FocusNavActionsProp_ConditionalOption,
	jsonEncode: (self: FocusNavActionsProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> FocusNavActionsProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _FocusNavActionsProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	value: FocusNavActionsProp?,
}

type _FocusNavActionsProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	value: FocusNavActionsProp?,
}

export type FocusNavActionsProp_ConditionalOption = typeof(setmetatable(
	{} :: _FocusNavActionsProp_ConditionalOptionFields,
	{} :: _FocusNavActionsProp_ConditionalOptionImpl
))
type _FocusNavActionsProp_ConditionalOptionMessage = proto.Message<
	FocusNavActionsProp_ConditionalOption,
	_FocusNavActionsProp_ConditionalOptionPartialFields
>

type _FocusNavActionsProp_ConditionalOptionsImpl = {
	__index: _FocusNavActionsProp_ConditionalOptionsImpl,
	new: (fields: _FocusNavActionsProp_ConditionalOptionsPartialFields?) -> FocusNavActionsProp_ConditionalOptions,
	encode: (self: FocusNavActionsProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> FocusNavActionsProp_ConditionalOptions,
	jsonEncode: (self: FocusNavActionsProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> FocusNavActionsProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _FocusNavActionsProp_ConditionalOptionsFields = {
	options: { FocusNavActionsProp_ConditionalOption },
}

type _FocusNavActionsProp_ConditionalOptionsPartialFields = {
	options: { FocusNavActionsProp_ConditionalOption }?,
}

export type FocusNavActionsProp_ConditionalOptions = typeof(setmetatable(
	{} :: _FocusNavActionsProp_ConditionalOptionsFields,
	{} :: _FocusNavActionsProp_ConditionalOptionsImpl
))
type _FocusNavActionsProp_ConditionalOptionsMessage = proto.Message<
	FocusNavActionsProp_ConditionalOptions,
	_FocusNavActionsProp_ConditionalOptionsPartialFields
>

type _FocusNavActionsProp_FocusNavDataImpl = {
	__index: _FocusNavActionsProp_FocusNavDataImpl,
	new: (fields: _FocusNavActionsProp_FocusNavDataPartialFields?) -> FocusNavActionsProp_FocusNavData,
	encode: (self: FocusNavActionsProp_FocusNavData) -> buffer,
	decode: (input: buffer) -> FocusNavActionsProp_FocusNavData,
	jsonEncode: (self: FocusNavActionsProp_FocusNavData) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> FocusNavActionsProp_FocusNavData,
	descriptor: proto.Descriptor,
}

type _FocusNavActionsProp_FocusNavDataFields = {
	keys: { [string]: string },
	events: { [string]: _google_protobuf_struct.Struct },
}

type _FocusNavActionsProp_FocusNavDataPartialFields = {
	keys: { [string]: string }?,
	events: { [string]: _google_protobuf_struct.Struct }?,
}

export type FocusNavActionsProp_FocusNavData = typeof(setmetatable(
	{} :: _FocusNavActionsProp_FocusNavDataFields,
	{} :: _FocusNavActionsProp_FocusNavDataImpl
))
type _FocusNavActionsProp_FocusNavDataMessage = proto.Message<
	FocusNavActionsProp_FocusNavData,
	_FocusNavActionsProp_FocusNavDataPartialFields
>

type _FocusNavActionsProp_FocusNavData_KeysEntryImpl = {
	__index: _FocusNavActionsProp_FocusNavData_KeysEntryImpl,
	new: (
		fields: _FocusNavActionsProp_FocusNavData_KeysEntryPartialFields?
	) -> FocusNavActionsProp_FocusNavData_KeysEntry,
	encode: (self: FocusNavActionsProp_FocusNavData_KeysEntry) -> buffer,
	decode: (input: buffer) -> FocusNavActionsProp_FocusNavData_KeysEntry,
	jsonEncode: (self: FocusNavActionsProp_FocusNavData_KeysEntry) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> FocusNavActionsProp_FocusNavData_KeysEntry,
	descriptor: proto.Descriptor,
}

type _FocusNavActionsProp_FocusNavData_KeysEntryFields = {
	key: string,
	value: string,
}

type _FocusNavActionsProp_FocusNavData_KeysEntryPartialFields = {
	key: string?,
	value: string?,
}

export type FocusNavActionsProp_FocusNavData_KeysEntry = typeof(setmetatable(
	{} :: _FocusNavActionsProp_FocusNavData_KeysEntryFields,
	{} :: _FocusNavActionsProp_FocusNavData_KeysEntryImpl
))
type _FocusNavActionsProp_FocusNavData_KeysEntryMessage = proto.Message<
	FocusNavActionsProp_FocusNavData_KeysEntry,
	_FocusNavActionsProp_FocusNavData_KeysEntryPartialFields
>

type _FocusNavActionsProp_FocusNavData_EventsEntryImpl = {
	__index: _FocusNavActionsProp_FocusNavData_EventsEntryImpl,
	new: (
		fields: _FocusNavActionsProp_FocusNavData_EventsEntryPartialFields?
	) -> FocusNavActionsProp_FocusNavData_EventsEntry,
	encode: (self: FocusNavActionsProp_FocusNavData_EventsEntry) -> buffer,
	decode: (input: buffer) -> FocusNavActionsProp_FocusNavData_EventsEntry,
	jsonEncode: (self: FocusNavActionsProp_FocusNavData_EventsEntry) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> FocusNavActionsProp_FocusNavData_EventsEntry,
	descriptor: proto.Descriptor,
}

type _FocusNavActionsProp_FocusNavData_EventsEntryFields = {
	key: string,
	value: _google_protobuf_struct.Struct?,
}

type _FocusNavActionsProp_FocusNavData_EventsEntryPartialFields = {
	key: string?,
	value: _google_protobuf_struct.Struct?,
}

export type FocusNavActionsProp_FocusNavData_EventsEntry = typeof(setmetatable(
	{} :: _FocusNavActionsProp_FocusNavData_EventsEntryFields,
	{} :: _FocusNavActionsProp_FocusNavData_EventsEntryImpl
))
type _FocusNavActionsProp_FocusNavData_EventsEntryMessage = proto.Message<
	FocusNavActionsProp_FocusNavData_EventsEntry,
	_FocusNavActionsProp_FocusNavData_EventsEntryPartialFields
>

type _ActionTypeMessage = proto.Enum<ActionType>
export type ActionType =
	"ACTION_TYPE_INVALID"
	| "ACTION_TYPE_DISMISS_DIALOG"
	| "ACTION_TYPE_LINK"
	| "ACTION_TYPE_OPEN_GAME_DETAILS"
	| "ACTION_TYPE_OPEN_JOIN_FRIENDS"
	| "ACTION_TYPE_OPEN_MARKETPLACE_TRY_ON"
	| "ACTION_TYPE_OPEN_SEE_ALL"
	| "ACTION_TYPE_OPEN_SPONSORED_TOOLTIP"
	| "ACTION_TYPE_PLAY_BUTTON_CLICK"
	| "ACTION_TYPE_UPDATE_USER_SETTINGS"
	| "ACTION_TYPE_OPEN_TOOLTIP"
	| "ACTION_TYPE_OPEN_BADGE_DETAILS"
	| number -- Unknown

do
	local _DismissDialogActionImpl = {}
	_DismissDialogActionImpl.__index = _DismissDialogActionImpl

	function _DismissDialogActionImpl.new(data: _DismissDialogActionPartialFields?): DismissDialogAction
		return setmetatable({
			action_type = if data == nil or data.action_type == nil
				then assert(messages.ActionType.fromNumber(0), "Enum has no 0 default")
				else data.action_type,
			action_params = if data == nil or data.action_params == nil then nil else data.action_params,
		}, _DismissDialogActionImpl :: _DismissDialogActionImpl)
	end

	function _DismissDialogActionImpl.encode(self: DismissDialogAction): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.ActionType.toNumber(self.action_type :: any))
		end

		if self.action_params ~= nil then
			local encoded = self.action_params:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _DismissDialogActionImpl.decode(input: buffer): DismissDialogAction
		local self = _DismissDialogActionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.action_type = (messages.ActionType.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.action_params = messages.DismissDialogAction_Params.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _DismissDialogActionImpl.jsonEncode(self: DismissDialogAction): any
		local output = {}

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output.actionType = if typeof(self.action_type) == "number"
				then self.action_type
				else messages.ActionType.toNumber(self.action_type :: any)
		end

		if self.action_params ~= nil then
			output.actionParams = self.action_params:jsonEncode()
		end

		return output
	end

	function _DismissDialogActionImpl.jsonDecode(input: { [string]: any }): DismissDialogAction
		local self = _DismissDialogActionImpl.new()

		if input.action_type ~= nil then
			self.action_type = if typeof(input.action_type) == "number"
				then (messages.ActionType.fromNumber(input.action_type) or input.action_type)
				else (messages.ActionType.fromName(input.action_type) or input.action_type)
		end

		if input.actionType ~= nil then
			self.action_type = if typeof(input.actionType) == "number"
				then (messages.ActionType.fromNumber(input.actionType) or input.actionType)
				else (messages.ActionType.fromName(input.actionType) or input.actionType)
		end

		if input.action_params ~= nil then
			self.action_params = messages.DismissDialogAction_Params.jsonDecode(input.action_params)
		end

		if input.actionParams ~= nil then
			self.action_params = messages.DismissDialogAction_Params.jsonDecode(input.actionParams)
		end

		return self
	end

	_DismissDialogActionImpl.descriptor = {
		name = "DismissDialogAction",
		fullName = "roblox.apppageplatform.shared.v1beta1.DismissDialogAction",
	}

	messages.DismissDialogAction = _DismissDialogActionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.DismissDialogAction)
end

do
	local _DismissDialogAction_ParamsImpl = {}
	_DismissDialogAction_ParamsImpl.__index = _DismissDialogAction_ParamsImpl

	function _DismissDialogAction_ParamsImpl.new(
		data: _DismissDialogAction_ParamsPartialFields?
	): DismissDialogAction_Params
		return setmetatable({
			dialog_type = if data == nil or data.dialog_type == nil then nil else data.dialog_type,
		}, _DismissDialogAction_ParamsImpl :: _DismissDialogAction_ParamsImpl)
	end

	function _DismissDialogAction_ParamsImpl.encode(self: DismissDialogAction_Params): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.dialog_type ~= nil then
			local encoded = self.dialog_type:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _DismissDialogAction_ParamsImpl.decode(input: buffer): DismissDialogAction_Params
		local self = _DismissDialogAction_ParamsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.dialog_type = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _DismissDialogAction_ParamsImpl.jsonEncode(self: DismissDialogAction_Params): any
		local output = {}

		if self.dialog_type ~= nil then
			output.dialogType = self.dialog_type:jsonEncode()
		end

		return output
	end

	function _DismissDialogAction_ParamsImpl.jsonDecode(input: { [string]: any }): DismissDialogAction_Params
		local self = _DismissDialogAction_ParamsImpl.new()

		if input.dialog_type ~= nil then
			self.dialog_type =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.dialog_type)
		end

		if input.dialogType ~= nil then
			self.dialog_type = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.dialogType)
		end

		return self
	end

	_DismissDialogAction_ParamsImpl.descriptor = {
		name = "DismissDialogAction_Params",
		fullName = "roblox.apppageplatform.shared.v1beta1.Params",
	}

	messages.DismissDialogAction_Params = _DismissDialogAction_ParamsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.DismissDialogAction_Params)
end

do
	local _LinkActionImpl = {}
	_LinkActionImpl.__index = _LinkActionImpl

	function _LinkActionImpl.new(data: _LinkActionPartialFields?): LinkAction
		return setmetatable({
			action_type = if data == nil or data.action_type == nil
				then assert(messages.ActionType.fromNumber(0), "Enum has no 0 default")
				else data.action_type,
			action_params = if data == nil or data.action_params == nil then nil else data.action_params,
		}, _LinkActionImpl :: _LinkActionImpl)
	end

	function _LinkActionImpl.encode(self: LinkAction): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.ActionType.toNumber(self.action_type :: any))
		end

		if self.action_params ~= nil then
			local encoded = self.action_params:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _LinkActionImpl.decode(input: buffer): LinkAction
		local self = _LinkActionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.action_type = (messages.ActionType.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.action_params = messages.LinkAction_Params.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _LinkActionImpl.jsonEncode(self: LinkAction): any
		local output = {}

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output.actionType = if typeof(self.action_type) == "number"
				then self.action_type
				else messages.ActionType.toNumber(self.action_type :: any)
		end

		if self.action_params ~= nil then
			output.actionParams = self.action_params:jsonEncode()
		end

		return output
	end

	function _LinkActionImpl.jsonDecode(input: { [string]: any }): LinkAction
		local self = _LinkActionImpl.new()

		if input.action_type ~= nil then
			self.action_type = if typeof(input.action_type) == "number"
				then (messages.ActionType.fromNumber(input.action_type) or input.action_type)
				else (messages.ActionType.fromName(input.action_type) or input.action_type)
		end

		if input.actionType ~= nil then
			self.action_type = if typeof(input.actionType) == "number"
				then (messages.ActionType.fromNumber(input.actionType) or input.actionType)
				else (messages.ActionType.fromName(input.actionType) or input.actionType)
		end

		if input.action_params ~= nil then
			self.action_params = messages.LinkAction_Params.jsonDecode(input.action_params)
		end

		if input.actionParams ~= nil then
			self.action_params = messages.LinkAction_Params.jsonDecode(input.actionParams)
		end

		return self
	end

	_LinkActionImpl.descriptor = {
		name = "LinkAction",
		fullName = "roblox.apppageplatform.shared.v1beta1.LinkAction",
	}

	messages.LinkAction = _LinkActionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.LinkAction)
end

do
	local _LinkAction_ParamsImpl = {}
	_LinkAction_ParamsImpl.__index = _LinkAction_ParamsImpl

	function _LinkAction_ParamsImpl.new(data: _LinkAction_ParamsPartialFields?): LinkAction_Params
		return setmetatable({
			url = if data == nil or data.url == nil then nil else data.url,
		}, _LinkAction_ParamsImpl :: _LinkAction_ParamsImpl)
	end

	function _LinkAction_ParamsImpl.encode(self: LinkAction_Params): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.url ~= nil then
			local encoded = self.url:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _LinkAction_ParamsImpl.decode(input: buffer): LinkAction_Params
		local self = _LinkAction_ParamsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.url = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _LinkAction_ParamsImpl.jsonEncode(self: LinkAction_Params): any
		local output = {}

		if self.url ~= nil then
			output.url = self.url:jsonEncode()
		end

		return output
	end

	function _LinkAction_ParamsImpl.jsonDecode(input: { [string]: any }): LinkAction_Params
		local self = _LinkAction_ParamsImpl.new()

		if input.url ~= nil then
			self.url = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.url)
		end

		return self
	end

	_LinkAction_ParamsImpl.descriptor = {
		name = "LinkAction_Params",
		fullName = "roblox.apppageplatform.shared.v1beta1.Params",
	}

	messages.LinkAction_Params = _LinkAction_ParamsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.LinkAction_Params)
end

do
	local _OpenGameDetailsActionImpl = {}
	_OpenGameDetailsActionImpl.__index = _OpenGameDetailsActionImpl

	function _OpenGameDetailsActionImpl.new(data: _OpenGameDetailsActionPartialFields?): OpenGameDetailsAction
		return setmetatable({
			action_type = if data == nil or data.action_type == nil
				then assert(messages.ActionType.fromNumber(0), "Enum has no 0 default")
				else data.action_type,
			action_params = if data == nil or data.action_params == nil then nil else data.action_params,
		}, _OpenGameDetailsActionImpl :: _OpenGameDetailsActionImpl)
	end

	function _OpenGameDetailsActionImpl.encode(self: OpenGameDetailsAction): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.ActionType.toNumber(self.action_type :: any))
		end

		if self.action_params ~= nil then
			local encoded = self.action_params:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenGameDetailsActionImpl.decode(input: buffer): OpenGameDetailsAction
		local self = _OpenGameDetailsActionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.action_type = (messages.ActionType.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.action_params = messages.OpenGameDetailsAction_Params.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenGameDetailsActionImpl.jsonEncode(self: OpenGameDetailsAction): any
		local output = {}

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output.actionType = if typeof(self.action_type) == "number"
				then self.action_type
				else messages.ActionType.toNumber(self.action_type :: any)
		end

		if self.action_params ~= nil then
			output.actionParams = self.action_params:jsonEncode()
		end

		return output
	end

	function _OpenGameDetailsActionImpl.jsonDecode(input: { [string]: any }): OpenGameDetailsAction
		local self = _OpenGameDetailsActionImpl.new()

		if input.action_type ~= nil then
			self.action_type = if typeof(input.action_type) == "number"
				then (messages.ActionType.fromNumber(input.action_type) or input.action_type)
				else (messages.ActionType.fromName(input.action_type) or input.action_type)
		end

		if input.actionType ~= nil then
			self.action_type = if typeof(input.actionType) == "number"
				then (messages.ActionType.fromNumber(input.actionType) or input.actionType)
				else (messages.ActionType.fromName(input.actionType) or input.actionType)
		end

		if input.action_params ~= nil then
			self.action_params = messages.OpenGameDetailsAction_Params.jsonDecode(input.action_params)
		end

		if input.actionParams ~= nil then
			self.action_params = messages.OpenGameDetailsAction_Params.jsonDecode(input.actionParams)
		end

		return self
	end

	_OpenGameDetailsActionImpl.descriptor = {
		name = "OpenGameDetailsAction",
		fullName = "roblox.apppageplatform.shared.v1beta1.OpenGameDetailsAction",
	}

	messages.OpenGameDetailsAction = _OpenGameDetailsActionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenGameDetailsAction)
end

do
	local _OpenGameDetailsAction_ParamsImpl = {}
	_OpenGameDetailsAction_ParamsImpl.__index = _OpenGameDetailsAction_ParamsImpl

	function _OpenGameDetailsAction_ParamsImpl.new(
		data: _OpenGameDetailsAction_ParamsPartialFields?
	): OpenGameDetailsAction_Params
		return setmetatable({
			place_id = if data == nil or data.place_id == nil then nil else data.place_id,
			universe_id = if data == nil or data.universe_id == nil then nil else data.universe_id,
		}, _OpenGameDetailsAction_ParamsImpl :: _OpenGameDetailsAction_ParamsImpl)
	end

	function _OpenGameDetailsAction_ParamsImpl.encode(self: OpenGameDetailsAction_Params): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.place_id ~= nil then
			local encoded = self.place_id:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.universe_id ~= nil then
			local encoded = self.universe_id:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenGameDetailsAction_ParamsImpl.decode(input: buffer): OpenGameDetailsAction_Params
		local self = _OpenGameDetailsAction_ParamsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.place_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.universe_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenGameDetailsAction_ParamsImpl.jsonEncode(self: OpenGameDetailsAction_Params): any
		local output = {}

		if self.place_id ~= nil then
			output.placeId = self.place_id:jsonEncode()
		end

		if self.universe_id ~= nil then
			output.universeId = self.universe_id:jsonEncode()
		end

		return output
	end

	function _OpenGameDetailsAction_ParamsImpl.jsonDecode(input: { [string]: any }): OpenGameDetailsAction_Params
		local self = _OpenGameDetailsAction_ParamsImpl.new()

		if input.place_id ~= nil then
			self.place_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.place_id)
		end

		if input.placeId ~= nil then
			self.place_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.placeId)
		end

		if input.universe_id ~= nil then
			self.universe_id =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.universe_id)
		end

		if input.universeId ~= nil then
			self.universe_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.universeId)
		end

		return self
	end

	_OpenGameDetailsAction_ParamsImpl.descriptor = {
		name = "OpenGameDetailsAction_Params",
		fullName = "roblox.apppageplatform.shared.v1beta1.Params",
	}

	messages.OpenGameDetailsAction_Params = _OpenGameDetailsAction_ParamsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenGameDetailsAction_Params)
end

do
	local _OpenJoinFriendsActionImpl = {}
	_OpenJoinFriendsActionImpl.__index = _OpenJoinFriendsActionImpl

	function _OpenJoinFriendsActionImpl.new(data: _OpenJoinFriendsActionPartialFields?): OpenJoinFriendsAction
		return setmetatable({
			action_type = if data == nil or data.action_type == nil
				then assert(messages.ActionType.fromNumber(0), "Enum has no 0 default")
				else data.action_type,
			action_params = if data == nil or data.action_params == nil then nil else data.action_params,
		}, _OpenJoinFriendsActionImpl :: _OpenJoinFriendsActionImpl)
	end

	function _OpenJoinFriendsActionImpl.encode(self: OpenJoinFriendsAction): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.ActionType.toNumber(self.action_type :: any))
		end

		if self.action_params ~= nil then
			local encoded = self.action_params:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenJoinFriendsActionImpl.decode(input: buffer): OpenJoinFriendsAction
		local self = _OpenJoinFriendsActionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.action_type = (messages.ActionType.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.action_params = messages.OpenJoinFriendsAction_Params.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenJoinFriendsActionImpl.jsonEncode(self: OpenJoinFriendsAction): any
		local output = {}

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output.actionType = if typeof(self.action_type) == "number"
				then self.action_type
				else messages.ActionType.toNumber(self.action_type :: any)
		end

		if self.action_params ~= nil then
			output.actionParams = self.action_params:jsonEncode()
		end

		return output
	end

	function _OpenJoinFriendsActionImpl.jsonDecode(input: { [string]: any }): OpenJoinFriendsAction
		local self = _OpenJoinFriendsActionImpl.new()

		if input.action_type ~= nil then
			self.action_type = if typeof(input.action_type) == "number"
				then (messages.ActionType.fromNumber(input.action_type) or input.action_type)
				else (messages.ActionType.fromName(input.action_type) or input.action_type)
		end

		if input.actionType ~= nil then
			self.action_type = if typeof(input.actionType) == "number"
				then (messages.ActionType.fromNumber(input.actionType) or input.actionType)
				else (messages.ActionType.fromName(input.actionType) or input.actionType)
		end

		if input.action_params ~= nil then
			self.action_params = messages.OpenJoinFriendsAction_Params.jsonDecode(input.action_params)
		end

		if input.actionParams ~= nil then
			self.action_params = messages.OpenJoinFriendsAction_Params.jsonDecode(input.actionParams)
		end

		return self
	end

	_OpenJoinFriendsActionImpl.descriptor = {
		name = "OpenJoinFriendsAction",
		fullName = "roblox.apppageplatform.shared.v1beta1.OpenJoinFriendsAction",
	}

	messages.OpenJoinFriendsAction = _OpenJoinFriendsActionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenJoinFriendsAction)
end

do
	local _OpenJoinFriendsAction_ParamsImpl = {}
	_OpenJoinFriendsAction_ParamsImpl.__index = _OpenJoinFriendsAction_ParamsImpl

	function _OpenJoinFriendsAction_ParamsImpl.new(
		data: _OpenJoinFriendsAction_ParamsPartialFields?
	): OpenJoinFriendsAction_Params
		return setmetatable({
			place_id = if data == nil or data.place_id == nil then nil else data.place_id,
			universe_id = if data == nil or data.universe_id == nil then nil else data.universe_id,
		}, _OpenJoinFriendsAction_ParamsImpl :: _OpenJoinFriendsAction_ParamsImpl)
	end

	function _OpenJoinFriendsAction_ParamsImpl.encode(self: OpenJoinFriendsAction_Params): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.place_id ~= nil then
			local encoded = self.place_id:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.universe_id ~= nil then
			local encoded = self.universe_id:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenJoinFriendsAction_ParamsImpl.decode(input: buffer): OpenJoinFriendsAction_Params
		local self = _OpenJoinFriendsAction_ParamsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.place_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.universe_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenJoinFriendsAction_ParamsImpl.jsonEncode(self: OpenJoinFriendsAction_Params): any
		local output = {}

		if self.place_id ~= nil then
			output.placeId = self.place_id:jsonEncode()
		end

		if self.universe_id ~= nil then
			output.universeId = self.universe_id:jsonEncode()
		end

		return output
	end

	function _OpenJoinFriendsAction_ParamsImpl.jsonDecode(input: { [string]: any }): OpenJoinFriendsAction_Params
		local self = _OpenJoinFriendsAction_ParamsImpl.new()

		if input.place_id ~= nil then
			self.place_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.place_id)
		end

		if input.placeId ~= nil then
			self.place_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.placeId)
		end

		if input.universe_id ~= nil then
			self.universe_id =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.universe_id)
		end

		if input.universeId ~= nil then
			self.universe_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.universeId)
		end

		return self
	end

	_OpenJoinFriendsAction_ParamsImpl.descriptor = {
		name = "OpenJoinFriendsAction_Params",
		fullName = "roblox.apppageplatform.shared.v1beta1.Params",
	}

	messages.OpenJoinFriendsAction_Params = _OpenJoinFriendsAction_ParamsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenJoinFriendsAction_Params)
end

do
	local _OpenMarketplaceTryOnActionImpl = {}
	_OpenMarketplaceTryOnActionImpl.__index = _OpenMarketplaceTryOnActionImpl

	function _OpenMarketplaceTryOnActionImpl.new(
		data: _OpenMarketplaceTryOnActionPartialFields?
	): OpenMarketplaceTryOnAction
		return setmetatable({
			action_type = if data == nil or data.action_type == nil
				then assert(messages.ActionType.fromNumber(0), "Enum has no 0 default")
				else data.action_type,
			action_params = if data == nil or data.action_params == nil then nil else data.action_params,
		}, _OpenMarketplaceTryOnActionImpl :: _OpenMarketplaceTryOnActionImpl)
	end

	function _OpenMarketplaceTryOnActionImpl.encode(self: OpenMarketplaceTryOnAction): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.ActionType.toNumber(self.action_type :: any))
		end

		if self.action_params ~= nil then
			local encoded = self.action_params:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenMarketplaceTryOnActionImpl.decode(input: buffer): OpenMarketplaceTryOnAction
		local self = _OpenMarketplaceTryOnActionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.action_type = (messages.ActionType.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.action_params = messages.OpenMarketplaceTryOnAction_Params.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenMarketplaceTryOnActionImpl.jsonEncode(self: OpenMarketplaceTryOnAction): any
		local output = {}

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output.actionType = if typeof(self.action_type) == "number"
				then self.action_type
				else messages.ActionType.toNumber(self.action_type :: any)
		end

		if self.action_params ~= nil then
			output.actionParams = self.action_params:jsonEncode()
		end

		return output
	end

	function _OpenMarketplaceTryOnActionImpl.jsonDecode(input: { [string]: any }): OpenMarketplaceTryOnAction
		local self = _OpenMarketplaceTryOnActionImpl.new()

		if input.action_type ~= nil then
			self.action_type = if typeof(input.action_type) == "number"
				then (messages.ActionType.fromNumber(input.action_type) or input.action_type)
				else (messages.ActionType.fromName(input.action_type) or input.action_type)
		end

		if input.actionType ~= nil then
			self.action_type = if typeof(input.actionType) == "number"
				then (messages.ActionType.fromNumber(input.actionType) or input.actionType)
				else (messages.ActionType.fromName(input.actionType) or input.actionType)
		end

		if input.action_params ~= nil then
			self.action_params = messages.OpenMarketplaceTryOnAction_Params.jsonDecode(input.action_params)
		end

		if input.actionParams ~= nil then
			self.action_params = messages.OpenMarketplaceTryOnAction_Params.jsonDecode(input.actionParams)
		end

		return self
	end

	_OpenMarketplaceTryOnActionImpl.descriptor = {
		name = "OpenMarketplaceTryOnAction",
		fullName = "roblox.apppageplatform.shared.v1beta1.OpenMarketplaceTryOnAction",
	}

	messages.OpenMarketplaceTryOnAction = _OpenMarketplaceTryOnActionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenMarketplaceTryOnAction)
end

do
	local _OpenMarketplaceTryOnAction_ParamsImpl = {}
	_OpenMarketplaceTryOnAction_ParamsImpl.__index = _OpenMarketplaceTryOnAction_ParamsImpl

	function _OpenMarketplaceTryOnAction_ParamsImpl.new(
		data: _OpenMarketplaceTryOnAction_ParamsPartialFields?
	): OpenMarketplaceTryOnAction_Params
		return setmetatable({
			item_id = if data == nil or data.item_id == nil then nil else data.item_id,
			item_type = if data == nil or data.item_type == nil then nil else data.item_type,
			item_sub_type_name = if data == nil or data.item_sub_type_name == nil then nil else data.item_sub_type_name,
		}, _OpenMarketplaceTryOnAction_ParamsImpl :: _OpenMarketplaceTryOnAction_ParamsImpl)
	end

	function _OpenMarketplaceTryOnAction_ParamsImpl.encode(self: OpenMarketplaceTryOnAction_Params): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.item_id ~= nil then
			local encoded = self.item_id:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.item_type ~= nil then
			local encoded = self.item_type:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.item_sub_type_name ~= nil then
			local encoded = self.item_sub_type_name:encode()
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenMarketplaceTryOnAction_ParamsImpl.decode(input: buffer): OpenMarketplaceTryOnAction_Params
		local self = _OpenMarketplaceTryOnAction_ParamsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.item_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.item_type = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.item_sub_type_name = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenMarketplaceTryOnAction_ParamsImpl.jsonEncode(self: OpenMarketplaceTryOnAction_Params): any
		local output = {}

		if self.item_id ~= nil then
			output.itemId = self.item_id:jsonEncode()
		end

		if self.item_type ~= nil then
			output.itemType = self.item_type:jsonEncode()
		end

		if self.item_sub_type_name ~= nil then
			output.itemSubTypeName = self.item_sub_type_name:jsonEncode()
		end

		return output
	end

	function _OpenMarketplaceTryOnAction_ParamsImpl.jsonDecode(
		input: { [string]: any }
	): OpenMarketplaceTryOnAction_Params
		local self = _OpenMarketplaceTryOnAction_ParamsImpl.new()

		if input.item_id ~= nil then
			self.item_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.item_id)
		end

		if input.itemId ~= nil then
			self.item_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.itemId)
		end

		if input.item_type ~= nil then
			self.item_type = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.item_type)
		end

		if input.itemType ~= nil then
			self.item_type = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.itemType)
		end

		if input.item_sub_type_name ~= nil then
			self.item_sub_type_name =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.item_sub_type_name)
		end

		if input.itemSubTypeName ~= nil then
			self.item_sub_type_name =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.itemSubTypeName)
		end

		return self
	end

	_OpenMarketplaceTryOnAction_ParamsImpl.descriptor = {
		name = "OpenMarketplaceTryOnAction_Params",
		fullName = "roblox.apppageplatform.shared.v1beta1.Params",
	}

	messages.OpenMarketplaceTryOnAction_Params = _OpenMarketplaceTryOnAction_ParamsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenMarketplaceTryOnAction_Params)
end

do
	local _OpenSeeAllActionImpl = {}
	_OpenSeeAllActionImpl.__index = _OpenSeeAllActionImpl

	function _OpenSeeAllActionImpl.new(data: _OpenSeeAllActionPartialFields?): OpenSeeAllAction
		return setmetatable({
			action_type = if data == nil or data.action_type == nil
				then assert(messages.ActionType.fromNumber(0), "Enum has no 0 default")
				else data.action_type,
			action_params = if data == nil or data.action_params == nil then nil else data.action_params,
		}, _OpenSeeAllActionImpl :: _OpenSeeAllActionImpl)
	end

	function _OpenSeeAllActionImpl.encode(self: OpenSeeAllAction): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.ActionType.toNumber(self.action_type :: any))
		end

		if self.action_params ~= nil then
			local encoded = self.action_params:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenSeeAllActionImpl.decode(input: buffer): OpenSeeAllAction
		local self = _OpenSeeAllActionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.action_type = (messages.ActionType.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.action_params = messages.OpenSeeAllAction_Params.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenSeeAllActionImpl.jsonEncode(self: OpenSeeAllAction): any
		local output = {}

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output.actionType = if typeof(self.action_type) == "number"
				then self.action_type
				else messages.ActionType.toNumber(self.action_type :: any)
		end

		if self.action_params ~= nil then
			output.actionParams = self.action_params:jsonEncode()
		end

		return output
	end

	function _OpenSeeAllActionImpl.jsonDecode(input: { [string]: any }): OpenSeeAllAction
		local self = _OpenSeeAllActionImpl.new()

		if input.action_type ~= nil then
			self.action_type = if typeof(input.action_type) == "number"
				then (messages.ActionType.fromNumber(input.action_type) or input.action_type)
				else (messages.ActionType.fromName(input.action_type) or input.action_type)
		end

		if input.actionType ~= nil then
			self.action_type = if typeof(input.actionType) == "number"
				then (messages.ActionType.fromNumber(input.actionType) or input.actionType)
				else (messages.ActionType.fromName(input.actionType) or input.actionType)
		end

		if input.action_params ~= nil then
			self.action_params = messages.OpenSeeAllAction_Params.jsonDecode(input.action_params)
		end

		if input.actionParams ~= nil then
			self.action_params = messages.OpenSeeAllAction_Params.jsonDecode(input.actionParams)
		end

		return self
	end

	_OpenSeeAllActionImpl.descriptor = {
		name = "OpenSeeAllAction",
		fullName = "roblox.apppageplatform.shared.v1beta1.OpenSeeAllAction",
	}

	messages.OpenSeeAllAction = _OpenSeeAllActionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenSeeAllAction)
end

do
	local _OpenSeeAllAction_ParamsImpl = {}
	_OpenSeeAllAction_ParamsImpl.__index = _OpenSeeAllAction_ParamsImpl

	function _OpenSeeAllAction_ParamsImpl.new(data: _OpenSeeAllAction_ParamsPartialFields?): OpenSeeAllAction_Params
		return setmetatable({
			collection_id = if data == nil or data.collection_id == nil then nil else data.collection_id,
			game_set_target_id = if data == nil or data.game_set_target_id == nil then nil else data.game_set_target_id,
			collection_position = if data == nil or data.collection_position == nil
				then nil
				else data.collection_position,
		}, _OpenSeeAllAction_ParamsImpl :: _OpenSeeAllAction_ParamsImpl)
	end

	function _OpenSeeAllAction_ParamsImpl.encode(self: OpenSeeAllAction_Params): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.collection_id ~= nil then
			local encoded = self.collection_id:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.game_set_target_id ~= nil then
			local encoded = self.game_set_target_id:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.collection_position ~= nil then
			local encoded = self.collection_position:encode()
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenSeeAllAction_ParamsImpl.decode(input: buffer): OpenSeeAllAction_Params
		local self = _OpenSeeAllAction_ParamsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.collection_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.game_set_target_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.collection_position =
						_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenSeeAllAction_ParamsImpl.jsonEncode(self: OpenSeeAllAction_Params): any
		local output = {}

		if self.collection_id ~= nil then
			output.collectionId = self.collection_id:jsonEncode()
		end

		if self.game_set_target_id ~= nil then
			output.gameSetTargetId = self.game_set_target_id:jsonEncode()
		end

		if self.collection_position ~= nil then
			output.collectionPosition = self.collection_position:jsonEncode()
		end

		return output
	end

	function _OpenSeeAllAction_ParamsImpl.jsonDecode(input: { [string]: any }): OpenSeeAllAction_Params
		local self = _OpenSeeAllAction_ParamsImpl.new()

		if input.collection_id ~= nil then
			self.collection_id =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.collection_id)
		end

		if input.collectionId ~= nil then
			self.collection_id =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.collectionId)
		end

		if input.game_set_target_id ~= nil then
			self.game_set_target_id =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.game_set_target_id)
		end

		if input.gameSetTargetId ~= nil then
			self.game_set_target_id =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.gameSetTargetId)
		end

		if input.collection_position ~= nil then
			self.collection_position =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.collection_position)
		end

		if input.collectionPosition ~= nil then
			self.collection_position =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.collectionPosition)
		end

		return self
	end

	_OpenSeeAllAction_ParamsImpl.descriptor = {
		name = "OpenSeeAllAction_Params",
		fullName = "roblox.apppageplatform.shared.v1beta1.Params",
	}

	messages.OpenSeeAllAction_Params = _OpenSeeAllAction_ParamsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenSeeAllAction_Params)
end

do
	local _OpenSponsoredTooltipActionImpl = {}
	_OpenSponsoredTooltipActionImpl.__index = _OpenSponsoredTooltipActionImpl

	function _OpenSponsoredTooltipActionImpl.new(
		data: _OpenSponsoredTooltipActionPartialFields?
	): OpenSponsoredTooltipAction
		return setmetatable({
			action_type = if data == nil or data.action_type == nil
				then assert(messages.ActionType.fromNumber(0), "Enum has no 0 default")
				else data.action_type,
			action_params = if data == nil or data.action_params == nil then nil else data.action_params,
		}, _OpenSponsoredTooltipActionImpl :: _OpenSponsoredTooltipActionImpl)
	end

	function _OpenSponsoredTooltipActionImpl.encode(self: OpenSponsoredTooltipAction): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.ActionType.toNumber(self.action_type :: any))
		end

		if self.action_params ~= nil then
			local encoded = self.action_params:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenSponsoredTooltipActionImpl.decode(input: buffer): OpenSponsoredTooltipAction
		local self = _OpenSponsoredTooltipActionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.action_type = (messages.ActionType.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.action_params = messages.OpenSponsoredTooltipAction_Params.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenSponsoredTooltipActionImpl.jsonEncode(self: OpenSponsoredTooltipAction): any
		local output = {}

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output.actionType = if typeof(self.action_type) == "number"
				then self.action_type
				else messages.ActionType.toNumber(self.action_type :: any)
		end

		if self.action_params ~= nil then
			output.actionParams = self.action_params:jsonEncode()
		end

		return output
	end

	function _OpenSponsoredTooltipActionImpl.jsonDecode(input: { [string]: any }): OpenSponsoredTooltipAction
		local self = _OpenSponsoredTooltipActionImpl.new()

		if input.action_type ~= nil then
			self.action_type = if typeof(input.action_type) == "number"
				then (messages.ActionType.fromNumber(input.action_type) or input.action_type)
				else (messages.ActionType.fromName(input.action_type) or input.action_type)
		end

		if input.actionType ~= nil then
			self.action_type = if typeof(input.actionType) == "number"
				then (messages.ActionType.fromNumber(input.actionType) or input.actionType)
				else (messages.ActionType.fromName(input.actionType) or input.actionType)
		end

		if input.action_params ~= nil then
			self.action_params = messages.OpenSponsoredTooltipAction_Params.jsonDecode(input.action_params)
		end

		if input.actionParams ~= nil then
			self.action_params = messages.OpenSponsoredTooltipAction_Params.jsonDecode(input.actionParams)
		end

		return self
	end

	_OpenSponsoredTooltipActionImpl.descriptor = {
		name = "OpenSponsoredTooltipAction",
		fullName = "roblox.apppageplatform.shared.v1beta1.OpenSponsoredTooltipAction",
	}

	messages.OpenSponsoredTooltipAction = _OpenSponsoredTooltipActionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenSponsoredTooltipAction)
end

do
	local _OpenSponsoredTooltipAction_ParamsImpl = {}
	_OpenSponsoredTooltipAction_ParamsImpl.__index = _OpenSponsoredTooltipAction_ParamsImpl

	function _OpenSponsoredTooltipAction_ParamsImpl.new(
		data: _OpenSponsoredTooltipAction_ParamsPartialFields?
	): OpenSponsoredTooltipAction_Params
		return setmetatable({}, _OpenSponsoredTooltipAction_ParamsImpl :: _OpenSponsoredTooltipAction_ParamsImpl)
	end

	function _OpenSponsoredTooltipAction_ParamsImpl.encode(self: OpenSponsoredTooltipAction_Params): buffer
		local output = buffer.create(0)
		local cursor = 0

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenSponsoredTooltipAction_ParamsImpl.decode(input: buffer): OpenSponsoredTooltipAction_Params
		local self = _OpenSponsoredTooltipAction_ParamsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenSponsoredTooltipAction_ParamsImpl.jsonEncode(self: OpenSponsoredTooltipAction_Params): any
		local output = {}

		return output
	end

	function _OpenSponsoredTooltipAction_ParamsImpl.jsonDecode(
		input: { [string]: any }
	): OpenSponsoredTooltipAction_Params
		local self = _OpenSponsoredTooltipAction_ParamsImpl.new()

		return self
	end

	_OpenSponsoredTooltipAction_ParamsImpl.descriptor = {
		name = "OpenSponsoredTooltipAction_Params",
		fullName = "roblox.apppageplatform.shared.v1beta1.Params",
	}

	messages.OpenSponsoredTooltipAction_Params = _OpenSponsoredTooltipAction_ParamsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenSponsoredTooltipAction_Params)
end

do
	local _PlayButtonClickActionImpl = {}
	_PlayButtonClickActionImpl.__index = _PlayButtonClickActionImpl

	function _PlayButtonClickActionImpl.new(data: _PlayButtonClickActionPartialFields?): PlayButtonClickAction
		return setmetatable({
			action_type = if data == nil or data.action_type == nil
				then assert(messages.ActionType.fromNumber(0), "Enum has no 0 default")
				else data.action_type,
			action_params = if data == nil or data.action_params == nil then nil else data.action_params,
		}, _PlayButtonClickActionImpl :: _PlayButtonClickActionImpl)
	end

	function _PlayButtonClickActionImpl.encode(self: PlayButtonClickAction): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.ActionType.toNumber(self.action_type :: any))
		end

		if self.action_params ~= nil then
			local encoded = self.action_params:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _PlayButtonClickActionImpl.decode(input: buffer): PlayButtonClickAction
		local self = _PlayButtonClickActionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.action_type = (messages.ActionType.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.action_params = messages.PlayButtonClickAction_Params.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _PlayButtonClickActionImpl.jsonEncode(self: PlayButtonClickAction): any
		local output = {}

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output.actionType = if typeof(self.action_type) == "number"
				then self.action_type
				else messages.ActionType.toNumber(self.action_type :: any)
		end

		if self.action_params ~= nil then
			output.actionParams = self.action_params:jsonEncode()
		end

		return output
	end

	function _PlayButtonClickActionImpl.jsonDecode(input: { [string]: any }): PlayButtonClickAction
		local self = _PlayButtonClickActionImpl.new()

		if input.action_type ~= nil then
			self.action_type = if typeof(input.action_type) == "number"
				then (messages.ActionType.fromNumber(input.action_type) or input.action_type)
				else (messages.ActionType.fromName(input.action_type) or input.action_type)
		end

		if input.actionType ~= nil then
			self.action_type = if typeof(input.actionType) == "number"
				then (messages.ActionType.fromNumber(input.actionType) or input.actionType)
				else (messages.ActionType.fromName(input.actionType) or input.actionType)
		end

		if input.action_params ~= nil then
			self.action_params = messages.PlayButtonClickAction_Params.jsonDecode(input.action_params)
		end

		if input.actionParams ~= nil then
			self.action_params = messages.PlayButtonClickAction_Params.jsonDecode(input.actionParams)
		end

		return self
	end

	_PlayButtonClickActionImpl.descriptor = {
		name = "PlayButtonClickAction",
		fullName = "roblox.apppageplatform.shared.v1beta1.PlayButtonClickAction",
	}

	messages.PlayButtonClickAction = _PlayButtonClickActionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.PlayButtonClickAction)
end

do
	local _PlayButtonClickAction_ParamsImpl = {}
	_PlayButtonClickAction_ParamsImpl.__index = _PlayButtonClickAction_ParamsImpl

	function _PlayButtonClickAction_ParamsImpl.new(
		data: _PlayButtonClickAction_ParamsPartialFields?
	): PlayButtonClickAction_Params
		return setmetatable({}, _PlayButtonClickAction_ParamsImpl :: _PlayButtonClickAction_ParamsImpl)
	end

	function _PlayButtonClickAction_ParamsImpl.encode(self: PlayButtonClickAction_Params): buffer
		local output = buffer.create(0)
		local cursor = 0

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _PlayButtonClickAction_ParamsImpl.decode(input: buffer): PlayButtonClickAction_Params
		local self = _PlayButtonClickAction_ParamsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _PlayButtonClickAction_ParamsImpl.jsonEncode(self: PlayButtonClickAction_Params): any
		local output = {}

		return output
	end

	function _PlayButtonClickAction_ParamsImpl.jsonDecode(input: { [string]: any }): PlayButtonClickAction_Params
		local self = _PlayButtonClickAction_ParamsImpl.new()

		return self
	end

	_PlayButtonClickAction_ParamsImpl.descriptor = {
		name = "PlayButtonClickAction_Params",
		fullName = "roblox.apppageplatform.shared.v1beta1.Params",
	}

	messages.PlayButtonClickAction_Params = _PlayButtonClickAction_ParamsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.PlayButtonClickAction_Params)
end

do
	local _UpdateUserSettingsActionImpl = {}
	_UpdateUserSettingsActionImpl.__index = _UpdateUserSettingsActionImpl

	function _UpdateUserSettingsActionImpl.new(data: _UpdateUserSettingsActionPartialFields?): UpdateUserSettingsAction
		return setmetatable({
			action_type = if data == nil or data.action_type == nil
				then assert(messages.ActionType.fromNumber(0), "Enum has no 0 default")
				else data.action_type,
			action_params = if data == nil or data.action_params == nil then nil else data.action_params,
		}, _UpdateUserSettingsActionImpl :: _UpdateUserSettingsActionImpl)
	end

	function _UpdateUserSettingsActionImpl.encode(self: UpdateUserSettingsAction): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.ActionType.toNumber(self.action_type :: any))
		end

		if self.action_params ~= nil then
			local encoded = self.action_params:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _UpdateUserSettingsActionImpl.decode(input: buffer): UpdateUserSettingsAction
		local self = _UpdateUserSettingsActionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.action_type = (messages.ActionType.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.action_params = messages.UpdateUserSettingsAction_Params.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _UpdateUserSettingsActionImpl.jsonEncode(self: UpdateUserSettingsAction): any
		local output = {}

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output.actionType = if typeof(self.action_type) == "number"
				then self.action_type
				else messages.ActionType.toNumber(self.action_type :: any)
		end

		if self.action_params ~= nil then
			output.actionParams = self.action_params:jsonEncode()
		end

		return output
	end

	function _UpdateUserSettingsActionImpl.jsonDecode(input: { [string]: any }): UpdateUserSettingsAction
		local self = _UpdateUserSettingsActionImpl.new()

		if input.action_type ~= nil then
			self.action_type = if typeof(input.action_type) == "number"
				then (messages.ActionType.fromNumber(input.action_type) or input.action_type)
				else (messages.ActionType.fromName(input.action_type) or input.action_type)
		end

		if input.actionType ~= nil then
			self.action_type = if typeof(input.actionType) == "number"
				then (messages.ActionType.fromNumber(input.actionType) or input.actionType)
				else (messages.ActionType.fromName(input.actionType) or input.actionType)
		end

		if input.action_params ~= nil then
			self.action_params = messages.UpdateUserSettingsAction_Params.jsonDecode(input.action_params)
		end

		if input.actionParams ~= nil then
			self.action_params = messages.UpdateUserSettingsAction_Params.jsonDecode(input.actionParams)
		end

		return self
	end

	_UpdateUserSettingsActionImpl.descriptor = {
		name = "UpdateUserSettingsAction",
		fullName = "roblox.apppageplatform.shared.v1beta1.UpdateUserSettingsAction",
	}

	messages.UpdateUserSettingsAction = _UpdateUserSettingsActionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.UpdateUserSettingsAction)
end

do
	local _UpdateUserSettingsAction_ParamsImpl = {}
	_UpdateUserSettingsAction_ParamsImpl.__index = _UpdateUserSettingsAction_ParamsImpl

	function _UpdateUserSettingsAction_ParamsImpl.new(
		data: _UpdateUserSettingsAction_ParamsPartialFields?
	): UpdateUserSettingsAction_Params
		return setmetatable({
			settings = if data == nil or data.settings == nil then nil else data.settings,
			audit_data = if data == nil or data.audit_data == nil then nil else data.audit_data,
		}, _UpdateUserSettingsAction_ParamsImpl :: _UpdateUserSettingsAction_ParamsImpl)
	end

	function _UpdateUserSettingsAction_ParamsImpl.encode(self: UpdateUserSettingsAction_Params): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.settings ~= nil then
			local encoded = self.settings:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.audit_data ~= nil then
			local encoded = self.audit_data:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _UpdateUserSettingsAction_ParamsImpl.decode(input: buffer): UpdateUserSettingsAction_Params
		local self = _UpdateUserSettingsAction_ParamsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.settings = _roblox_apppageplatform_shared_v1beta1_prop_types.StructProp.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.audit_data = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _UpdateUserSettingsAction_ParamsImpl.jsonEncode(self: UpdateUserSettingsAction_Params): any
		local output = {}

		if self.settings ~= nil then
			output.settings = self.settings:jsonEncode()
		end

		if self.audit_data ~= nil then
			output.auditData = self.audit_data:jsonEncode()
		end

		return output
	end

	function _UpdateUserSettingsAction_ParamsImpl.jsonDecode(input: { [string]: any }): UpdateUserSettingsAction_Params
		local self = _UpdateUserSettingsAction_ParamsImpl.new()

		if input.settings ~= nil then
			self.settings = _roblox_apppageplatform_shared_v1beta1_prop_types.StructProp.jsonDecode(input.settings)
		end

		if input.audit_data ~= nil then
			self.audit_data = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.audit_data)
		end

		if input.auditData ~= nil then
			self.audit_data = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.auditData)
		end

		return self
	end

	_UpdateUserSettingsAction_ParamsImpl.descriptor = {
		name = "UpdateUserSettingsAction_Params",
		fullName = "roblox.apppageplatform.shared.v1beta1.Params",
	}

	messages.UpdateUserSettingsAction_Params = _UpdateUserSettingsAction_ParamsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.UpdateUserSettingsAction_Params)
end

do
	local _OpenTooltipActionImpl = {}
	_OpenTooltipActionImpl.__index = _OpenTooltipActionImpl

	function _OpenTooltipActionImpl.new(data: _OpenTooltipActionPartialFields?): OpenTooltipAction
		return setmetatable({
			action_type = if data == nil or data.action_type == nil
				then assert(messages.ActionType.fromNumber(0), "Enum has no 0 default")
				else data.action_type,
			action_params = if data == nil or data.action_params == nil then nil else data.action_params,
		}, _OpenTooltipActionImpl :: _OpenTooltipActionImpl)
	end

	function _OpenTooltipActionImpl.encode(self: OpenTooltipAction): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.ActionType.toNumber(self.action_type :: any))
		end

		if self.action_params ~= nil then
			local encoded = self.action_params:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenTooltipActionImpl.decode(input: buffer): OpenTooltipAction
		local self = _OpenTooltipActionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.action_type = (messages.ActionType.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.action_params = messages.OpenTooltipAction_Params.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenTooltipActionImpl.jsonEncode(self: OpenTooltipAction): any
		local output = {}

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output.actionType = if typeof(self.action_type) == "number"
				then self.action_type
				else messages.ActionType.toNumber(self.action_type :: any)
		end

		if self.action_params ~= nil then
			output.actionParams = self.action_params:jsonEncode()
		end

		return output
	end

	function _OpenTooltipActionImpl.jsonDecode(input: { [string]: any }): OpenTooltipAction
		local self = _OpenTooltipActionImpl.new()

		if input.action_type ~= nil then
			self.action_type = if typeof(input.action_type) == "number"
				then (messages.ActionType.fromNumber(input.action_type) or input.action_type)
				else (messages.ActionType.fromName(input.action_type) or input.action_type)
		end

		if input.actionType ~= nil then
			self.action_type = if typeof(input.actionType) == "number"
				then (messages.ActionType.fromNumber(input.actionType) or input.actionType)
				else (messages.ActionType.fromName(input.actionType) or input.actionType)
		end

		if input.action_params ~= nil then
			self.action_params = messages.OpenTooltipAction_Params.jsonDecode(input.action_params)
		end

		if input.actionParams ~= nil then
			self.action_params = messages.OpenTooltipAction_Params.jsonDecode(input.actionParams)
		end

		return self
	end

	_OpenTooltipActionImpl.descriptor = {
		name = "OpenTooltipAction",
		fullName = "roblox.apppageplatform.shared.v1beta1.OpenTooltipAction",
	}

	messages.OpenTooltipAction = _OpenTooltipActionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenTooltipAction)
end

do
	local _OpenTooltipAction_ParamsImpl = {}
	_OpenTooltipAction_ParamsImpl.__index = _OpenTooltipAction_ParamsImpl

	function _OpenTooltipAction_ParamsImpl.new(data: _OpenTooltipAction_ParamsPartialFields?): OpenTooltipAction_Params
		return setmetatable({
			tooltip_title = if data == nil or data.tooltip_title == nil then nil else data.tooltip_title,
			tooltip_info_text = if data == nil or data.tooltip_info_text == nil then nil else data.tooltip_info_text,
		}, _OpenTooltipAction_ParamsImpl :: _OpenTooltipAction_ParamsImpl)
	end

	function _OpenTooltipAction_ParamsImpl.encode(self: OpenTooltipAction_Params): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.tooltip_title ~= nil then
			local encoded = self.tooltip_title:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.tooltip_info_text ~= nil then
			local encoded = self.tooltip_info_text:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenTooltipAction_ParamsImpl.decode(input: buffer): OpenTooltipAction_Params
		local self = _OpenTooltipAction_ParamsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.tooltip_title = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.tooltip_info_text = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenTooltipAction_ParamsImpl.jsonEncode(self: OpenTooltipAction_Params): any
		local output = {}

		if self.tooltip_title ~= nil then
			output.tooltipTitle = self.tooltip_title:jsonEncode()
		end

		if self.tooltip_info_text ~= nil then
			output.tooltipInfoText = self.tooltip_info_text:jsonEncode()
		end

		return output
	end

	function _OpenTooltipAction_ParamsImpl.jsonDecode(input: { [string]: any }): OpenTooltipAction_Params
		local self = _OpenTooltipAction_ParamsImpl.new()

		if input.tooltip_title ~= nil then
			self.tooltip_title =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.tooltip_title)
		end

		if input.tooltipTitle ~= nil then
			self.tooltip_title =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.tooltipTitle)
		end

		if input.tooltip_info_text ~= nil then
			self.tooltip_info_text =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.tooltip_info_text)
		end

		if input.tooltipInfoText ~= nil then
			self.tooltip_info_text =
				_roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.tooltipInfoText)
		end

		return self
	end

	_OpenTooltipAction_ParamsImpl.descriptor = {
		name = "OpenTooltipAction_Params",
		fullName = "roblox.apppageplatform.shared.v1beta1.Params",
	}

	messages.OpenTooltipAction_Params = _OpenTooltipAction_ParamsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenTooltipAction_Params)
end

do
	local _OpenBadgeDetailsActionImpl = {}
	_OpenBadgeDetailsActionImpl.__index = _OpenBadgeDetailsActionImpl

	function _OpenBadgeDetailsActionImpl.new(data: _OpenBadgeDetailsActionPartialFields?): OpenBadgeDetailsAction
		return setmetatable({
			action_type = if data == nil or data.action_type == nil
				then assert(messages.ActionType.fromNumber(0), "Enum has no 0 default")
				else data.action_type,
			action_params = if data == nil or data.action_params == nil then nil else data.action_params,
		}, _OpenBadgeDetailsActionImpl :: _OpenBadgeDetailsActionImpl)
	end

	function _OpenBadgeDetailsActionImpl.encode(self: OpenBadgeDetailsAction): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.ActionType.toNumber(self.action_type :: any))
		end

		if self.action_params ~= nil then
			local encoded = self.action_params:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenBadgeDetailsActionImpl.decode(input: buffer): OpenBadgeDetailsAction
		local self = _OpenBadgeDetailsActionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.action_type = (messages.ActionType.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.action_params = messages.OpenBadgeDetailsAction_Params.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenBadgeDetailsActionImpl.jsonEncode(self: OpenBadgeDetailsAction): any
		local output = {}

		if
			self.action_type ~= nil
			and (
				self.action_type ~= nil and self.action_type ~= 0
				or self.action_type ~= messages.ActionType.fromNumber(0)
			)
		then
			output.actionType = if typeof(self.action_type) == "number"
				then self.action_type
				else messages.ActionType.toNumber(self.action_type :: any)
		end

		if self.action_params ~= nil then
			output.actionParams = self.action_params:jsonEncode()
		end

		return output
	end

	function _OpenBadgeDetailsActionImpl.jsonDecode(input: { [string]: any }): OpenBadgeDetailsAction
		local self = _OpenBadgeDetailsActionImpl.new()

		if input.action_type ~= nil then
			self.action_type = if typeof(input.action_type) == "number"
				then (messages.ActionType.fromNumber(input.action_type) or input.action_type)
				else (messages.ActionType.fromName(input.action_type) or input.action_type)
		end

		if input.actionType ~= nil then
			self.action_type = if typeof(input.actionType) == "number"
				then (messages.ActionType.fromNumber(input.actionType) or input.actionType)
				else (messages.ActionType.fromName(input.actionType) or input.actionType)
		end

		if input.action_params ~= nil then
			self.action_params = messages.OpenBadgeDetailsAction_Params.jsonDecode(input.action_params)
		end

		if input.actionParams ~= nil then
			self.action_params = messages.OpenBadgeDetailsAction_Params.jsonDecode(input.actionParams)
		end

		return self
	end

	_OpenBadgeDetailsActionImpl.descriptor = {
		name = "OpenBadgeDetailsAction",
		fullName = "roblox.apppageplatform.shared.v1beta1.OpenBadgeDetailsAction",
	}

	messages.OpenBadgeDetailsAction = _OpenBadgeDetailsActionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenBadgeDetailsAction)
end

do
	local _OpenBadgeDetailsAction_ParamsImpl = {}
	_OpenBadgeDetailsAction_ParamsImpl.__index = _OpenBadgeDetailsAction_ParamsImpl

	function _OpenBadgeDetailsAction_ParamsImpl.new(
		data: _OpenBadgeDetailsAction_ParamsPartialFields?
	): OpenBadgeDetailsAction_Params
		return setmetatable({
			badge_id = if data == nil or data.badge_id == nil then nil else data.badge_id,
			title_text = if data == nil or data.title_text == nil then nil else data.title_text,
		}, _OpenBadgeDetailsAction_ParamsImpl :: _OpenBadgeDetailsAction_ParamsImpl)
	end

	function _OpenBadgeDetailsAction_ParamsImpl.encode(self: OpenBadgeDetailsAction_Params): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.badge_id ~= nil then
			local encoded = self.badge_id:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.title_text ~= nil then
			local encoded = self.title_text:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _OpenBadgeDetailsAction_ParamsImpl.decode(input: buffer): OpenBadgeDetailsAction_Params
		local self = _OpenBadgeDetailsAction_ParamsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.badge_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.title_text = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _OpenBadgeDetailsAction_ParamsImpl.jsonEncode(self: OpenBadgeDetailsAction_Params): any
		local output = {}

		if self.badge_id ~= nil then
			output.badgeId = self.badge_id:jsonEncode()
		end

		if self.title_text ~= nil then
			output.titleText = self.title_text:jsonEncode()
		end

		return output
	end

	function _OpenBadgeDetailsAction_ParamsImpl.jsonDecode(input: { [string]: any }): OpenBadgeDetailsAction_Params
		local self = _OpenBadgeDetailsAction_ParamsImpl.new()

		if input.badge_id ~= nil then
			self.badge_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.badge_id)
		end

		if input.badgeId ~= nil then
			self.badge_id = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.badgeId)
		end

		if input.title_text ~= nil then
			self.title_text = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.title_text)
		end

		if input.titleText ~= nil then
			self.title_text = _roblox_apppageplatform_shared_v1beta1_prop_types.StringProp.jsonDecode(input.titleText)
		end

		return self
	end

	_OpenBadgeDetailsAction_ParamsImpl.descriptor = {
		name = "OpenBadgeDetailsAction_Params",
		fullName = "roblox.apppageplatform.shared.v1beta1.Params",
	}

	messages.OpenBadgeDetailsAction_Params = _OpenBadgeDetailsAction_ParamsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.OpenBadgeDetailsAction_Params)
end

do
	local _ActionImpl = {}
	_ActionImpl.__index = _ActionImpl

	function _ActionImpl.new(data: _ActionPartialFields?): Action
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _ActionImpl :: _ActionImpl)
	end

	function _ActionImpl.encode(self: Action): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "dismiss_dialog_action" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "link_action" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "open_game_details_action" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "open_join_friends_action" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "open_marketplace_try_on_action" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "open_see_all_action" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 6, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "open_sponsored_tooltip_action" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 7, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "play_button_click_action" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 8, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "update_user_settings_action" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 9, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "open_tooltip_action" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 10, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "open_badge_details_action" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 11, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ActionImpl.decode(input: buffer): Action
		local self = _ActionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "dismiss_dialog_action", value = messages.DismissDialogAction.decode(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "link_action", value = messages.LinkAction.decode(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind =
						{ type = "open_game_details_action", value = messages.OpenGameDetailsAction.decode(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind =
						{ type = "open_join_friends_action", value = messages.OpenJoinFriendsAction.decode(value) }
					continue
				elseif field == 5 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = {
						type = "open_marketplace_try_on_action",
						value = messages.OpenMarketplaceTryOnAction.decode(value),
					}
					continue
				elseif field == 6 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "open_see_all_action", value = messages.OpenSeeAllAction.decode(value) }
					continue
				elseif field == 7 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = {
						type = "open_sponsored_tooltip_action",
						value = messages.OpenSponsoredTooltipAction.decode(value),
					}
					continue
				elseif field == 8 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind =
						{ type = "play_button_click_action", value = messages.PlayButtonClickAction.decode(value) }
					continue
				elseif field == 9 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = {
						type = "update_user_settings_action",
						value = messages.UpdateUserSettingsAction.decode(value),
					}
					continue
				elseif field == 10 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "open_tooltip_action", value = messages.OpenTooltipAction.decode(value) }
					continue
				elseif field == 11 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind =
						{ type = "open_badge_details_action", value = messages.OpenBadgeDetailsAction.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ActionImpl.jsonEncode(self: Action): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "dismiss_dialog_action" then
				output.dismissDialogAction = self.kind.value:jsonEncode()
			elseif self.kind.type == "link_action" then
				output.linkAction = self.kind.value:jsonEncode()
			elseif self.kind.type == "open_game_details_action" then
				output.openGameDetailsAction = self.kind.value:jsonEncode()
			elseif self.kind.type == "open_join_friends_action" then
				output.openJoinFriendsAction = self.kind.value:jsonEncode()
			elseif self.kind.type == "open_marketplace_try_on_action" then
				output.openMarketplaceTryOnAction = self.kind.value:jsonEncode()
			elseif self.kind.type == "open_see_all_action" then
				output.openSeeAllAction = self.kind.value:jsonEncode()
			elseif self.kind.type == "open_sponsored_tooltip_action" then
				output.openSponsoredTooltipAction = self.kind.value:jsonEncode()
			elseif self.kind.type == "play_button_click_action" then
				output.playButtonClickAction = self.kind.value:jsonEncode()
			elseif self.kind.type == "update_user_settings_action" then
				output.updateUserSettingsAction = self.kind.value:jsonEncode()
			elseif self.kind.type == "open_tooltip_action" then
				output.openTooltipAction = self.kind.value:jsonEncode()
			elseif self.kind.type == "open_badge_details_action" then
				output.openBadgeDetailsAction = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _ActionImpl.jsonDecode(input: { [string]: any }): Action
		local self = _ActionImpl.new()

		if input.dismiss_dialog_action ~= nil then
			self.kind = {
				type = "dismiss_dialog_action",
				value = messages.DismissDialogAction.jsonDecode(input.dismiss_dialog_action),
			}
		end

		if input.dismissDialogAction ~= nil then
			self.kind = {
				type = "dismiss_dialog_action",
				value = messages.DismissDialogAction.jsonDecode(input.dismissDialogAction),
			}
		end

		if input.link_action ~= nil then
			self.kind = { type = "link_action", value = messages.LinkAction.jsonDecode(input.link_action) }
		end

		if input.linkAction ~= nil then
			self.kind = { type = "link_action", value = messages.LinkAction.jsonDecode(input.linkAction) }
		end

		if input.open_game_details_action ~= nil then
			self.kind = {
				type = "open_game_details_action",
				value = messages.OpenGameDetailsAction.jsonDecode(input.open_game_details_action),
			}
		end

		if input.openGameDetailsAction ~= nil then
			self.kind = {
				type = "open_game_details_action",
				value = messages.OpenGameDetailsAction.jsonDecode(input.openGameDetailsAction),
			}
		end

		if input.open_join_friends_action ~= nil then
			self.kind = {
				type = "open_join_friends_action",
				value = messages.OpenJoinFriendsAction.jsonDecode(input.open_join_friends_action),
			}
		end

		if input.openJoinFriendsAction ~= nil then
			self.kind = {
				type = "open_join_friends_action",
				value = messages.OpenJoinFriendsAction.jsonDecode(input.openJoinFriendsAction),
			}
		end

		if input.open_marketplace_try_on_action ~= nil then
			self.kind = {
				type = "open_marketplace_try_on_action",
				value = messages.OpenMarketplaceTryOnAction.jsonDecode(input.open_marketplace_try_on_action),
			}
		end

		if input.openMarketplaceTryOnAction ~= nil then
			self.kind = {
				type = "open_marketplace_try_on_action",
				value = messages.OpenMarketplaceTryOnAction.jsonDecode(input.openMarketplaceTryOnAction),
			}
		end

		if input.open_see_all_action ~= nil then
			self.kind = {
				type = "open_see_all_action",
				value = messages.OpenSeeAllAction.jsonDecode(input.open_see_all_action),
			}
		end

		if input.openSeeAllAction ~= nil then
			self.kind =
				{ type = "open_see_all_action", value = messages.OpenSeeAllAction.jsonDecode(input.openSeeAllAction) }
		end

		if input.open_sponsored_tooltip_action ~= nil then
			self.kind = {
				type = "open_sponsored_tooltip_action",
				value = messages.OpenSponsoredTooltipAction.jsonDecode(input.open_sponsored_tooltip_action),
			}
		end

		if input.openSponsoredTooltipAction ~= nil then
			self.kind = {
				type = "open_sponsored_tooltip_action",
				value = messages.OpenSponsoredTooltipAction.jsonDecode(input.openSponsoredTooltipAction),
			}
		end

		if input.play_button_click_action ~= nil then
			self.kind = {
				type = "play_button_click_action",
				value = messages.PlayButtonClickAction.jsonDecode(input.play_button_click_action),
			}
		end

		if input.playButtonClickAction ~= nil then
			self.kind = {
				type = "play_button_click_action",
				value = messages.PlayButtonClickAction.jsonDecode(input.playButtonClickAction),
			}
		end

		if input.update_user_settings_action ~= nil then
			self.kind = {
				type = "update_user_settings_action",
				value = messages.UpdateUserSettingsAction.jsonDecode(input.update_user_settings_action),
			}
		end

		if input.updateUserSettingsAction ~= nil then
			self.kind = {
				type = "update_user_settings_action",
				value = messages.UpdateUserSettingsAction.jsonDecode(input.updateUserSettingsAction),
			}
		end

		if input.open_tooltip_action ~= nil then
			self.kind = {
				type = "open_tooltip_action",
				value = messages.OpenTooltipAction.jsonDecode(input.open_tooltip_action),
			}
		end

		if input.openTooltipAction ~= nil then
			self.kind =
				{ type = "open_tooltip_action", value = messages.OpenTooltipAction.jsonDecode(input.openTooltipAction) }
		end

		if input.open_badge_details_action ~= nil then
			self.kind = {
				type = "open_badge_details_action",
				value = messages.OpenBadgeDetailsAction.jsonDecode(input.open_badge_details_action),
			}
		end

		if input.openBadgeDetailsAction ~= nil then
			self.kind = {
				type = "open_badge_details_action",
				value = messages.OpenBadgeDetailsAction.jsonDecode(input.openBadgeDetailsAction),
			}
		end

		return self
	end

	_ActionImpl.descriptor = {
		name = "Action",
		fullName = "roblox.apppageplatform.shared.v1beta1.Action",
	}

	messages.Action = _ActionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Action)
end

do
	local _ActionPropImpl = {}
	_ActionPropImpl.__index = _ActionPropImpl

	function _ActionPropImpl.new(data: _ActionPropPartialFields?): ActionProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _ActionPropImpl :: _ActionPropImpl)
	end

	function _ActionPropImpl.encode(self: ActionProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "value" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ActionPropImpl.decode(input: buffer): ActionProp
		local self = _ActionPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "value", value = messages.Action.decode(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.ActionProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ActionPropImpl.jsonEncode(self: ActionProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "value" then
				output.value = self.kind.value:jsonEncode()
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _ActionPropImpl.jsonDecode(input: { [string]: any }): ActionProp
		local self = _ActionPropImpl.new()

		if input.value ~= nil then
			self.kind = { type = "value", value = messages.Action.jsonDecode(input.value) }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.ActionProp_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_ActionPropImpl.descriptor = {
		name = "ActionProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.ActionProp",
	}

	messages.ActionProp = _ActionPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ActionProp)
end

do
	local _ActionProp_ConditionalOptionImpl = {}
	_ActionProp_ConditionalOptionImpl.__index = _ActionProp_ConditionalOptionImpl

	function _ActionProp_ConditionalOptionImpl.new(
		data: _ActionProp_ConditionalOptionPartialFields?
	): ActionProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			value = if data == nil or data.value == nil then nil else data.value,
		}, _ActionProp_ConditionalOptionImpl :: _ActionProp_ConditionalOptionImpl)
	end

	function _ActionProp_ConditionalOptionImpl.encode(self: ActionProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.value ~= nil then
			local encoded = self.value:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ActionProp_ConditionalOptionImpl.decode(input: buffer): ActionProp_ConditionalOption
		local self = _ActionProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = messages.Action.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ActionProp_ConditionalOptionImpl.jsonEncode(self: ActionProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.value ~= nil then
			output.value = self.value:jsonEncode()
		end

		return output
	end

	function _ActionProp_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): ActionProp_ConditionalOption
		local self = _ActionProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.value ~= nil then
			self.value = messages.Action.jsonDecode(input.value)
		end

		return self
	end

	_ActionProp_ConditionalOptionImpl.descriptor = {
		name = "ActionProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.ActionProp_ConditionalOption = _ActionProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ActionProp_ConditionalOption)
end

do
	local _ActionProp_ConditionalOptionsImpl = {}
	_ActionProp_ConditionalOptionsImpl.__index = _ActionProp_ConditionalOptionsImpl

	function _ActionProp_ConditionalOptionsImpl.new(
		data: _ActionProp_ConditionalOptionsPartialFields?
	): ActionProp_ConditionalOptions
		return setmetatable({
			options = if data == nil or data.options == nil then {} else data.options,
		}, _ActionProp_ConditionalOptionsImpl :: _ActionProp_ConditionalOptionsImpl)
	end

	function _ActionProp_ConditionalOptionsImpl.encode(self: ActionProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.options ~= nil and #self.options > 0 then
			for _, value in self.options do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ActionProp_ConditionalOptionsImpl.decode(input: buffer): ActionProp_ConditionalOptions
		local self = _ActionProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.options, messages.ActionProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ActionProp_ConditionalOptionsImpl.jsonEncode(self: ActionProp_ConditionalOptions): any
		local output = {}

		if self.options ~= nil and #self.options > 0 then
			local newOutput = {}
			for _, value in self.options do
				table.insert(newOutput, value:jsonEncode())
			end
			output.options = newOutput
		end

		return output
	end

	function _ActionProp_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): ActionProp_ConditionalOptions
		local self = _ActionProp_ConditionalOptionsImpl.new()

		if input.options ~= nil then
			local newOutput: { ActionProp_ConditionalOption } = {}
			for _, value in input.options do
				table.insert(newOutput, messages.ActionProp_ConditionalOption.jsonDecode(value))
			end

			self.options = newOutput
		end

		return self
	end

	_ActionProp_ConditionalOptionsImpl.descriptor = {
		name = "ActionProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.ActionProp_ConditionalOptions = _ActionProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ActionProp_ConditionalOptions)
end

do
	local _FocusNavActionsPropImpl = {}
	_FocusNavActionsPropImpl.__index = _FocusNavActionsPropImpl

	function _FocusNavActionsPropImpl.new(data: _FocusNavActionsPropPartialFields?): FocusNavActionsProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _FocusNavActionsPropImpl :: _FocusNavActionsPropImpl)
	end

	function _FocusNavActionsPropImpl.encode(self: FocusNavActionsProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "value" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _FocusNavActionsPropImpl.decode(input: buffer): FocusNavActionsProp
		local self = _FocusNavActionsPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "value", value = messages.FocusNavActionsProp_FocusNavData.decode(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind =
						{ type = "conditional", value = messages.FocusNavActionsProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _FocusNavActionsPropImpl.jsonEncode(self: FocusNavActionsProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "value" then
				output.value = self.kind.value:jsonEncode()
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _FocusNavActionsPropImpl.jsonDecode(input: { [string]: any }): FocusNavActionsProp
		local self = _FocusNavActionsPropImpl.new()

		if input.value ~= nil then
			self.kind = { type = "value", value = messages.FocusNavActionsProp_FocusNavData.jsonDecode(input.value) }
		end

		if input.conditional ~= nil then
			self.kind = {
				type = "conditional",
				value = messages.FocusNavActionsProp_ConditionalOptions.jsonDecode(input.conditional),
			}
		end

		return self
	end

	_FocusNavActionsPropImpl.descriptor = {
		name = "FocusNavActionsProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.FocusNavActionsProp",
	}

	messages.FocusNavActionsProp = _FocusNavActionsPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.FocusNavActionsProp)
end

do
	local _FocusNavActionsProp_ConditionalOptionImpl = {}
	_FocusNavActionsProp_ConditionalOptionImpl.__index = _FocusNavActionsProp_ConditionalOptionImpl

	function _FocusNavActionsProp_ConditionalOptionImpl.new(
		data: _FocusNavActionsProp_ConditionalOptionPartialFields?
	): FocusNavActionsProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			value = if data == nil or data.value == nil then nil else data.value,
		}, _FocusNavActionsProp_ConditionalOptionImpl :: _FocusNavActionsProp_ConditionalOptionImpl)
	end

	function _FocusNavActionsProp_ConditionalOptionImpl.encode(self: FocusNavActionsProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.value ~= nil then
			local encoded = self.value:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _FocusNavActionsProp_ConditionalOptionImpl.decode(input: buffer): FocusNavActionsProp_ConditionalOption
		local self = _FocusNavActionsProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = messages.FocusNavActionsProp.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _FocusNavActionsProp_ConditionalOptionImpl.jsonEncode(self: FocusNavActionsProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.value ~= nil then
			output.value = self.value:jsonEncode()
		end

		return output
	end

	function _FocusNavActionsProp_ConditionalOptionImpl.jsonDecode(
		input: { [string]: any }
	): FocusNavActionsProp_ConditionalOption
		local self = _FocusNavActionsProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.value ~= nil then
			self.value = messages.FocusNavActionsProp.jsonDecode(input.value)
		end

		return self
	end

	_FocusNavActionsProp_ConditionalOptionImpl.descriptor = {
		name = "FocusNavActionsProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.FocusNavActionsProp_ConditionalOption = _FocusNavActionsProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.FocusNavActionsProp_ConditionalOption)
end

do
	local _FocusNavActionsProp_ConditionalOptionsImpl = {}
	_FocusNavActionsProp_ConditionalOptionsImpl.__index = _FocusNavActionsProp_ConditionalOptionsImpl

	function _FocusNavActionsProp_ConditionalOptionsImpl.new(
		data: _FocusNavActionsProp_ConditionalOptionsPartialFields?
	): FocusNavActionsProp_ConditionalOptions
		return setmetatable({
			options = if data == nil or data.options == nil then {} else data.options,
		}, _FocusNavActionsProp_ConditionalOptionsImpl :: _FocusNavActionsProp_ConditionalOptionsImpl)
	end

	function _FocusNavActionsProp_ConditionalOptionsImpl.encode(self: FocusNavActionsProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.options ~= nil and #self.options > 0 then
			for _, value in self.options do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _FocusNavActionsProp_ConditionalOptionsImpl.decode(input: buffer): FocusNavActionsProp_ConditionalOptions
		local self = _FocusNavActionsProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.options, messages.FocusNavActionsProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _FocusNavActionsProp_ConditionalOptionsImpl.jsonEncode(self: FocusNavActionsProp_ConditionalOptions): any
		local output = {}

		if self.options ~= nil and #self.options > 0 then
			local newOutput = {}
			for _, value in self.options do
				table.insert(newOutput, value:jsonEncode())
			end
			output.options = newOutput
		end

		return output
	end

	function _FocusNavActionsProp_ConditionalOptionsImpl.jsonDecode(
		input: { [string]: any }
	): FocusNavActionsProp_ConditionalOptions
		local self = _FocusNavActionsProp_ConditionalOptionsImpl.new()

		if input.options ~= nil then
			local newOutput: { FocusNavActionsProp_ConditionalOption } = {}
			for _, value in input.options do
				table.insert(newOutput, messages.FocusNavActionsProp_ConditionalOption.jsonDecode(value))
			end

			self.options = newOutput
		end

		return self
	end

	_FocusNavActionsProp_ConditionalOptionsImpl.descriptor = {
		name = "FocusNavActionsProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.FocusNavActionsProp_ConditionalOptions = _FocusNavActionsProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.FocusNavActionsProp_ConditionalOptions)
end

do
	local _FocusNavActionsProp_FocusNavDataImpl = {}
	_FocusNavActionsProp_FocusNavDataImpl.__index = _FocusNavActionsProp_FocusNavDataImpl

	function _FocusNavActionsProp_FocusNavDataImpl.new(
		data: _FocusNavActionsProp_FocusNavDataPartialFields?
	): FocusNavActionsProp_FocusNavData
		return setmetatable({
			keys = if data == nil or data.keys == nil then {} else data.keys,
			events = if data == nil or data.events == nil then {} else data.events,
		}, _FocusNavActionsProp_FocusNavDataImpl :: _FocusNavActionsProp_FocusNavDataImpl)
	end

	function _FocusNavActionsProp_FocusNavDataImpl.encode(self: FocusNavActionsProp_FocusNavData): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.keys ~= nil and next(self.keys) ~= nil then
			for key, value in self.keys do
				local mapBuffer = buffer.create(0)
				local mapCursor = 0
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 1, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeString(mapBuffer, mapCursor, key)
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 2, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeString(mapBuffer, mapCursor, value)
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, mapBuffer, mapCursor)
			end
		end

		if self.events ~= nil and next(self.events) ~= nil then
			for key, value in self.events do
				local mapBuffer = buffer.create(0)
				local mapCursor = 0
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 1, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeString(mapBuffer, mapCursor, key)
				local encoded = value:encode()
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 2, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeBuffer(mapBuffer, mapCursor, encoded, buffer.len(encoded))
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, mapBuffer, mapCursor)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _FocusNavActionsProp_FocusNavDataImpl.decode(input: buffer): FocusNavActionsProp_FocusNavData
		local self = _FocusNavActionsProp_FocusNavDataImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)

					local mapEntry = messages.FocusNavActionsProp_FocusNavData_KeysEntry.decode(value)

					local keyDefault = ""
					local valueDefault = ""

					self.keys[mapEntry.key or keyDefault] = mapEntry.value or valueDefault

					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)

					local mapEntry = messages.FocusNavActionsProp_FocusNavData_EventsEntry.decode(value)

					local keyDefault = ""
					local valueDefault = _google_protobuf_struct.Struct.new()

					self.events[mapEntry.key or keyDefault] = mapEntry.value or valueDefault

					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _FocusNavActionsProp_FocusNavDataImpl.jsonEncode(self: FocusNavActionsProp_FocusNavData): any
		local output = {}

		if self.keys ~= nil and next(self.keys) ~= nil then
			local newOutput = {}
			for key, value in self.keys do
				newOutput[key] = value
			end
			output.keys = newOutput
		end

		if self.events ~= nil and next(self.events) ~= nil then
			local newOutput = {}
			for key, value in self.events do
				newOutput[key] = value:jsonEncode()
			end
			output.events = newOutput
		end

		return output
	end

	function _FocusNavActionsProp_FocusNavDataImpl.jsonDecode(
		input: { [string]: any }
	): FocusNavActionsProp_FocusNavData
		local self = _FocusNavActionsProp_FocusNavDataImpl.new()

		if input.keys ~= nil then
			local newOutput: { [string]: string } = {}
			for key, value in input.keys do
				newOutput[key] = value
			end

			self.keys = newOutput
		end

		if input.events ~= nil then
			local newOutput: { [string]: _google_protobuf_struct.Struct } = {}
			for key, value in input.events do
				newOutput[key] = _google_protobuf_struct.Struct.jsonDecode(value)
			end

			self.events = newOutput
		end

		return self
	end

	_FocusNavActionsProp_FocusNavDataImpl.descriptor = {
		name = "FocusNavActionsProp_FocusNavData",
		fullName = "roblox.apppageplatform.shared.v1beta1.FocusNavData",
	}

	messages.FocusNavActionsProp_FocusNavData = _FocusNavActionsProp_FocusNavDataImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.FocusNavActionsProp_FocusNavData)
end

do
	local _FocusNavActionsProp_FocusNavData_KeysEntryImpl = {}
	_FocusNavActionsProp_FocusNavData_KeysEntryImpl.__index = _FocusNavActionsProp_FocusNavData_KeysEntryImpl

	function _FocusNavActionsProp_FocusNavData_KeysEntryImpl.new(
		data: _FocusNavActionsProp_FocusNavData_KeysEntryPartialFields?
	): FocusNavActionsProp_FocusNavData_KeysEntry
		return setmetatable({
			key = if data == nil or data.key == nil then "" else data.key,
			value = if data == nil or data.value == nil then "" else data.value,
		}, _FocusNavActionsProp_FocusNavData_KeysEntryImpl :: _FocusNavActionsProp_FocusNavData_KeysEntryImpl)
	end

	function _FocusNavActionsProp_FocusNavData_KeysEntryImpl.encode(
		self: FocusNavActionsProp_FocusNavData_KeysEntry
	): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.key ~= nil and self.key ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.key)
		end

		if self.value ~= nil and self.value ~= "" then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _FocusNavActionsProp_FocusNavData_KeysEntryImpl.decode(
		input: buffer
	): FocusNavActionsProp_FocusNavData_KeysEntry
		local self = _FocusNavActionsProp_FocusNavData_KeysEntryImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.key = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _FocusNavActionsProp_FocusNavData_KeysEntryImpl.jsonEncode(
		self: FocusNavActionsProp_FocusNavData_KeysEntry
	): any
		local output = {}

		if self.key ~= nil and self.key ~= "" then
			output.key = self.key
		end

		if self.value ~= nil and self.value ~= "" then
			output.value = self.value
		end

		return output
	end

	function _FocusNavActionsProp_FocusNavData_KeysEntryImpl.jsonDecode(
		input: { [string]: any }
	): FocusNavActionsProp_FocusNavData_KeysEntry
		local self = _FocusNavActionsProp_FocusNavData_KeysEntryImpl.new()

		if input.key ~= nil then
			self.key = input.key
		end

		if input.value ~= nil then
			self.value = input.value
		end

		return self
	end

	_FocusNavActionsProp_FocusNavData_KeysEntryImpl.descriptor = {
		name = "FocusNavActionsProp_FocusNavData_KeysEntry",
		fullName = "roblox.apppageplatform.shared.v1beta1.KeysEntry",
	}

	messages.FocusNavActionsProp_FocusNavData_KeysEntry = _FocusNavActionsProp_FocusNavData_KeysEntryImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.FocusNavActionsProp_FocusNavData_KeysEntry)
end

do
	local _FocusNavActionsProp_FocusNavData_EventsEntryImpl = {}
	_FocusNavActionsProp_FocusNavData_EventsEntryImpl.__index = _FocusNavActionsProp_FocusNavData_EventsEntryImpl

	function _FocusNavActionsProp_FocusNavData_EventsEntryImpl.new(
		data: _FocusNavActionsProp_FocusNavData_EventsEntryPartialFields?
	): FocusNavActionsProp_FocusNavData_EventsEntry
		return setmetatable({
			key = if data == nil or data.key == nil then "" else data.key,
			value = if data == nil or data.value == nil then nil else data.value,
		}, _FocusNavActionsProp_FocusNavData_EventsEntryImpl :: _FocusNavActionsProp_FocusNavData_EventsEntryImpl)
	end

	function _FocusNavActionsProp_FocusNavData_EventsEntryImpl.encode(
		self: FocusNavActionsProp_FocusNavData_EventsEntry
	): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.key ~= nil and self.key ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.key)
		end

		if self.value ~= nil then
			local encoded = self.value:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _FocusNavActionsProp_FocusNavData_EventsEntryImpl.decode(
		input: buffer
	): FocusNavActionsProp_FocusNavData_EventsEntry
		local self = _FocusNavActionsProp_FocusNavData_EventsEntryImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.key = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = _google_protobuf_struct.Struct.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _FocusNavActionsProp_FocusNavData_EventsEntryImpl.jsonEncode(
		self: FocusNavActionsProp_FocusNavData_EventsEntry
	): any
		local output = {}

		if self.key ~= nil and self.key ~= "" then
			output.key = self.key
		end

		if self.value ~= nil then
			output.value = self.value:jsonEncode()
		end

		return output
	end

	function _FocusNavActionsProp_FocusNavData_EventsEntryImpl.jsonDecode(
		input: { [string]: any }
	): FocusNavActionsProp_FocusNavData_EventsEntry
		local self = _FocusNavActionsProp_FocusNavData_EventsEntryImpl.new()

		if input.key ~= nil then
			self.key = input.key
		end

		if input.value ~= nil then
			self.value = _google_protobuf_struct.Struct.jsonDecode(input.value)
		end

		return self
	end

	_FocusNavActionsProp_FocusNavData_EventsEntryImpl.descriptor = {
		name = "FocusNavActionsProp_FocusNavData_EventsEntry",
		fullName = "roblox.apppageplatform.shared.v1beta1.EventsEntry",
	}

	messages.FocusNavActionsProp_FocusNavData_EventsEntry = _FocusNavActionsProp_FocusNavData_EventsEntryImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.FocusNavActionsProp_FocusNavData_EventsEntry)
end

messages.ActionType = {
	fromNumber = function(value: number): ActionType?
		if value == 0 then
			return "ACTION_TYPE_INVALID"
		elseif value == 1 then
			return "ACTION_TYPE_DISMISS_DIALOG"
		elseif value == 2 then
			return "ACTION_TYPE_LINK"
		elseif value == 3 then
			return "ACTION_TYPE_OPEN_GAME_DETAILS"
		elseif value == 4 then
			return "ACTION_TYPE_OPEN_JOIN_FRIENDS"
		elseif value == 5 then
			return "ACTION_TYPE_OPEN_MARKETPLACE_TRY_ON"
		elseif value == 6 then
			return "ACTION_TYPE_OPEN_SEE_ALL"
		elseif value == 7 then
			return "ACTION_TYPE_OPEN_SPONSORED_TOOLTIP"
		elseif value == 8 then
			return "ACTION_TYPE_PLAY_BUTTON_CLICK"
		elseif value == 9 then
			return "ACTION_TYPE_UPDATE_USER_SETTINGS"
		elseif value == 10 then
			return "ACTION_TYPE_OPEN_TOOLTIP"
		elseif value == 11 then
			return "ACTION_TYPE_OPEN_BADGE_DETAILS"
		else
			return nil
		end
	end,

	toNumber = function(self: ActionType): number
		if self == "ACTION_TYPE_INVALID" then
			return 0
		elseif self == "ACTION_TYPE_DISMISS_DIALOG" then
			return 1
		elseif self == "ACTION_TYPE_LINK" then
			return 2
		elseif self == "ACTION_TYPE_OPEN_GAME_DETAILS" then
			return 3
		elseif self == "ACTION_TYPE_OPEN_JOIN_FRIENDS" then
			return 4
		elseif self == "ACTION_TYPE_OPEN_MARKETPLACE_TRY_ON" then
			return 5
		elseif self == "ACTION_TYPE_OPEN_SEE_ALL" then
			return 6
		elseif self == "ACTION_TYPE_OPEN_SPONSORED_TOOLTIP" then
			return 7
		elseif self == "ACTION_TYPE_PLAY_BUTTON_CLICK" then
			return 8
		elseif self == "ACTION_TYPE_UPDATE_USER_SETTINGS" then
			return 9
		elseif self == "ACTION_TYPE_OPEN_TOOLTIP" then
			return 10
		elseif self == "ACTION_TYPE_OPEN_BADGE_DETAILS" then
			return 11
		else
			return self
		end
	end,

	fromName = function(name: string): ActionType?
		if name == "ACTION_TYPE_INVALID" then
			return "ACTION_TYPE_INVALID"
		elseif name == "ACTION_TYPE_DISMISS_DIALOG" then
			return "ACTION_TYPE_DISMISS_DIALOG"
		elseif name == "ACTION_TYPE_LINK" then
			return "ACTION_TYPE_LINK"
		elseif name == "ACTION_TYPE_OPEN_GAME_DETAILS" then
			return "ACTION_TYPE_OPEN_GAME_DETAILS"
		elseif name == "ACTION_TYPE_OPEN_JOIN_FRIENDS" then
			return "ACTION_TYPE_OPEN_JOIN_FRIENDS"
		elseif name == "ACTION_TYPE_OPEN_MARKETPLACE_TRY_ON" then
			return "ACTION_TYPE_OPEN_MARKETPLACE_TRY_ON"
		elseif name == "ACTION_TYPE_OPEN_SEE_ALL" then
			return "ACTION_TYPE_OPEN_SEE_ALL"
		elseif name == "ACTION_TYPE_OPEN_SPONSORED_TOOLTIP" then
			return "ACTION_TYPE_OPEN_SPONSORED_TOOLTIP"
		elseif name == "ACTION_TYPE_PLAY_BUTTON_CLICK" then
			return "ACTION_TYPE_PLAY_BUTTON_CLICK"
		elseif name == "ACTION_TYPE_UPDATE_USER_SETTINGS" then
			return "ACTION_TYPE_UPDATE_USER_SETTINGS"
		elseif name == "ACTION_TYPE_OPEN_TOOLTIP" then
			return "ACTION_TYPE_OPEN_TOOLTIP"
		elseif name == "ACTION_TYPE_OPEN_BADGE_DETAILS" then
			return "ACTION_TYPE_OPEN_BADGE_DETAILS"
		else
			return nil
		end
	end,
}

return {
	DismissDialogAction = messages.DismissDialogAction,
	DismissDialogAction_Params = messages.DismissDialogAction_Params,
	LinkAction = messages.LinkAction,
	LinkAction_Params = messages.LinkAction_Params,
	OpenGameDetailsAction = messages.OpenGameDetailsAction,
	OpenGameDetailsAction_Params = messages.OpenGameDetailsAction_Params,
	OpenJoinFriendsAction = messages.OpenJoinFriendsAction,
	OpenJoinFriendsAction_Params = messages.OpenJoinFriendsAction_Params,
	OpenMarketplaceTryOnAction = messages.OpenMarketplaceTryOnAction,
	OpenMarketplaceTryOnAction_Params = messages.OpenMarketplaceTryOnAction_Params,
	OpenSeeAllAction = messages.OpenSeeAllAction,
	OpenSeeAllAction_Params = messages.OpenSeeAllAction_Params,
	OpenSponsoredTooltipAction = messages.OpenSponsoredTooltipAction,
	OpenSponsoredTooltipAction_Params = messages.OpenSponsoredTooltipAction_Params,
	PlayButtonClickAction = messages.PlayButtonClickAction,
	PlayButtonClickAction_Params = messages.PlayButtonClickAction_Params,
	UpdateUserSettingsAction = messages.UpdateUserSettingsAction,
	UpdateUserSettingsAction_Params = messages.UpdateUserSettingsAction_Params,
	OpenTooltipAction = messages.OpenTooltipAction,
	OpenTooltipAction_Params = messages.OpenTooltipAction_Params,
	OpenBadgeDetailsAction = messages.OpenBadgeDetailsAction,
	OpenBadgeDetailsAction_Params = messages.OpenBadgeDetailsAction_Params,
	Action = messages.Action,
	ActionProp = messages.ActionProp,
	ActionProp_ConditionalOption = messages.ActionProp_ConditionalOption,
	ActionProp_ConditionalOptions = messages.ActionProp_ConditionalOptions,
	FocusNavActionsProp = messages.FocusNavActionsProp,
	FocusNavActionsProp_ConditionalOption = messages.FocusNavActionsProp_ConditionalOption,
	FocusNavActionsProp_ConditionalOptions = messages.FocusNavActionsProp_ConditionalOptions,
	FocusNavActionsProp_FocusNavData = messages.FocusNavActionsProp_FocusNavData,
	ActionType = messages.ActionType,
}
