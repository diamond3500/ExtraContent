--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require(script.Parent.Parent.Parent.Parent.Parent.proto)
local typeRegistry = require(script.Parent.Parent.Parent.Parent.Parent.proto.typeRegistry)

type _Messages = {
	HydrationContent: _HydrationContentMessage,
	HydrationContent_BadgeEntry: _HydrationContent_BadgeEntryMessage,
}
local messages: _Messages = {} :: _Messages

local _roblox_apppageplatform_shared_v1beta1_badge_data = require(script.Parent.badge_data)

type _HydrationContentImpl = {
	__index: _HydrationContentImpl,
	new: (fields: _HydrationContentPartialFields?) -> HydrationContent,
	encode: (self: HydrationContent) -> buffer,
	decode: (input: buffer) -> HydrationContent,
	jsonEncode: (self: HydrationContent) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> HydrationContent,
	descriptor: proto.Descriptor,
}

type _HydrationContentFields = {
	badge: { [string]: _roblox_apppageplatform_shared_v1beta1_badge_data.BadgeData },
}

type _HydrationContentPartialFields = {
	badge: { [string]: _roblox_apppageplatform_shared_v1beta1_badge_data.BadgeData }?,
}

export type HydrationContent = typeof(setmetatable({} :: _HydrationContentFields, {} :: _HydrationContentImpl))
type _HydrationContentMessage = proto.Message<HydrationContent, _HydrationContentPartialFields>

type _HydrationContent_BadgeEntryImpl = {
	__index: _HydrationContent_BadgeEntryImpl,
	new: (fields: _HydrationContent_BadgeEntryPartialFields?) -> HydrationContent_BadgeEntry,
	encode: (self: HydrationContent_BadgeEntry) -> buffer,
	decode: (input: buffer) -> HydrationContent_BadgeEntry,
	jsonEncode: (self: HydrationContent_BadgeEntry) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> HydrationContent_BadgeEntry,
	descriptor: proto.Descriptor,
}

type _HydrationContent_BadgeEntryFields = {
	key: string,
	value: _roblox_apppageplatform_shared_v1beta1_badge_data.BadgeData?,
}

type _HydrationContent_BadgeEntryPartialFields = {
	key: string?,
	value: _roblox_apppageplatform_shared_v1beta1_badge_data.BadgeData?,
}

export type HydrationContent_BadgeEntry = typeof(setmetatable(
	{} :: _HydrationContent_BadgeEntryFields,
	{} :: _HydrationContent_BadgeEntryImpl
))
type _HydrationContent_BadgeEntryMessage = proto.Message<
	HydrationContent_BadgeEntry,
	_HydrationContent_BadgeEntryPartialFields
>

do
	local _HydrationContentImpl = {}
	_HydrationContentImpl.__index = _HydrationContentImpl

	function _HydrationContentImpl.new(data: _HydrationContentPartialFields?): HydrationContent
		return setmetatable({
			badge = if data == nil or data.badge == nil then {} else data.badge,
		}, _HydrationContentImpl :: _HydrationContentImpl)
	end

	function _HydrationContentImpl.encode(self: HydrationContent): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.badge ~= nil and next(self.badge) ~= nil then
			for key, value in self.badge do
				local mapBuffer = buffer.create(0)
				local mapCursor = 0
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 1, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeString(mapBuffer, mapCursor, key)
				local encoded = value:encode()
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 2, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeBuffer(mapBuffer, mapCursor, encoded, buffer.len(encoded))
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, mapBuffer, mapCursor)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _HydrationContentImpl.decode(input: buffer): HydrationContent
		local self = _HydrationContentImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)

					local mapEntry = messages.HydrationContent_BadgeEntry.decode(value)

					local keyDefault = ""
					local valueDefault = _roblox_apppageplatform_shared_v1beta1_badge_data.BadgeData.new()

					self.badge[mapEntry.key or keyDefault] = mapEntry.value or valueDefault

					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _HydrationContentImpl.jsonEncode(self: HydrationContent): any
		local output = {}

		if self.badge ~= nil and next(self.badge) ~= nil then
			local newOutput = {}
			for key, value in self.badge do
				newOutput[key] = value:jsonEncode()
			end
			output.badge = newOutput
		end

		return output
	end

	function _HydrationContentImpl.jsonDecode(input: { [string]: any }): HydrationContent
		local self = _HydrationContentImpl.new()

		if input.badge ~= nil then
			local newOutput: { [string]: _roblox_apppageplatform_shared_v1beta1_badge_data.BadgeData } = {}
			for key, value in input.badge do
				newOutput[key] = _roblox_apppageplatform_shared_v1beta1_badge_data.BadgeData.jsonDecode(value)
			end

			self.badge = newOutput
		end

		return self
	end

	_HydrationContentImpl.descriptor = {
		name = "HydrationContent",
		fullName = "roblox.apppageplatform.shared.v1beta1.HydrationContent",
	}

	messages.HydrationContent = _HydrationContentImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.HydrationContent)
end

do
	local _HydrationContent_BadgeEntryImpl = {}
	_HydrationContent_BadgeEntryImpl.__index = _HydrationContent_BadgeEntryImpl

	function _HydrationContent_BadgeEntryImpl.new(
		data: _HydrationContent_BadgeEntryPartialFields?
	): HydrationContent_BadgeEntry
		return setmetatable({
			key = if data == nil or data.key == nil then "" else data.key,
			value = if data == nil or data.value == nil then nil else data.value,
		}, _HydrationContent_BadgeEntryImpl :: _HydrationContent_BadgeEntryImpl)
	end

	function _HydrationContent_BadgeEntryImpl.encode(self: HydrationContent_BadgeEntry): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.key ~= nil and self.key ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.key)
		end

		if self.value ~= nil then
			local encoded = self.value:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _HydrationContent_BadgeEntryImpl.decode(input: buffer): HydrationContent_BadgeEntry
		local self = _HydrationContent_BadgeEntryImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.key = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = _roblox_apppageplatform_shared_v1beta1_badge_data.BadgeData.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _HydrationContent_BadgeEntryImpl.jsonEncode(self: HydrationContent_BadgeEntry): any
		local output = {}

		if self.key ~= nil and self.key ~= "" then
			output.key = self.key
		end

		if self.value ~= nil then
			output.value = self.value:jsonEncode()
		end

		return output
	end

	function _HydrationContent_BadgeEntryImpl.jsonDecode(input: { [string]: any }): HydrationContent_BadgeEntry
		local self = _HydrationContent_BadgeEntryImpl.new()

		if input.key ~= nil then
			self.key = input.key
		end

		if input.value ~= nil then
			self.value = _roblox_apppageplatform_shared_v1beta1_badge_data.BadgeData.jsonDecode(input.value)
		end

		return self
	end

	_HydrationContent_BadgeEntryImpl.descriptor = {
		name = "HydrationContent_BadgeEntry",
		fullName = "roblox.apppageplatform.shared.v1beta1.BadgeEntry",
	}

	messages.HydrationContent_BadgeEntry = _HydrationContent_BadgeEntryImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.HydrationContent_BadgeEntry)
end

return {
	HydrationContent = messages.HydrationContent,
}
