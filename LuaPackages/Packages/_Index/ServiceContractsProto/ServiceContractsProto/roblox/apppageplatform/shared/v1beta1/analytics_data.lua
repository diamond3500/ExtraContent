--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require(script.Parent.Parent.Parent.Parent.Parent.proto)
local typeRegistry = require(script.Parent.Parent.Parent.Parent.Parent.proto.typeRegistry)

type _Messages = {
	AnalyticsDataField: _AnalyticsDataFieldMessage,
}
local messages: _Messages = {} :: _Messages

type _AnalyticsDataFieldImpl = {
	__index: _AnalyticsDataFieldImpl,
	new: (fields: _AnalyticsDataFieldPartialFields?) -> AnalyticsDataField,
	encode: (self: AnalyticsDataField) -> buffer,
	decode: (input: buffer) -> AnalyticsDataField,
	jsonEncode: (self: AnalyticsDataField) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> AnalyticsDataField,
	descriptor: proto.Descriptor,
}

type _AnalyticsDataFieldFields = {
	kind: ({ type: "binding_path", value: string } | { type: "literal", value: string })?,
}

type _AnalyticsDataFieldPartialFields = {
	kind: ({ type: "binding_path", value: string } | { type: "literal", value: string })?,
}

export type AnalyticsDataField = typeof(setmetatable({} :: _AnalyticsDataFieldFields, {} :: _AnalyticsDataFieldImpl))
type _AnalyticsDataFieldMessage = proto.Message<AnalyticsDataField, _AnalyticsDataFieldPartialFields>

do
	local _AnalyticsDataFieldImpl = {}
	_AnalyticsDataFieldImpl.__index = _AnalyticsDataFieldImpl

	function _AnalyticsDataFieldImpl.new(data: _AnalyticsDataFieldPartialFields?): AnalyticsDataField
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _AnalyticsDataFieldImpl :: _AnalyticsDataFieldImpl)
	end

	function _AnalyticsDataFieldImpl.encode(self: AnalyticsDataField): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _AnalyticsDataFieldImpl.decode(input: buffer): AnalyticsDataField
		local self = _AnalyticsDataFieldImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _AnalyticsDataFieldImpl.jsonEncode(self: AnalyticsDataField): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "literal" then
				output.literal = self.kind.value
			end
		end

		return output
	end

	function _AnalyticsDataFieldImpl.jsonDecode(input: { [string]: any }): AnalyticsDataField
		local self = _AnalyticsDataFieldImpl.new()

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		return self
	end

	_AnalyticsDataFieldImpl.descriptor = {
		name = "AnalyticsDataField",
		fullName = "roblox.apppageplatform.shared.v1beta1.AnalyticsDataField",
	}

	messages.AnalyticsDataField = _AnalyticsDataFieldImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.AnalyticsDataField)
end

return {
	AnalyticsDataField = messages.AnalyticsDataField,
}
