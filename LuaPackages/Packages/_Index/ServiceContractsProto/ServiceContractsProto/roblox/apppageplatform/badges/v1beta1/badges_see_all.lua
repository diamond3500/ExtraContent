--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require(script.Parent.Parent.Parent.Parent.Parent.proto)
local typeRegistry = require(script.Parent.Parent.Parent.Parent.Parent.proto.typeRegistry)

type _Messages = {
	BadgesSeeAllRequest: _BadgesSeeAllRequestMessage,
	Pagination: _PaginationMessage,
	BadgesGridPageEntry: _BadgesGridPageEntryMessage,
	BadgesGridPageEntry_BadgeInputData: _BadgesGridPageEntry_BadgeInputDataMessage,
	BadgesSeeAllPageEntry: _BadgesSeeAllPageEntryMessage,
	BadgesSeeAllResponse: _BadgesSeeAllResponseMessage,
	BadgesSeeAllResponse_TemplatesEntry: _BadgesSeeAllResponse_TemplatesEntryMessage,
}
local messages: _Messages = {} :: _Messages

local _roblox_apppageplatform_shared_v1beta1_hydration_content =
	require(script.Parent.Parent.Parent.shared.v1beta1.hydration_content)
local _roblox_apppageplatform_shared_v1beta1_template_entry =
	require(script.Parent.Parent.Parent.shared.v1beta1.template_entry)
local _roblox_apppageplatform_shared_v1beta1_page_entry = require(script.Parent.Parent.Parent.shared.v1beta1.page_entry)

type _BadgesSeeAllRequestImpl = {
	__index: _BadgesSeeAllRequestImpl,
	new: (fields: _BadgesSeeAllRequestPartialFields?) -> BadgesSeeAllRequest,
	encode: (self: BadgesSeeAllRequest) -> buffer,
	decode: (input: buffer) -> BadgesSeeAllRequest,
	jsonEncode: (self: BadgesSeeAllRequest) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> BadgesSeeAllRequest,
	descriptor: proto.Descriptor,
}

type _BadgesSeeAllRequestFields = {
	universe_id: number,
	user_id: number,
	page_size: number,
	cursor: string,
}

type _BadgesSeeAllRequestPartialFields = {
	universe_id: number?,
	user_id: number?,
	page_size: number?,
	cursor: string?,
}

export type BadgesSeeAllRequest = typeof(setmetatable({} :: _BadgesSeeAllRequestFields, {} :: _BadgesSeeAllRequestImpl))
type _BadgesSeeAllRequestMessage = proto.Message<BadgesSeeAllRequest, _BadgesSeeAllRequestPartialFields>

type _PaginationImpl = {
	__index: _PaginationImpl,
	new: (fields: _PaginationPartialFields?) -> Pagination,
	encode: (self: Pagination) -> buffer,
	decode: (input: buffer) -> Pagination,
	jsonEncode: (self: Pagination) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Pagination,
	descriptor: proto.Descriptor,
}

type _PaginationFields = {
	page_size: number,
	next_cursor: string,
	prev_cursor: string,
	total: number,
}

type _PaginationPartialFields = {
	page_size: number?,
	next_cursor: string?,
	prev_cursor: string?,
	total: number?,
}

export type Pagination = typeof(setmetatable({} :: _PaginationFields, {} :: _PaginationImpl))
type _PaginationMessage = proto.Message<Pagination, _PaginationPartialFields>

type _BadgesGridPageEntryImpl = {
	__index: _BadgesGridPageEntryImpl,
	new: (fields: _BadgesGridPageEntryPartialFields?) -> BadgesGridPageEntry,
	encode: (self: BadgesGridPageEntry) -> buffer,
	decode: (input: buffer) -> BadgesGridPageEntry,
	jsonEncode: (self: BadgesGridPageEntry) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> BadgesGridPageEntry,
	descriptor: proto.Descriptor,
}

type _BadgesGridPageEntryFields = {
	section_title: string,
	badges: { BadgesGridPageEntry_BadgeInputData },
	collection_id: string,
	collection_position: string,
}

type _BadgesGridPageEntryPartialFields = {
	section_title: string?,
	badges: { BadgesGridPageEntry_BadgeInputData }?,
	collection_id: string?,
	collection_position: string?,
}

export type BadgesGridPageEntry = typeof(setmetatable({} :: _BadgesGridPageEntryFields, {} :: _BadgesGridPageEntryImpl))
type _BadgesGridPageEntryMessage = proto.Message<BadgesGridPageEntry, _BadgesGridPageEntryPartialFields>

type _BadgesGridPageEntry_BadgeInputDataImpl = {
	__index: _BadgesGridPageEntry_BadgeInputDataImpl,
	new: (fields: _BadgesGridPageEntry_BadgeInputDataPartialFields?) -> BadgesGridPageEntry_BadgeInputData,
	encode: (self: BadgesGridPageEntry_BadgeInputData) -> buffer,
	decode: (input: buffer) -> BadgesGridPageEntry_BadgeInputData,
	jsonEncode: (self: BadgesGridPageEntry_BadgeInputData) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> BadgesGridPageEntry_BadgeInputData,
	descriptor: proto.Descriptor,
}

type _BadgesGridPageEntry_BadgeInputDataFields = {
	badge_id: string,
}

type _BadgesGridPageEntry_BadgeInputDataPartialFields = {
	badge_id: string?,
}

export type BadgesGridPageEntry_BadgeInputData = typeof(setmetatable(
	{} :: _BadgesGridPageEntry_BadgeInputDataFields,
	{} :: _BadgesGridPageEntry_BadgeInputDataImpl
))
type _BadgesGridPageEntry_BadgeInputDataMessage = proto.Message<
	BadgesGridPageEntry_BadgeInputData,
	_BadgesGridPageEntry_BadgeInputDataPartialFields
>

type _BadgesSeeAllPageEntryImpl = {
	__index: _BadgesSeeAllPageEntryImpl,
	new: (fields: _BadgesSeeAllPageEntryPartialFields?) -> BadgesSeeAllPageEntry,
	encode: (self: BadgesSeeAllPageEntry) -> buffer,
	decode: (input: buffer) -> BadgesSeeAllPageEntry,
	jsonEncode: (self: BadgesSeeAllPageEntry) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> BadgesSeeAllPageEntry,
	descriptor: proto.Descriptor,
}

type _BadgesSeeAllPageEntryFields = {
	page_entry: _roblox_apppageplatform_shared_v1beta1_page_entry.PageEntry?,
	kind: { type: "badges_grid", value: BadgesGridPageEntry }?,
}

type _BadgesSeeAllPageEntryPartialFields = {
	page_entry: _roblox_apppageplatform_shared_v1beta1_page_entry.PageEntry?,
	kind: { type: "badges_grid", value: BadgesGridPageEntry }?,
}

export type BadgesSeeAllPageEntry = typeof(setmetatable(
	{} :: _BadgesSeeAllPageEntryFields,
	{} :: _BadgesSeeAllPageEntryImpl
))
type _BadgesSeeAllPageEntryMessage = proto.Message<BadgesSeeAllPageEntry, _BadgesSeeAllPageEntryPartialFields>

type _BadgesSeeAllResponseImpl = {
	__index: _BadgesSeeAllResponseImpl,
	new: (fields: _BadgesSeeAllResponsePartialFields?) -> BadgesSeeAllResponse,
	encode: (self: BadgesSeeAllResponse) -> buffer,
	decode: (input: buffer) -> BadgesSeeAllResponse,
	jsonEncode: (self: BadgesSeeAllResponse) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> BadgesSeeAllResponse,
	descriptor: proto.Descriptor,
}

type _BadgesSeeAllResponseFields = {
	page_entries: { BadgesSeeAllPageEntry },
	hydration_data: _roblox_apppageplatform_shared_v1beta1_hydration_content.HydrationContent?,
	templates: { [string]: _roblox_apppageplatform_shared_v1beta1_template_entry.TemplateEntry },
	pagination: Pagination?,
}

type _BadgesSeeAllResponsePartialFields = {
	page_entries: { BadgesSeeAllPageEntry }?,
	hydration_data: _roblox_apppageplatform_shared_v1beta1_hydration_content.HydrationContent?,
	templates: { [string]: _roblox_apppageplatform_shared_v1beta1_template_entry.TemplateEntry }?,
	pagination: Pagination?,
}

export type BadgesSeeAllResponse = typeof(setmetatable(
	{} :: _BadgesSeeAllResponseFields,
	{} :: _BadgesSeeAllResponseImpl
))
type _BadgesSeeAllResponseMessage = proto.Message<BadgesSeeAllResponse, _BadgesSeeAllResponsePartialFields>

type _BadgesSeeAllResponse_TemplatesEntryImpl = {
	__index: _BadgesSeeAllResponse_TemplatesEntryImpl,
	new: (fields: _BadgesSeeAllResponse_TemplatesEntryPartialFields?) -> BadgesSeeAllResponse_TemplatesEntry,
	encode: (self: BadgesSeeAllResponse_TemplatesEntry) -> buffer,
	decode: (input: buffer) -> BadgesSeeAllResponse_TemplatesEntry,
	jsonEncode: (self: BadgesSeeAllResponse_TemplatesEntry) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> BadgesSeeAllResponse_TemplatesEntry,
	descriptor: proto.Descriptor,
}

type _BadgesSeeAllResponse_TemplatesEntryFields = {
	key: string,
	value: _roblox_apppageplatform_shared_v1beta1_template_entry.TemplateEntry?,
}

type _BadgesSeeAllResponse_TemplatesEntryPartialFields = {
	key: string?,
	value: _roblox_apppageplatform_shared_v1beta1_template_entry.TemplateEntry?,
}

export type BadgesSeeAllResponse_TemplatesEntry = typeof(setmetatable(
	{} :: _BadgesSeeAllResponse_TemplatesEntryFields,
	{} :: _BadgesSeeAllResponse_TemplatesEntryImpl
))
type _BadgesSeeAllResponse_TemplatesEntryMessage = proto.Message<
	BadgesSeeAllResponse_TemplatesEntry,
	_BadgesSeeAllResponse_TemplatesEntryPartialFields
>

do
	local _BadgesSeeAllRequestImpl = {}
	_BadgesSeeAllRequestImpl.__index = _BadgesSeeAllRequestImpl

	function _BadgesSeeAllRequestImpl.new(data: _BadgesSeeAllRequestPartialFields?): BadgesSeeAllRequest
		return setmetatable({
			universe_id = if data == nil or data.universe_id == nil then 0 else data.universe_id,
			user_id = if data == nil or data.user_id == nil then 0 else data.user_id,
			page_size = if data == nil or data.page_size == nil then 0 else data.page_size,
			cursor = if data == nil or data.cursor == nil then "" else data.cursor,
		}, _BadgesSeeAllRequestImpl :: _BadgesSeeAllRequestImpl)
	end

	function _BadgesSeeAllRequestImpl.encode(self: BadgesSeeAllRequest): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.universe_id ~= nil and self.universe_id ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.universe_id)
		end

		if self.user_id ~= nil and self.user_id ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.user_id)
		end

		if self.page_size ~= nil and self.page_size ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.page_size)
		end

		if self.cursor ~= nil and self.cursor ~= "" then
			output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.cursor)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _BadgesSeeAllRequestImpl.decode(input: buffer): BadgesSeeAllRequest
		local self = _BadgesSeeAllRequestImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI64(input, cursor)
					self.universe_id = value
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readVarIntI64(input, cursor)
					self.user_id = value
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.page_size = value
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.cursor = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _BadgesSeeAllRequestImpl.jsonEncode(self: BadgesSeeAllRequest): any
		local output = {}

		if self.universe_id ~= nil and self.universe_id ~= 0 then
			output.universeId = self.universe_id
		end

		if self.user_id ~= nil and self.user_id ~= 0 then
			output.userId = self.user_id
		end

		if self.page_size ~= nil and self.page_size ~= 0 then
			output.pageSize = self.page_size
		end

		if self.cursor ~= nil and self.cursor ~= "" then
			output.cursor = self.cursor
		end

		return output
	end

	function _BadgesSeeAllRequestImpl.jsonDecode(input: { [string]: any }): BadgesSeeAllRequest
		local self = _BadgesSeeAllRequestImpl.new()

		if input.universe_id ~= nil then
			self.universe_id = input.universe_id
		end

		if input.universeId ~= nil then
			self.universe_id = input.universeId
		end

		if input.user_id ~= nil then
			self.user_id = input.user_id
		end

		if input.userId ~= nil then
			self.user_id = input.userId
		end

		if input.page_size ~= nil then
			self.page_size = input.page_size
		end

		if input.pageSize ~= nil then
			self.page_size = input.pageSize
		end

		if input.cursor ~= nil then
			self.cursor = input.cursor
		end

		return self
	end

	_BadgesSeeAllRequestImpl.descriptor = {
		name = "BadgesSeeAllRequest",
		fullName = "roblox.apppageplatform.badges.v1beta1.BadgesSeeAllRequest",
	}

	messages.BadgesSeeAllRequest = _BadgesSeeAllRequestImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.BadgesSeeAllRequest)
end

do
	local _PaginationImpl = {}
	_PaginationImpl.__index = _PaginationImpl

	function _PaginationImpl.new(data: _PaginationPartialFields?): Pagination
		return setmetatable({
			page_size = if data == nil or data.page_size == nil then 0 else data.page_size,
			next_cursor = if data == nil or data.next_cursor == nil then "" else data.next_cursor,
			prev_cursor = if data == nil or data.prev_cursor == nil then "" else data.prev_cursor,
			total = if data == nil or data.total == nil then 0 else data.total,
		}, _PaginationImpl :: _PaginationImpl)
	end

	function _PaginationImpl.encode(self: Pagination): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.page_size ~= nil and self.page_size ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.page_size)
		end

		if self.next_cursor ~= nil and self.next_cursor ~= "" then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.next_cursor)
		end

		if self.prev_cursor ~= nil and self.prev_cursor ~= "" then
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.prev_cursor)
		end

		if self.total ~= nil and self.total ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.total)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _PaginationImpl.decode(input: buffer): Pagination
		local self = _PaginationImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.page_size = value
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readVarIntI64(input, cursor)
					self.total = value
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.next_cursor = buffer.tostring(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.prev_cursor = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _PaginationImpl.jsonEncode(self: Pagination): any
		local output = {}

		if self.page_size ~= nil and self.page_size ~= 0 then
			output.pageSize = self.page_size
		end

		if self.next_cursor ~= nil and self.next_cursor ~= "" then
			output.nextCursor = self.next_cursor
		end

		if self.prev_cursor ~= nil and self.prev_cursor ~= "" then
			output.prevCursor = self.prev_cursor
		end

		if self.total ~= nil and self.total ~= 0 then
			output.total = self.total
		end

		return output
	end

	function _PaginationImpl.jsonDecode(input: { [string]: any }): Pagination
		local self = _PaginationImpl.new()

		if input.page_size ~= nil then
			self.page_size = input.page_size
		end

		if input.pageSize ~= nil then
			self.page_size = input.pageSize
		end

		if input.next_cursor ~= nil then
			self.next_cursor = input.next_cursor
		end

		if input.nextCursor ~= nil then
			self.next_cursor = input.nextCursor
		end

		if input.prev_cursor ~= nil then
			self.prev_cursor = input.prev_cursor
		end

		if input.prevCursor ~= nil then
			self.prev_cursor = input.prevCursor
		end

		if input.total ~= nil then
			self.total = input.total
		end

		return self
	end

	_PaginationImpl.descriptor = {
		name = "Pagination",
		fullName = "roblox.apppageplatform.badges.v1beta1.Pagination",
	}

	messages.Pagination = _PaginationImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Pagination)
end

do
	local _BadgesGridPageEntryImpl = {}
	_BadgesGridPageEntryImpl.__index = _BadgesGridPageEntryImpl

	function _BadgesGridPageEntryImpl.new(data: _BadgesGridPageEntryPartialFields?): BadgesGridPageEntry
		return setmetatable({
			section_title = if data == nil or data.section_title == nil then "" else data.section_title,
			badges = if data == nil or data.badges == nil then {} else data.badges,
			collection_id = if data == nil or data.collection_id == nil then "" else data.collection_id,
			collection_position = if data == nil or data.collection_position == nil
				then ""
				else data.collection_position,
		}, _BadgesGridPageEntryImpl :: _BadgesGridPageEntryImpl)
	end

	function _BadgesGridPageEntryImpl.encode(self: BadgesGridPageEntry): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.section_title ~= nil and self.section_title ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.section_title)
		end

		if self.badges ~= nil and #self.badges > 0 then
			for _, value in self.badges do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		if self.collection_id ~= nil and self.collection_id ~= "" then
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.collection_id)
		end

		if self.collection_position ~= nil and self.collection_position ~= "" then
			output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.collection_position)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _BadgesGridPageEntryImpl.decode(input: buffer): BadgesGridPageEntry
		local self = _BadgesGridPageEntryImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.section_title = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.badges, messages.BadgesGridPageEntry_BadgeInputData.decode(value))
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.collection_id = buffer.tostring(value)
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.collection_position = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _BadgesGridPageEntryImpl.jsonEncode(self: BadgesGridPageEntry): any
		local output = {}

		if self.section_title ~= nil and self.section_title ~= "" then
			output.sectionTitle = self.section_title
		end

		if self.badges ~= nil and #self.badges > 0 then
			local newOutput = {}
			for _, value in self.badges do
				table.insert(newOutput, value:jsonEncode())
			end
			output.badges = newOutput
		end

		if self.collection_id ~= nil and self.collection_id ~= "" then
			output.collectionId = self.collection_id
		end

		if self.collection_position ~= nil and self.collection_position ~= "" then
			output.collectionPosition = self.collection_position
		end

		return output
	end

	function _BadgesGridPageEntryImpl.jsonDecode(input: { [string]: any }): BadgesGridPageEntry
		local self = _BadgesGridPageEntryImpl.new()

		if input.section_title ~= nil then
			self.section_title = input.section_title
		end

		if input.sectionTitle ~= nil then
			self.section_title = input.sectionTitle
		end

		if input.badges ~= nil then
			local newOutput: { BadgesGridPageEntry_BadgeInputData } = {}
			for _, value in input.badges do
				table.insert(newOutput, messages.BadgesGridPageEntry_BadgeInputData.jsonDecode(value))
			end

			self.badges = newOutput
		end

		if input.collection_id ~= nil then
			self.collection_id = input.collection_id
		end

		if input.collectionId ~= nil then
			self.collection_id = input.collectionId
		end

		if input.collection_position ~= nil then
			self.collection_position = input.collection_position
		end

		if input.collectionPosition ~= nil then
			self.collection_position = input.collectionPosition
		end

		return self
	end

	_BadgesGridPageEntryImpl.descriptor = {
		name = "BadgesGridPageEntry",
		fullName = "roblox.apppageplatform.badges.v1beta1.BadgesGridPageEntry",
	}

	messages.BadgesGridPageEntry = _BadgesGridPageEntryImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.BadgesGridPageEntry)
end

do
	local _BadgesGridPageEntry_BadgeInputDataImpl = {}
	_BadgesGridPageEntry_BadgeInputDataImpl.__index = _BadgesGridPageEntry_BadgeInputDataImpl

	function _BadgesGridPageEntry_BadgeInputDataImpl.new(
		data: _BadgesGridPageEntry_BadgeInputDataPartialFields?
	): BadgesGridPageEntry_BadgeInputData
		return setmetatable({
			badge_id = if data == nil or data.badge_id == nil then "" else data.badge_id,
		}, _BadgesGridPageEntry_BadgeInputDataImpl :: _BadgesGridPageEntry_BadgeInputDataImpl)
	end

	function _BadgesGridPageEntry_BadgeInputDataImpl.encode(self: BadgesGridPageEntry_BadgeInputData): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.badge_id ~= nil and self.badge_id ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.badge_id)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _BadgesGridPageEntry_BadgeInputDataImpl.decode(input: buffer): BadgesGridPageEntry_BadgeInputData
		local self = _BadgesGridPageEntry_BadgeInputDataImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.badge_id = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _BadgesGridPageEntry_BadgeInputDataImpl.jsonEncode(self: BadgesGridPageEntry_BadgeInputData): any
		local output = {}

		if self.badge_id ~= nil and self.badge_id ~= "" then
			output.badgeId = self.badge_id
		end

		return output
	end

	function _BadgesGridPageEntry_BadgeInputDataImpl.jsonDecode(
		input: { [string]: any }
	): BadgesGridPageEntry_BadgeInputData
		local self = _BadgesGridPageEntry_BadgeInputDataImpl.new()

		if input.badge_id ~= nil then
			self.badge_id = input.badge_id
		end

		if input.badgeId ~= nil then
			self.badge_id = input.badgeId
		end

		return self
	end

	_BadgesGridPageEntry_BadgeInputDataImpl.descriptor = {
		name = "BadgesGridPageEntry_BadgeInputData",
		fullName = "roblox.apppageplatform.badges.v1beta1.BadgeInputData",
	}

	messages.BadgesGridPageEntry_BadgeInputData = _BadgesGridPageEntry_BadgeInputDataImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.BadgesGridPageEntry_BadgeInputData)
end

do
	local _BadgesSeeAllPageEntryImpl = {}
	_BadgesSeeAllPageEntryImpl.__index = _BadgesSeeAllPageEntryImpl

	function _BadgesSeeAllPageEntryImpl.new(data: _BadgesSeeAllPageEntryPartialFields?): BadgesSeeAllPageEntry
		return setmetatable({
			page_entry = if data == nil or data.page_entry == nil then nil else data.page_entry,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _BadgesSeeAllPageEntryImpl :: _BadgesSeeAllPageEntryImpl)
	end

	function _BadgesSeeAllPageEntryImpl.encode(self: BadgesSeeAllPageEntry): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.page_entry ~= nil then
			local encoded = self.page_entry:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "badges_grid" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _BadgesSeeAllPageEntryImpl.decode(input: buffer): BadgesSeeAllPageEntry
		local self = _BadgesSeeAllPageEntryImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.page_entry = _roblox_apppageplatform_shared_v1beta1_page_entry.PageEntry.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "badges_grid", value = messages.BadgesGridPageEntry.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _BadgesSeeAllPageEntryImpl.jsonEncode(self: BadgesSeeAllPageEntry): any
		local output = {}

		if self.page_entry ~= nil then
			output.pageEntry = self.page_entry:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "badges_grid" then
				output.badgesGrid = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _BadgesSeeAllPageEntryImpl.jsonDecode(input: { [string]: any }): BadgesSeeAllPageEntry
		local self = _BadgesSeeAllPageEntryImpl.new()

		if input.page_entry ~= nil then
			self.page_entry = _roblox_apppageplatform_shared_v1beta1_page_entry.PageEntry.jsonDecode(input.page_entry)
		end

		if input.pageEntry ~= nil then
			self.page_entry = _roblox_apppageplatform_shared_v1beta1_page_entry.PageEntry.jsonDecode(input.pageEntry)
		end

		if input.badges_grid ~= nil then
			self.kind = { type = "badges_grid", value = messages.BadgesGridPageEntry.jsonDecode(input.badges_grid) }
		end

		if input.badgesGrid ~= nil then
			self.kind = { type = "badges_grid", value = messages.BadgesGridPageEntry.jsonDecode(input.badgesGrid) }
		end

		return self
	end

	_BadgesSeeAllPageEntryImpl.descriptor = {
		name = "BadgesSeeAllPageEntry",
		fullName = "roblox.apppageplatform.badges.v1beta1.BadgesSeeAllPageEntry",
	}

	messages.BadgesSeeAllPageEntry = _BadgesSeeAllPageEntryImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.BadgesSeeAllPageEntry)
end

do
	local _BadgesSeeAllResponseImpl = {}
	_BadgesSeeAllResponseImpl.__index = _BadgesSeeAllResponseImpl

	function _BadgesSeeAllResponseImpl.new(data: _BadgesSeeAllResponsePartialFields?): BadgesSeeAllResponse
		return setmetatable({
			page_entries = if data == nil or data.page_entries == nil then {} else data.page_entries,
			hydration_data = if data == nil or data.hydration_data == nil then nil else data.hydration_data,
			templates = if data == nil or data.templates == nil then {} else data.templates,
			pagination = if data == nil or data.pagination == nil then nil else data.pagination,
		}, _BadgesSeeAllResponseImpl :: _BadgesSeeAllResponseImpl)
	end

	function _BadgesSeeAllResponseImpl.encode(self: BadgesSeeAllResponse): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.page_entries ~= nil and #self.page_entries > 0 then
			for _, value in self.page_entries do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		if self.hydration_data ~= nil then
			local encoded = self.hydration_data:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.templates ~= nil and next(self.templates) ~= nil then
			for key, value in self.templates do
				local mapBuffer = buffer.create(0)
				local mapCursor = 0
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 1, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeString(mapBuffer, mapCursor, key)
				local encoded = value:encode()
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 2, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeBuffer(mapBuffer, mapCursor, encoded, buffer.len(encoded))
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, mapBuffer, mapCursor)
			end
		end

		if self.pagination ~= nil then
			local encoded = self.pagination:encode()
			output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _BadgesSeeAllResponseImpl.decode(input: buffer): BadgesSeeAllResponse
		local self = _BadgesSeeAllResponseImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.page_entries, messages.BadgesSeeAllPageEntry.decode(value))
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.hydration_data =
						_roblox_apppageplatform_shared_v1beta1_hydration_content.HydrationContent.decode(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)

					local mapEntry = messages.BadgesSeeAllResponse_TemplatesEntry.decode(value)

					local keyDefault = ""
					local valueDefault = _roblox_apppageplatform_shared_v1beta1_template_entry.TemplateEntry.new()

					self.templates[mapEntry.key or keyDefault] = mapEntry.value or valueDefault

					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.pagination = messages.Pagination.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _BadgesSeeAllResponseImpl.jsonEncode(self: BadgesSeeAllResponse): any
		local output = {}

		if self.page_entries ~= nil and #self.page_entries > 0 then
			local newOutput = {}
			for _, value in self.page_entries do
				table.insert(newOutput, value:jsonEncode())
			end
			output.pageEntries = newOutput
		end

		if self.hydration_data ~= nil then
			output.hydrationData = self.hydration_data:jsonEncode()
		end

		if self.templates ~= nil and next(self.templates) ~= nil then
			local newOutput = {}
			for key, value in self.templates do
				newOutput[key] = value:jsonEncode()
			end
			output.templates = newOutput
		end

		if self.pagination ~= nil then
			output.pagination = self.pagination:jsonEncode()
		end

		return output
	end

	function _BadgesSeeAllResponseImpl.jsonDecode(input: { [string]: any }): BadgesSeeAllResponse
		local self = _BadgesSeeAllResponseImpl.new()

		if input.page_entries ~= nil then
			local newOutput: { BadgesSeeAllPageEntry } = {}
			for _, value in input.page_entries do
				table.insert(newOutput, messages.BadgesSeeAllPageEntry.jsonDecode(value))
			end

			self.page_entries = newOutput
		end

		if input.pageEntries ~= nil then
			local newOutput: { BadgesSeeAllPageEntry } = {}
			for _, value in input.pageEntries do
				table.insert(newOutput, messages.BadgesSeeAllPageEntry.jsonDecode(value))
			end

			self.page_entries = newOutput
		end

		if input.hydration_data ~= nil then
			self.hydration_data = _roblox_apppageplatform_shared_v1beta1_hydration_content.HydrationContent.jsonDecode(
				input.hydration_data
			)
		end

		if input.hydrationData ~= nil then
			self.hydration_data = _roblox_apppageplatform_shared_v1beta1_hydration_content.HydrationContent.jsonDecode(
				input.hydrationData
			)
		end

		if input.templates ~= nil then
			local newOutput: { [string]: _roblox_apppageplatform_shared_v1beta1_template_entry.TemplateEntry } = {}
			for key, value in input.templates do
				newOutput[key] = _roblox_apppageplatform_shared_v1beta1_template_entry.TemplateEntry.jsonDecode(value)
			end

			self.templates = newOutput
		end

		if input.pagination ~= nil then
			self.pagination = messages.Pagination.jsonDecode(input.pagination)
		end

		return self
	end

	_BadgesSeeAllResponseImpl.descriptor = {
		name = "BadgesSeeAllResponse",
		fullName = "roblox.apppageplatform.badges.v1beta1.BadgesSeeAllResponse",
	}

	messages.BadgesSeeAllResponse = _BadgesSeeAllResponseImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.BadgesSeeAllResponse)
end

do
	local _BadgesSeeAllResponse_TemplatesEntryImpl = {}
	_BadgesSeeAllResponse_TemplatesEntryImpl.__index = _BadgesSeeAllResponse_TemplatesEntryImpl

	function _BadgesSeeAllResponse_TemplatesEntryImpl.new(
		data: _BadgesSeeAllResponse_TemplatesEntryPartialFields?
	): BadgesSeeAllResponse_TemplatesEntry
		return setmetatable({
			key = if data == nil or data.key == nil then "" else data.key,
			value = if data == nil or data.value == nil then nil else data.value,
		}, _BadgesSeeAllResponse_TemplatesEntryImpl :: _BadgesSeeAllResponse_TemplatesEntryImpl)
	end

	function _BadgesSeeAllResponse_TemplatesEntryImpl.encode(self: BadgesSeeAllResponse_TemplatesEntry): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.key ~= nil and self.key ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.key)
		end

		if self.value ~= nil then
			local encoded = self.value:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _BadgesSeeAllResponse_TemplatesEntryImpl.decode(input: buffer): BadgesSeeAllResponse_TemplatesEntry
		local self = _BadgesSeeAllResponse_TemplatesEntryImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.key = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = _roblox_apppageplatform_shared_v1beta1_template_entry.TemplateEntry.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _BadgesSeeAllResponse_TemplatesEntryImpl.jsonEncode(self: BadgesSeeAllResponse_TemplatesEntry): any
		local output = {}

		if self.key ~= nil and self.key ~= "" then
			output.key = self.key
		end

		if self.value ~= nil then
			output.value = self.value:jsonEncode()
		end

		return output
	end

	function _BadgesSeeAllResponse_TemplatesEntryImpl.jsonDecode(
		input: { [string]: any }
	): BadgesSeeAllResponse_TemplatesEntry
		local self = _BadgesSeeAllResponse_TemplatesEntryImpl.new()

		if input.key ~= nil then
			self.key = input.key
		end

		if input.value ~= nil then
			self.value = _roblox_apppageplatform_shared_v1beta1_template_entry.TemplateEntry.jsonDecode(input.value)
		end

		return self
	end

	_BadgesSeeAllResponse_TemplatesEntryImpl.descriptor = {
		name = "BadgesSeeAllResponse_TemplatesEntry",
		fullName = "roblox.apppageplatform.badges.v1beta1.TemplatesEntry",
	}

	messages.BadgesSeeAllResponse_TemplatesEntry = _BadgesSeeAllResponse_TemplatesEntryImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.BadgesSeeAllResponse_TemplatesEntry)
end

return {
	BadgesSeeAllRequest = messages.BadgesSeeAllRequest,
	Pagination = messages.Pagination,
	BadgesGridPageEntry = messages.BadgesGridPageEntry,
	BadgesGridPageEntry_BadgeInputData = messages.BadgesGridPageEntry_BadgeInputData,
	BadgesSeeAllPageEntry = messages.BadgesSeeAllPageEntry,
	BadgesSeeAllResponse = messages.BadgesSeeAllResponse,
}
