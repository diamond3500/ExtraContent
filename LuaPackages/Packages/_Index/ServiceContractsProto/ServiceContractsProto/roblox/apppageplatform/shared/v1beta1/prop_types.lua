--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require(script.Parent.Parent.Parent.Parent.Parent.proto)
local typeRegistry = require(script.Parent.Parent.Parent.Parent.Parent.proto.typeRegistry)

type _Messages = {
	StringFormat: _StringFormatMessage,
	StringFormat_FormatArg: _StringFormat_FormatArgMessage,
	StringFormat_ArgsEntry: _StringFormat_ArgsEntryMessage,
	StringProp: _StringPropMessage,
	StringProp_ConditionalOption: _StringProp_ConditionalOptionMessage,
	StringProp_ConditionalOptions: _StringProp_ConditionalOptionsMessage,
	FloatProp: _FloatPropMessage,
	FloatProp_ConditionalOption: _FloatProp_ConditionalOptionMessage,
	FloatProp_ConditionalOptions: _FloatProp_ConditionalOptionsMessage,
	DoubleProp: _DoublePropMessage,
	DoubleProp_ConditionalOption: _DoubleProp_ConditionalOptionMessage,
	DoubleProp_ConditionalOptions: _DoubleProp_ConditionalOptionsMessage,
	Int32Prop: _Int32PropMessage,
	Int32Prop_ConditionalOption: _Int32Prop_ConditionalOptionMessage,
	Int32Prop_ConditionalOptions: _Int32Prop_ConditionalOptionsMessage,
	Int64Prop: _Int64PropMessage,
	Int64Prop_ConditionalOption: _Int64Prop_ConditionalOptionMessage,
	Int64Prop_ConditionalOptions: _Int64Prop_ConditionalOptionsMessage,
	BoolProp: _BoolPropMessage,
	BoolProp_ConditionalOption: _BoolProp_ConditionalOptionMessage,
	BoolProp_ConditionalOptions: _BoolProp_ConditionalOptionsMessage,
	StructProp: _StructPropMessage,
	StructProp_ConditionalOption: _StructProp_ConditionalOptionMessage,
	StructProp_ConditionalOptions: _StructProp_ConditionalOptionsMessage,
	ImageStringProp: _ImageStringPropMessage,
	ImageStringProp_ConditionalOption: _ImageStringProp_ConditionalOptionMessage,
	ImageStringProp_ConditionalOptions: _ImageStringProp_ConditionalOptionsMessage,
	ImageSetProp: _ImageSetPropMessage,
	ImageSetProp_ConditionalOption: _ImageSetProp_ConditionalOptionMessage,
	ImageSetProp_ConditionalOptions: _ImageSetProp_ConditionalOptionsMessage,
	ColorProp: _ColorPropMessage,
	ColorProp_ConditionalOption: _ColorProp_ConditionalOptionMessage,
	ColorProp_ConditionalOptions: _ColorProp_ConditionalOptionsMessage,
	TypographyProp: _TypographyPropMessage,
	TypographyProp_ConditionalOption: _TypographyProp_ConditionalOptionMessage,
	TypographyProp_ConditionalOptions: _TypographyProp_ConditionalOptionsMessage,
	TypographyFontProp: _TypographyFontPropMessage,
	TypographyFontProp_ConditionalOption: _TypographyFontProp_ConditionalOptionMessage,
	TypographyFontProp_ConditionalOptions: _TypographyFontProp_ConditionalOptionsMessage,
	UDimProp: _UDimPropMessage,
	UDimProp_ConditionalOption: _UDimProp_ConditionalOptionMessage,
	UDimProp_ConditionalOptions: _UDimProp_ConditionalOptionsMessage,
	UDim2Prop: _UDim2PropMessage,
	UDim2Prop_ConditionalOption: _UDim2Prop_ConditionalOptionMessage,
	UDim2Prop_ConditionalOptions: _UDim2Prop_ConditionalOptionsMessage,
	Vector2Prop: _Vector2PropMessage,
	Vector2Prop_ConditionalOption: _Vector2Prop_ConditionalOptionMessage,
	Vector2Prop_ConditionalOptions: _Vector2Prop_ConditionalOptionsMessage,
	TemplateArg: _TemplateArgMessage,
	TemplateArg_LiteralValue: _TemplateArg_LiteralValueMessage,
	NestedComponentProp: _NestedComponentPropMessage,
	NestedComponentProp_ConditionalOption: _NestedComponentProp_ConditionalOptionMessage,
	NestedComponentProp_ConditionalOptions: _NestedComponentProp_ConditionalOptionsMessage,
	NestedComponentProp_TemplateData: _NestedComponentProp_TemplateDataMessage,
	NestedComponentProp_TemplateData_InputsEntry: _NestedComponentProp_TemplateData_InputsEntryMessage,
	LazyNestedComponentListProp: _LazyNestedComponentListPropMessage,
	LazyNestedComponentListProp_ConditionalOption: _LazyNestedComponentListProp_ConditionalOptionMessage,
	LazyNestedComponentListProp_ConditionalOptions: _LazyNestedComponentListProp_ConditionalOptionsMessage,
	LazyNestedComponentListProp_TemplateData: _LazyNestedComponentListProp_TemplateDataMessage,
	LazyNestedComponentListProp_TemplateData_InputsEntry: _LazyNestedComponentListProp_TemplateData_InputsEntryMessage,
	LazyNestedComponentListProp_TemplateDataList: _LazyNestedComponentListProp_TemplateDataListMessage,
	IconProp: _IconPropMessage,
	IconProp_ConditionalOption: _IconProp_ConditionalOptionMessage,
	IconProp_ConditionalOptions: _IconProp_ConditionalOptionsMessage,
	GradientProp: _GradientPropMessage,
	GradientProp_ConditionalOption: _GradientProp_ConditionalOptionMessage,
	GradientProp_ConditionalOptions: _GradientProp_ConditionalOptionsMessage,
	GradientProp_GradientData: _GradientProp_GradientDataMessage,
	ArrayOfStructProp: _ArrayOfStructPropMessage,
	ArrayOfStructProp_ConditionalOption: _ArrayOfStructProp_ConditionalOptionMessage,
	ArrayOfStructProp_ConditionalOptions: _ArrayOfStructProp_ConditionalOptionsMessage,
	ArrayOfStructProp_ArrayOfStructs: _ArrayOfStructProp_ArrayOfStructsMessage,
}
local messages: _Messages = {} :: _Messages

local _google_protobuf_struct = require(script.Parent.Parent.Parent.Parent.Parent.google.protobuf.struct)
local _roblox_apppageplatform_shared_v1beta1_prop_condition = require(script.Parent.prop_condition)
local _roblox_apppageplatform_shared_v1beta1_roblox_component_type = require(script.Parent.roblox_component_type)

type _StringFormatImpl = {
	__index: _StringFormatImpl,
	new: (fields: _StringFormatPartialFields?) -> StringFormat,
	encode: (self: StringFormat) -> buffer,
	decode: (input: buffer) -> StringFormat,
	jsonEncode: (self: StringFormat) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> StringFormat,
	descriptor: proto.Descriptor,
}

type _StringFormatFields = {
	str: string,
	args: { [string]: StringFormat_FormatArg },
}

type _StringFormatPartialFields = {
	str: string?,
	args: { [string]: StringFormat_FormatArg }?,
}

export type StringFormat = typeof(setmetatable({} :: _StringFormatFields, {} :: _StringFormatImpl))
type _StringFormatMessage = proto.Message<StringFormat, _StringFormatPartialFields>

type _StringFormat_FormatArgImpl = {
	__index: _StringFormat_FormatArgImpl,
	new: (fields: _StringFormat_FormatArgPartialFields?) -> StringFormat_FormatArg,
	encode: (self: StringFormat_FormatArg) -> buffer,
	decode: (input: buffer) -> StringFormat_FormatArg,
	jsonEncode: (self: StringFormat_FormatArg) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> StringFormat_FormatArg,
	descriptor: proto.Descriptor,
}

type _StringFormat_FormatArgFields = {
	kind: ({ type: "literal", value: string } | { type: "binding_path", value: string })?,
}

type _StringFormat_FormatArgPartialFields = {
	kind: ({ type: "literal", value: string } | { type: "binding_path", value: string })?,
}

export type StringFormat_FormatArg = typeof(setmetatable(
	{} :: _StringFormat_FormatArgFields,
	{} :: _StringFormat_FormatArgImpl
))
type _StringFormat_FormatArgMessage = proto.Message<StringFormat_FormatArg, _StringFormat_FormatArgPartialFields>

type _StringFormat_ArgsEntryImpl = {
	__index: _StringFormat_ArgsEntryImpl,
	new: (fields: _StringFormat_ArgsEntryPartialFields?) -> StringFormat_ArgsEntry,
	encode: (self: StringFormat_ArgsEntry) -> buffer,
	decode: (input: buffer) -> StringFormat_ArgsEntry,
	jsonEncode: (self: StringFormat_ArgsEntry) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> StringFormat_ArgsEntry,
	descriptor: proto.Descriptor,
}

type _StringFormat_ArgsEntryFields = {
	key: string,
	value: StringFormat_FormatArg?,
}

type _StringFormat_ArgsEntryPartialFields = {
	key: string?,
	value: StringFormat_FormatArg?,
}

export type StringFormat_ArgsEntry = typeof(setmetatable(
	{} :: _StringFormat_ArgsEntryFields,
	{} :: _StringFormat_ArgsEntryImpl
))
type _StringFormat_ArgsEntryMessage = proto.Message<StringFormat_ArgsEntry, _StringFormat_ArgsEntryPartialFields>

type _StringPropImpl = {
	__index: _StringPropImpl,
	new: (fields: _StringPropPartialFields?) -> StringProp,
	encode: (self: StringProp) -> buffer,
	decode: (input: buffer) -> StringProp,
	jsonEncode: (self: StringProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> StringProp,
	descriptor: proto.Descriptor,
}

type _StringPropFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "binding_path", value: string }
		| { type: "token", value: string }
		| { type: "format", value: StringFormat }
		| { type: "conditional", value: StringProp_ConditionalOptions }
	)?,
}

type _StringPropPartialFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "binding_path", value: string }
		| { type: "token", value: string }
		| { type: "format", value: StringFormat }
		| { type: "conditional", value: StringProp_ConditionalOptions }
	)?,
}

export type StringProp = typeof(setmetatable({} :: _StringPropFields, {} :: _StringPropImpl))
type _StringPropMessage = proto.Message<StringProp, _StringPropPartialFields>

type _StringProp_ConditionalOptionImpl = {
	__index: _StringProp_ConditionalOptionImpl,
	new: (fields: _StringProp_ConditionalOptionPartialFields?) -> StringProp_ConditionalOption,
	encode: (self: StringProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> StringProp_ConditionalOption,
	jsonEncode: (self: StringProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> StringProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _StringProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: string }
		| { type: "binding_path", value: string }
		| { type: "token", value: string }
		| { type: "format", value: StringFormat }
	)?,
}

type _StringProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: string }
		| { type: "binding_path", value: string }
		| { type: "token", value: string }
		| { type: "format", value: StringFormat }
	)?,
}

export type StringProp_ConditionalOption = typeof(setmetatable(
	{} :: _StringProp_ConditionalOptionFields,
	{} :: _StringProp_ConditionalOptionImpl
))
type _StringProp_ConditionalOptionMessage = proto.Message<
	StringProp_ConditionalOption,
	_StringProp_ConditionalOptionPartialFields
>

type _StringProp_ConditionalOptionsImpl = {
	__index: _StringProp_ConditionalOptionsImpl,
	new: (fields: _StringProp_ConditionalOptionsPartialFields?) -> StringProp_ConditionalOptions,
	encode: (self: StringProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> StringProp_ConditionalOptions,
	jsonEncode: (self: StringProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> StringProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _StringProp_ConditionalOptionsFields = {
	option: { StringProp_ConditionalOption },
}

type _StringProp_ConditionalOptionsPartialFields = {
	option: { StringProp_ConditionalOption }?,
}

export type StringProp_ConditionalOptions = typeof(setmetatable(
	{} :: _StringProp_ConditionalOptionsFields,
	{} :: _StringProp_ConditionalOptionsImpl
))
type _StringProp_ConditionalOptionsMessage = proto.Message<
	StringProp_ConditionalOptions,
	_StringProp_ConditionalOptionsPartialFields
>

type _FloatPropImpl = {
	__index: _FloatPropImpl,
	new: (fields: _FloatPropPartialFields?) -> FloatProp,
	encode: (self: FloatProp) -> buffer,
	decode: (input: buffer) -> FloatProp,
	jsonEncode: (self: FloatProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> FloatProp,
	descriptor: proto.Descriptor,
}

type _FloatPropFields = {
	kind: (
		{ type: "literal", value: number }
		| { type: "binding_path", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: FloatProp_ConditionalOptions }
	)?,
}

type _FloatPropPartialFields = {
	kind: (
		{ type: "literal", value: number }
		| { type: "binding_path", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: FloatProp_ConditionalOptions }
	)?,
}

export type FloatProp = typeof(setmetatable({} :: _FloatPropFields, {} :: _FloatPropImpl))
type _FloatPropMessage = proto.Message<FloatProp, _FloatPropPartialFields>

type _FloatProp_ConditionalOptionImpl = {
	__index: _FloatProp_ConditionalOptionImpl,
	new: (fields: _FloatProp_ConditionalOptionPartialFields?) -> FloatProp_ConditionalOption,
	encode: (self: FloatProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> FloatProp_ConditionalOption,
	jsonEncode: (self: FloatProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> FloatProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _FloatProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: number } | { type: "binding_path", value: string } | { type: "token", value: string }
	)?,
}

type _FloatProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: number } | { type: "binding_path", value: string } | { type: "token", value: string }
	)?,
}

export type FloatProp_ConditionalOption = typeof(setmetatable(
	{} :: _FloatProp_ConditionalOptionFields,
	{} :: _FloatProp_ConditionalOptionImpl
))
type _FloatProp_ConditionalOptionMessage = proto.Message<
	FloatProp_ConditionalOption,
	_FloatProp_ConditionalOptionPartialFields
>

type _FloatProp_ConditionalOptionsImpl = {
	__index: _FloatProp_ConditionalOptionsImpl,
	new: (fields: _FloatProp_ConditionalOptionsPartialFields?) -> FloatProp_ConditionalOptions,
	encode: (self: FloatProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> FloatProp_ConditionalOptions,
	jsonEncode: (self: FloatProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> FloatProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _FloatProp_ConditionalOptionsFields = {
	option: { FloatProp_ConditionalOption },
}

type _FloatProp_ConditionalOptionsPartialFields = {
	option: { FloatProp_ConditionalOption }?,
}

export type FloatProp_ConditionalOptions = typeof(setmetatable(
	{} :: _FloatProp_ConditionalOptionsFields,
	{} :: _FloatProp_ConditionalOptionsImpl
))
type _FloatProp_ConditionalOptionsMessage = proto.Message<
	FloatProp_ConditionalOptions,
	_FloatProp_ConditionalOptionsPartialFields
>

type _DoublePropImpl = {
	__index: _DoublePropImpl,
	new: (fields: _DoublePropPartialFields?) -> DoubleProp,
	encode: (self: DoubleProp) -> buffer,
	decode: (input: buffer) -> DoubleProp,
	jsonEncode: (self: DoubleProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> DoubleProp,
	descriptor: proto.Descriptor,
}

type _DoublePropFields = {
	kind: (
		{ type: "literal", value: number }
		| { type: "binding_path", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: DoubleProp_ConditionalOptions }
	)?,
}

type _DoublePropPartialFields = {
	kind: (
		{ type: "literal", value: number }
		| { type: "binding_path", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: DoubleProp_ConditionalOptions }
	)?,
}

export type DoubleProp = typeof(setmetatable({} :: _DoublePropFields, {} :: _DoublePropImpl))
type _DoublePropMessage = proto.Message<DoubleProp, _DoublePropPartialFields>

type _DoubleProp_ConditionalOptionImpl = {
	__index: _DoubleProp_ConditionalOptionImpl,
	new: (fields: _DoubleProp_ConditionalOptionPartialFields?) -> DoubleProp_ConditionalOption,
	encode: (self: DoubleProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> DoubleProp_ConditionalOption,
	jsonEncode: (self: DoubleProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> DoubleProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _DoubleProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: number } | { type: "binding_path", value: string } | { type: "token", value: string }
	)?,
}

type _DoubleProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: number } | { type: "binding_path", value: string } | { type: "token", value: string }
	)?,
}

export type DoubleProp_ConditionalOption = typeof(setmetatable(
	{} :: _DoubleProp_ConditionalOptionFields,
	{} :: _DoubleProp_ConditionalOptionImpl
))
type _DoubleProp_ConditionalOptionMessage = proto.Message<
	DoubleProp_ConditionalOption,
	_DoubleProp_ConditionalOptionPartialFields
>

type _DoubleProp_ConditionalOptionsImpl = {
	__index: _DoubleProp_ConditionalOptionsImpl,
	new: (fields: _DoubleProp_ConditionalOptionsPartialFields?) -> DoubleProp_ConditionalOptions,
	encode: (self: DoubleProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> DoubleProp_ConditionalOptions,
	jsonEncode: (self: DoubleProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> DoubleProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _DoubleProp_ConditionalOptionsFields = {
	option: { DoubleProp_ConditionalOption },
}

type _DoubleProp_ConditionalOptionsPartialFields = {
	option: { DoubleProp_ConditionalOption }?,
}

export type DoubleProp_ConditionalOptions = typeof(setmetatable(
	{} :: _DoubleProp_ConditionalOptionsFields,
	{} :: _DoubleProp_ConditionalOptionsImpl
))
type _DoubleProp_ConditionalOptionsMessage = proto.Message<
	DoubleProp_ConditionalOptions,
	_DoubleProp_ConditionalOptionsPartialFields
>

type _Int32PropImpl = {
	__index: _Int32PropImpl,
	new: (fields: _Int32PropPartialFields?) -> Int32Prop,
	encode: (self: Int32Prop) -> buffer,
	decode: (input: buffer) -> Int32Prop,
	jsonEncode: (self: Int32Prop) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Int32Prop,
	descriptor: proto.Descriptor,
}

type _Int32PropFields = {
	kind: (
		{ type: "literal", value: number }
		| { type: "binding_path", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: Int32Prop_ConditionalOptions }
	)?,
}

type _Int32PropPartialFields = {
	kind: (
		{ type: "literal", value: number }
		| { type: "binding_path", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: Int32Prop_ConditionalOptions }
	)?,
}

export type Int32Prop = typeof(setmetatable({} :: _Int32PropFields, {} :: _Int32PropImpl))
type _Int32PropMessage = proto.Message<Int32Prop, _Int32PropPartialFields>

type _Int32Prop_ConditionalOptionImpl = {
	__index: _Int32Prop_ConditionalOptionImpl,
	new: (fields: _Int32Prop_ConditionalOptionPartialFields?) -> Int32Prop_ConditionalOption,
	encode: (self: Int32Prop_ConditionalOption) -> buffer,
	decode: (input: buffer) -> Int32Prop_ConditionalOption,
	jsonEncode: (self: Int32Prop_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Int32Prop_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _Int32Prop_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: number } | { type: "binding_path", value: string } | { type: "token", value: string }
	)?,
}

type _Int32Prop_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: number } | { type: "binding_path", value: string } | { type: "token", value: string }
	)?,
}

export type Int32Prop_ConditionalOption = typeof(setmetatable(
	{} :: _Int32Prop_ConditionalOptionFields,
	{} :: _Int32Prop_ConditionalOptionImpl
))
type _Int32Prop_ConditionalOptionMessage = proto.Message<
	Int32Prop_ConditionalOption,
	_Int32Prop_ConditionalOptionPartialFields
>

type _Int32Prop_ConditionalOptionsImpl = {
	__index: _Int32Prop_ConditionalOptionsImpl,
	new: (fields: _Int32Prop_ConditionalOptionsPartialFields?) -> Int32Prop_ConditionalOptions,
	encode: (self: Int32Prop_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> Int32Prop_ConditionalOptions,
	jsonEncode: (self: Int32Prop_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Int32Prop_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _Int32Prop_ConditionalOptionsFields = {
	option: { Int32Prop_ConditionalOption },
}

type _Int32Prop_ConditionalOptionsPartialFields = {
	option: { Int32Prop_ConditionalOption }?,
}

export type Int32Prop_ConditionalOptions = typeof(setmetatable(
	{} :: _Int32Prop_ConditionalOptionsFields,
	{} :: _Int32Prop_ConditionalOptionsImpl
))
type _Int32Prop_ConditionalOptionsMessage = proto.Message<
	Int32Prop_ConditionalOptions,
	_Int32Prop_ConditionalOptionsPartialFields
>

type _Int64PropImpl = {
	__index: _Int64PropImpl,
	new: (fields: _Int64PropPartialFields?) -> Int64Prop,
	encode: (self: Int64Prop) -> buffer,
	decode: (input: buffer) -> Int64Prop,
	jsonEncode: (self: Int64Prop) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Int64Prop,
	descriptor: proto.Descriptor,
}

type _Int64PropFields = {
	kind: (
		{ type: "literal", value: number }
		| { type: "binding_path", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: Int64Prop_ConditionalOptions }
	)?,
}

type _Int64PropPartialFields = {
	kind: (
		{ type: "literal", value: number }
		| { type: "binding_path", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: Int64Prop_ConditionalOptions }
	)?,
}

export type Int64Prop = typeof(setmetatable({} :: _Int64PropFields, {} :: _Int64PropImpl))
type _Int64PropMessage = proto.Message<Int64Prop, _Int64PropPartialFields>

type _Int64Prop_ConditionalOptionImpl = {
	__index: _Int64Prop_ConditionalOptionImpl,
	new: (fields: _Int64Prop_ConditionalOptionPartialFields?) -> Int64Prop_ConditionalOption,
	encode: (self: Int64Prop_ConditionalOption) -> buffer,
	decode: (input: buffer) -> Int64Prop_ConditionalOption,
	jsonEncode: (self: Int64Prop_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Int64Prop_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _Int64Prop_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: number } | { type: "binding_path", value: string } | { type: "token", value: string }
	)?,
}

type _Int64Prop_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: number } | { type: "binding_path", value: string } | { type: "token", value: string }
	)?,
}

export type Int64Prop_ConditionalOption = typeof(setmetatable(
	{} :: _Int64Prop_ConditionalOptionFields,
	{} :: _Int64Prop_ConditionalOptionImpl
))
type _Int64Prop_ConditionalOptionMessage = proto.Message<
	Int64Prop_ConditionalOption,
	_Int64Prop_ConditionalOptionPartialFields
>

type _Int64Prop_ConditionalOptionsImpl = {
	__index: _Int64Prop_ConditionalOptionsImpl,
	new: (fields: _Int64Prop_ConditionalOptionsPartialFields?) -> Int64Prop_ConditionalOptions,
	encode: (self: Int64Prop_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> Int64Prop_ConditionalOptions,
	jsonEncode: (self: Int64Prop_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Int64Prop_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _Int64Prop_ConditionalOptionsFields = {
	option: { Int64Prop_ConditionalOption },
}

type _Int64Prop_ConditionalOptionsPartialFields = {
	option: { Int64Prop_ConditionalOption }?,
}

export type Int64Prop_ConditionalOptions = typeof(setmetatable(
	{} :: _Int64Prop_ConditionalOptionsFields,
	{} :: _Int64Prop_ConditionalOptionsImpl
))
type _Int64Prop_ConditionalOptionsMessage = proto.Message<
	Int64Prop_ConditionalOptions,
	_Int64Prop_ConditionalOptionsPartialFields
>

type _BoolPropImpl = {
	__index: _BoolPropImpl,
	new: (fields: _BoolPropPartialFields?) -> BoolProp,
	encode: (self: BoolProp) -> buffer,
	decode: (input: buffer) -> BoolProp,
	jsonEncode: (self: BoolProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> BoolProp,
	descriptor: proto.Descriptor,
}

type _BoolPropFields = {
	kind: (
		{ type: "literal", value: boolean }
		| { type: "binding_path", value: string }
		| { type: "conditional", value: BoolProp_ConditionalOptions }
	)?,
}

type _BoolPropPartialFields = {
	kind: (
		{ type: "literal", value: boolean }
		| { type: "binding_path", value: string }
		| { type: "conditional", value: BoolProp_ConditionalOptions }
	)?,
}

export type BoolProp = typeof(setmetatable({} :: _BoolPropFields, {} :: _BoolPropImpl))
type _BoolPropMessage = proto.Message<BoolProp, _BoolPropPartialFields>

type _BoolProp_ConditionalOptionImpl = {
	__index: _BoolProp_ConditionalOptionImpl,
	new: (fields: _BoolProp_ConditionalOptionPartialFields?) -> BoolProp_ConditionalOption,
	encode: (self: BoolProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> BoolProp_ConditionalOption,
	jsonEncode: (self: BoolProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> BoolProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _BoolProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "literal", value: boolean } | { type: "binding_path", value: string })?,
}

type _BoolProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "literal", value: boolean } | { type: "binding_path", value: string })?,
}

export type BoolProp_ConditionalOption = typeof(setmetatable(
	{} :: _BoolProp_ConditionalOptionFields,
	{} :: _BoolProp_ConditionalOptionImpl
))
type _BoolProp_ConditionalOptionMessage = proto.Message<
	BoolProp_ConditionalOption,
	_BoolProp_ConditionalOptionPartialFields
>

type _BoolProp_ConditionalOptionsImpl = {
	__index: _BoolProp_ConditionalOptionsImpl,
	new: (fields: _BoolProp_ConditionalOptionsPartialFields?) -> BoolProp_ConditionalOptions,
	encode: (self: BoolProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> BoolProp_ConditionalOptions,
	jsonEncode: (self: BoolProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> BoolProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _BoolProp_ConditionalOptionsFields = {
	option: { BoolProp_ConditionalOption },
}

type _BoolProp_ConditionalOptionsPartialFields = {
	option: { BoolProp_ConditionalOption }?,
}

export type BoolProp_ConditionalOptions = typeof(setmetatable(
	{} :: _BoolProp_ConditionalOptionsFields,
	{} :: _BoolProp_ConditionalOptionsImpl
))
type _BoolProp_ConditionalOptionsMessage = proto.Message<
	BoolProp_ConditionalOptions,
	_BoolProp_ConditionalOptionsPartialFields
>

type _StructPropImpl = {
	__index: _StructPropImpl,
	new: (fields: _StructPropPartialFields?) -> StructProp,
	encode: (self: StructProp) -> buffer,
	decode: (input: buffer) -> StructProp,
	jsonEncode: (self: StructProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> StructProp,
	descriptor: proto.Descriptor,
}

type _StructPropFields = {
	kind: (
		{ type: "literal", value: _google_protobuf_struct.Struct }
		| { type: "binding_path", value: string }
		| { type: "conditional", value: StructProp_ConditionalOptions }
	)?,
}

type _StructPropPartialFields = {
	kind: (
		{ type: "literal", value: _google_protobuf_struct.Struct }
		| { type: "binding_path", value: string }
		| { type: "conditional", value: StructProp_ConditionalOptions }
	)?,
}

export type StructProp = typeof(setmetatable({} :: _StructPropFields, {} :: _StructPropImpl))
type _StructPropMessage = proto.Message<StructProp, _StructPropPartialFields>

type _StructProp_ConditionalOptionImpl = {
	__index: _StructProp_ConditionalOptionImpl,
	new: (fields: _StructProp_ConditionalOptionPartialFields?) -> StructProp_ConditionalOption,
	encode: (self: StructProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> StructProp_ConditionalOption,
	jsonEncode: (self: StructProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> StructProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _StructProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "literal", value: _google_protobuf_struct.Struct } | { type: "binding_path", value: string })?,
}

type _StructProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "literal", value: _google_protobuf_struct.Struct } | { type: "binding_path", value: string })?,
}

export type StructProp_ConditionalOption = typeof(setmetatable(
	{} :: _StructProp_ConditionalOptionFields,
	{} :: _StructProp_ConditionalOptionImpl
))
type _StructProp_ConditionalOptionMessage = proto.Message<
	StructProp_ConditionalOption,
	_StructProp_ConditionalOptionPartialFields
>

type _StructProp_ConditionalOptionsImpl = {
	__index: _StructProp_ConditionalOptionsImpl,
	new: (fields: _StructProp_ConditionalOptionsPartialFields?) -> StructProp_ConditionalOptions,
	encode: (self: StructProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> StructProp_ConditionalOptions,
	jsonEncode: (self: StructProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> StructProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _StructProp_ConditionalOptionsFields = {
	option: { StructProp_ConditionalOption },
}

type _StructProp_ConditionalOptionsPartialFields = {
	option: { StructProp_ConditionalOption }?,
}

export type StructProp_ConditionalOptions = typeof(setmetatable(
	{} :: _StructProp_ConditionalOptionsFields,
	{} :: _StructProp_ConditionalOptionsImpl
))
type _StructProp_ConditionalOptionsMessage = proto.Message<
	StructProp_ConditionalOptions,
	_StructProp_ConditionalOptionsPartialFields
>

type _ImageStringPropImpl = {
	__index: _ImageStringPropImpl,
	new: (fields: _ImageStringPropPartialFields?) -> ImageStringProp,
	encode: (self: ImageStringProp) -> buffer,
	decode: (input: buffer) -> ImageStringProp,
	jsonEncode: (self: ImageStringProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ImageStringProp,
	descriptor: proto.Descriptor,
}

type _ImageStringPropFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "binding_path", value: string }
		| { type: "format", value: StringFormat }
		| { type: "conditional", value: ImageStringProp_ConditionalOptions }
	)?,
}

type _ImageStringPropPartialFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "binding_path", value: string }
		| { type: "format", value: StringFormat }
		| { type: "conditional", value: ImageStringProp_ConditionalOptions }
	)?,
}

export type ImageStringProp = typeof(setmetatable({} :: _ImageStringPropFields, {} :: _ImageStringPropImpl))
type _ImageStringPropMessage = proto.Message<ImageStringProp, _ImageStringPropPartialFields>

type _ImageStringProp_ConditionalOptionImpl = {
	__index: _ImageStringProp_ConditionalOptionImpl,
	new: (fields: _ImageStringProp_ConditionalOptionPartialFields?) -> ImageStringProp_ConditionalOption,
	encode: (self: ImageStringProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> ImageStringProp_ConditionalOption,
	jsonEncode: (self: ImageStringProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ImageStringProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _ImageStringProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: string }
		| { type: "binding_path", value: string }
		| { type: "format", value: StringFormat }
	)?,
}

type _ImageStringProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: string }
		| { type: "binding_path", value: string }
		| { type: "format", value: StringFormat }
	)?,
}

export type ImageStringProp_ConditionalOption = typeof(setmetatable(
	{} :: _ImageStringProp_ConditionalOptionFields,
	{} :: _ImageStringProp_ConditionalOptionImpl
))
type _ImageStringProp_ConditionalOptionMessage = proto.Message<
	ImageStringProp_ConditionalOption,
	_ImageStringProp_ConditionalOptionPartialFields
>

type _ImageStringProp_ConditionalOptionsImpl = {
	__index: _ImageStringProp_ConditionalOptionsImpl,
	new: (fields: _ImageStringProp_ConditionalOptionsPartialFields?) -> ImageStringProp_ConditionalOptions,
	encode: (self: ImageStringProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> ImageStringProp_ConditionalOptions,
	jsonEncode: (self: ImageStringProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ImageStringProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _ImageStringProp_ConditionalOptionsFields = {
	option: { ImageStringProp_ConditionalOption },
}

type _ImageStringProp_ConditionalOptionsPartialFields = {
	option: { ImageStringProp_ConditionalOption }?,
}

export type ImageStringProp_ConditionalOptions = typeof(setmetatable(
	{} :: _ImageStringProp_ConditionalOptionsFields,
	{} :: _ImageStringProp_ConditionalOptionsImpl
))
type _ImageStringProp_ConditionalOptionsMessage = proto.Message<
	ImageStringProp_ConditionalOptions,
	_ImageStringProp_ConditionalOptionsPartialFields
>

type _ImageSetPropImpl = {
	__index: _ImageSetPropImpl,
	new: (fields: _ImageSetPropPartialFields?) -> ImageSetProp,
	encode: (self: ImageSetProp) -> buffer,
	decode: (input: buffer) -> ImageSetProp,
	jsonEncode: (self: ImageSetProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ImageSetProp,
	descriptor: proto.Descriptor,
}

type _ImageSetPropFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "binding_path", value: string }
		| { type: "format", value: StringFormat }
		| { type: "conditional", value: ImageSetProp_ConditionalOptions }
	)?,
}

type _ImageSetPropPartialFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "binding_path", value: string }
		| { type: "format", value: StringFormat }
		| { type: "conditional", value: ImageSetProp_ConditionalOptions }
	)?,
}

export type ImageSetProp = typeof(setmetatable({} :: _ImageSetPropFields, {} :: _ImageSetPropImpl))
type _ImageSetPropMessage = proto.Message<ImageSetProp, _ImageSetPropPartialFields>

type _ImageSetProp_ConditionalOptionImpl = {
	__index: _ImageSetProp_ConditionalOptionImpl,
	new: (fields: _ImageSetProp_ConditionalOptionPartialFields?) -> ImageSetProp_ConditionalOption,
	encode: (self: ImageSetProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> ImageSetProp_ConditionalOption,
	jsonEncode: (self: ImageSetProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ImageSetProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _ImageSetProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: string }
		| { type: "binding_path", value: string }
		| { type: "format", value: StringFormat }
	)?,
}

type _ImageSetProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: string }
		| { type: "binding_path", value: string }
		| { type: "format", value: StringFormat }
	)?,
}

export type ImageSetProp_ConditionalOption = typeof(setmetatable(
	{} :: _ImageSetProp_ConditionalOptionFields,
	{} :: _ImageSetProp_ConditionalOptionImpl
))
type _ImageSetProp_ConditionalOptionMessage = proto.Message<
	ImageSetProp_ConditionalOption,
	_ImageSetProp_ConditionalOptionPartialFields
>

type _ImageSetProp_ConditionalOptionsImpl = {
	__index: _ImageSetProp_ConditionalOptionsImpl,
	new: (fields: _ImageSetProp_ConditionalOptionsPartialFields?) -> ImageSetProp_ConditionalOptions,
	encode: (self: ImageSetProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> ImageSetProp_ConditionalOptions,
	jsonEncode: (self: ImageSetProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ImageSetProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _ImageSetProp_ConditionalOptionsFields = {
	option: { ImageSetProp_ConditionalOption },
}

type _ImageSetProp_ConditionalOptionsPartialFields = {
	option: { ImageSetProp_ConditionalOption }?,
}

export type ImageSetProp_ConditionalOptions = typeof(setmetatable(
	{} :: _ImageSetProp_ConditionalOptionsFields,
	{} :: _ImageSetProp_ConditionalOptionsImpl
))
type _ImageSetProp_ConditionalOptionsMessage = proto.Message<
	ImageSetProp_ConditionalOptions,
	_ImageSetProp_ConditionalOptionsPartialFields
>

type _ColorPropImpl = {
	__index: _ColorPropImpl,
	new: (fields: _ColorPropPartialFields?) -> ColorProp,
	encode: (self: ColorProp) -> buffer,
	decode: (input: buffer) -> ColorProp,
	jsonEncode: (self: ColorProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ColorProp,
	descriptor: proto.Descriptor,
}

type _ColorPropFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: ColorProp_ConditionalOptions }
		| { type: "binding_path", value: string }
	)?,
}

type _ColorPropPartialFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: ColorProp_ConditionalOptions }
		| { type: "binding_path", value: string }
	)?,
}

export type ColorProp = typeof(setmetatable({} :: _ColorPropFields, {} :: _ColorPropImpl))
type _ColorPropMessage = proto.Message<ColorProp, _ColorPropPartialFields>

type _ColorProp_ConditionalOptionImpl = {
	__index: _ColorProp_ConditionalOptionImpl,
	new: (fields: _ColorProp_ConditionalOptionPartialFields?) -> ColorProp_ConditionalOption,
	encode: (self: ColorProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> ColorProp_ConditionalOption,
	jsonEncode: (self: ColorProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ColorProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _ColorProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: string } | { type: "token", value: string } | { type: "binding_path", value: string }
	)?,
}

type _ColorProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: string } | { type: "token", value: string } | { type: "binding_path", value: string }
	)?,
}

export type ColorProp_ConditionalOption = typeof(setmetatable(
	{} :: _ColorProp_ConditionalOptionFields,
	{} :: _ColorProp_ConditionalOptionImpl
))
type _ColorProp_ConditionalOptionMessage = proto.Message<
	ColorProp_ConditionalOption,
	_ColorProp_ConditionalOptionPartialFields
>

type _ColorProp_ConditionalOptionsImpl = {
	__index: _ColorProp_ConditionalOptionsImpl,
	new: (fields: _ColorProp_ConditionalOptionsPartialFields?) -> ColorProp_ConditionalOptions,
	encode: (self: ColorProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> ColorProp_ConditionalOptions,
	jsonEncode: (self: ColorProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ColorProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _ColorProp_ConditionalOptionsFields = {
	option: { ColorProp_ConditionalOption },
}

type _ColorProp_ConditionalOptionsPartialFields = {
	option: { ColorProp_ConditionalOption }?,
}

export type ColorProp_ConditionalOptions = typeof(setmetatable(
	{} :: _ColorProp_ConditionalOptionsFields,
	{} :: _ColorProp_ConditionalOptionsImpl
))
type _ColorProp_ConditionalOptionsMessage = proto.Message<
	ColorProp_ConditionalOptions,
	_ColorProp_ConditionalOptionsPartialFields
>

type _TypographyPropImpl = {
	__index: _TypographyPropImpl,
	new: (fields: _TypographyPropPartialFields?) -> TypographyProp,
	encode: (self: TypographyProp) -> buffer,
	decode: (input: buffer) -> TypographyProp,
	jsonEncode: (self: TypographyProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> TypographyProp,
	descriptor: proto.Descriptor,
}

type _TypographyPropFields = {
	kind: ({ type: "token", value: string } | { type: "conditional", value: TypographyProp_ConditionalOptions })?,
}

type _TypographyPropPartialFields = {
	kind: ({ type: "token", value: string } | { type: "conditional", value: TypographyProp_ConditionalOptions })?,
}

export type TypographyProp = typeof(setmetatable({} :: _TypographyPropFields, {} :: _TypographyPropImpl))
type _TypographyPropMessage = proto.Message<TypographyProp, _TypographyPropPartialFields>

type _TypographyProp_ConditionalOptionImpl = {
	__index: _TypographyProp_ConditionalOptionImpl,
	new: (fields: _TypographyProp_ConditionalOptionPartialFields?) -> TypographyProp_ConditionalOption,
	encode: (self: TypographyProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> TypographyProp_ConditionalOption,
	jsonEncode: (self: TypographyProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> TypographyProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _TypographyProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	token: string,
}

type _TypographyProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	token: string?,
}

export type TypographyProp_ConditionalOption = typeof(setmetatable(
	{} :: _TypographyProp_ConditionalOptionFields,
	{} :: _TypographyProp_ConditionalOptionImpl
))
type _TypographyProp_ConditionalOptionMessage = proto.Message<
	TypographyProp_ConditionalOption,
	_TypographyProp_ConditionalOptionPartialFields
>

type _TypographyProp_ConditionalOptionsImpl = {
	__index: _TypographyProp_ConditionalOptionsImpl,
	new: (fields: _TypographyProp_ConditionalOptionsPartialFields?) -> TypographyProp_ConditionalOptions,
	encode: (self: TypographyProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> TypographyProp_ConditionalOptions,
	jsonEncode: (self: TypographyProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> TypographyProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _TypographyProp_ConditionalOptionsFields = {
	option: { TypographyProp_ConditionalOption },
}

type _TypographyProp_ConditionalOptionsPartialFields = {
	option: { TypographyProp_ConditionalOption }?,
}

export type TypographyProp_ConditionalOptions = typeof(setmetatable(
	{} :: _TypographyProp_ConditionalOptionsFields,
	{} :: _TypographyProp_ConditionalOptionsImpl
))
type _TypographyProp_ConditionalOptionsMessage = proto.Message<
	TypographyProp_ConditionalOptions,
	_TypographyProp_ConditionalOptionsPartialFields
>

type _TypographyFontPropImpl = {
	__index: _TypographyFontPropImpl,
	new: (fields: _TypographyFontPropPartialFields?) -> TypographyFontProp,
	encode: (self: TypographyFontProp) -> buffer,
	decode: (input: buffer) -> TypographyFontProp,
	jsonEncode: (self: TypographyFontProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> TypographyFontProp,
	descriptor: proto.Descriptor,
}

type _TypographyFontPropFields = {
	kind: ({ type: "token", value: string } | { type: "conditional", value: TypographyFontProp_ConditionalOptions })?,
}

type _TypographyFontPropPartialFields = {
	kind: ({ type: "token", value: string } | { type: "conditional", value: TypographyFontProp_ConditionalOptions })?,
}

export type TypographyFontProp = typeof(setmetatable({} :: _TypographyFontPropFields, {} :: _TypographyFontPropImpl))
type _TypographyFontPropMessage = proto.Message<TypographyFontProp, _TypographyFontPropPartialFields>

type _TypographyFontProp_ConditionalOptionImpl = {
	__index: _TypographyFontProp_ConditionalOptionImpl,
	new: (fields: _TypographyFontProp_ConditionalOptionPartialFields?) -> TypographyFontProp_ConditionalOption,
	encode: (self: TypographyFontProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> TypographyFontProp_ConditionalOption,
	jsonEncode: (self: TypographyFontProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> TypographyFontProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _TypographyFontProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	token: string,
}

type _TypographyFontProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	token: string?,
}

export type TypographyFontProp_ConditionalOption = typeof(setmetatable(
	{} :: _TypographyFontProp_ConditionalOptionFields,
	{} :: _TypographyFontProp_ConditionalOptionImpl
))
type _TypographyFontProp_ConditionalOptionMessage = proto.Message<
	TypographyFontProp_ConditionalOption,
	_TypographyFontProp_ConditionalOptionPartialFields
>

type _TypographyFontProp_ConditionalOptionsImpl = {
	__index: _TypographyFontProp_ConditionalOptionsImpl,
	new: (fields: _TypographyFontProp_ConditionalOptionsPartialFields?) -> TypographyFontProp_ConditionalOptions,
	encode: (self: TypographyFontProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> TypographyFontProp_ConditionalOptions,
	jsonEncode: (self: TypographyFontProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> TypographyFontProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _TypographyFontProp_ConditionalOptionsFields = {
	option: { TypographyFontProp_ConditionalOption },
}

type _TypographyFontProp_ConditionalOptionsPartialFields = {
	option: { TypographyFontProp_ConditionalOption }?,
}

export type TypographyFontProp_ConditionalOptions = typeof(setmetatable(
	{} :: _TypographyFontProp_ConditionalOptionsFields,
	{} :: _TypographyFontProp_ConditionalOptionsImpl
))
type _TypographyFontProp_ConditionalOptionsMessage = proto.Message<
	TypographyFontProp_ConditionalOptions,
	_TypographyFontProp_ConditionalOptionsPartialFields
>

type _UDimPropImpl = {
	__index: _UDimPropImpl,
	new: (fields: _UDimPropPartialFields?) -> UDimProp,
	encode: (self: UDimProp) -> buffer,
	decode: (input: buffer) -> UDimProp,
	jsonEncode: (self: UDimProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> UDimProp,
	descriptor: proto.Descriptor,
}

type _UDimPropFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: UDimProp_ConditionalOptions }
	)?,
}

type _UDimPropPartialFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: UDimProp_ConditionalOptions }
	)?,
}

export type UDimProp = typeof(setmetatable({} :: _UDimPropFields, {} :: _UDimPropImpl))
type _UDimPropMessage = proto.Message<UDimProp, _UDimPropPartialFields>

type _UDimProp_ConditionalOptionImpl = {
	__index: _UDimProp_ConditionalOptionImpl,
	new: (fields: _UDimProp_ConditionalOptionPartialFields?) -> UDimProp_ConditionalOption,
	encode: (self: UDimProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> UDimProp_ConditionalOption,
	jsonEncode: (self: UDimProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> UDimProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _UDimProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "literal", value: string } | { type: "token", value: string })?,
}

type _UDimProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "literal", value: string } | { type: "token", value: string })?,
}

export type UDimProp_ConditionalOption = typeof(setmetatable(
	{} :: _UDimProp_ConditionalOptionFields,
	{} :: _UDimProp_ConditionalOptionImpl
))
type _UDimProp_ConditionalOptionMessage = proto.Message<
	UDimProp_ConditionalOption,
	_UDimProp_ConditionalOptionPartialFields
>

type _UDimProp_ConditionalOptionsImpl = {
	__index: _UDimProp_ConditionalOptionsImpl,
	new: (fields: _UDimProp_ConditionalOptionsPartialFields?) -> UDimProp_ConditionalOptions,
	encode: (self: UDimProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> UDimProp_ConditionalOptions,
	jsonEncode: (self: UDimProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> UDimProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _UDimProp_ConditionalOptionsFields = {
	option: { UDimProp_ConditionalOption },
}

type _UDimProp_ConditionalOptionsPartialFields = {
	option: { UDimProp_ConditionalOption }?,
}

export type UDimProp_ConditionalOptions = typeof(setmetatable(
	{} :: _UDimProp_ConditionalOptionsFields,
	{} :: _UDimProp_ConditionalOptionsImpl
))
type _UDimProp_ConditionalOptionsMessage = proto.Message<
	UDimProp_ConditionalOptions,
	_UDimProp_ConditionalOptionsPartialFields
>

type _UDim2PropImpl = {
	__index: _UDim2PropImpl,
	new: (fields: _UDim2PropPartialFields?) -> UDim2Prop,
	encode: (self: UDim2Prop) -> buffer,
	decode: (input: buffer) -> UDim2Prop,
	jsonEncode: (self: UDim2Prop) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> UDim2Prop,
	descriptor: proto.Descriptor,
}

type _UDim2PropFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: UDim2Prop_ConditionalOptions }
	)?,
}

type _UDim2PropPartialFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: UDim2Prop_ConditionalOptions }
	)?,
}

export type UDim2Prop = typeof(setmetatable({} :: _UDim2PropFields, {} :: _UDim2PropImpl))
type _UDim2PropMessage = proto.Message<UDim2Prop, _UDim2PropPartialFields>

type _UDim2Prop_ConditionalOptionImpl = {
	__index: _UDim2Prop_ConditionalOptionImpl,
	new: (fields: _UDim2Prop_ConditionalOptionPartialFields?) -> UDim2Prop_ConditionalOption,
	encode: (self: UDim2Prop_ConditionalOption) -> buffer,
	decode: (input: buffer) -> UDim2Prop_ConditionalOption,
	jsonEncode: (self: UDim2Prop_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> UDim2Prop_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _UDim2Prop_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "literal", value: string } | { type: "token", value: string })?,
}

type _UDim2Prop_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "literal", value: string } | { type: "token", value: string })?,
}

export type UDim2Prop_ConditionalOption = typeof(setmetatable(
	{} :: _UDim2Prop_ConditionalOptionFields,
	{} :: _UDim2Prop_ConditionalOptionImpl
))
type _UDim2Prop_ConditionalOptionMessage = proto.Message<
	UDim2Prop_ConditionalOption,
	_UDim2Prop_ConditionalOptionPartialFields
>

type _UDim2Prop_ConditionalOptionsImpl = {
	__index: _UDim2Prop_ConditionalOptionsImpl,
	new: (fields: _UDim2Prop_ConditionalOptionsPartialFields?) -> UDim2Prop_ConditionalOptions,
	encode: (self: UDim2Prop_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> UDim2Prop_ConditionalOptions,
	jsonEncode: (self: UDim2Prop_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> UDim2Prop_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _UDim2Prop_ConditionalOptionsFields = {
	option: { UDim2Prop_ConditionalOption },
}

type _UDim2Prop_ConditionalOptionsPartialFields = {
	option: { UDim2Prop_ConditionalOption }?,
}

export type UDim2Prop_ConditionalOptions = typeof(setmetatable(
	{} :: _UDim2Prop_ConditionalOptionsFields,
	{} :: _UDim2Prop_ConditionalOptionsImpl
))
type _UDim2Prop_ConditionalOptionsMessage = proto.Message<
	UDim2Prop_ConditionalOptions,
	_UDim2Prop_ConditionalOptionsPartialFields
>

type _Vector2PropImpl = {
	__index: _Vector2PropImpl,
	new: (fields: _Vector2PropPartialFields?) -> Vector2Prop,
	encode: (self: Vector2Prop) -> buffer,
	decode: (input: buffer) -> Vector2Prop,
	jsonEncode: (self: Vector2Prop) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Vector2Prop,
	descriptor: proto.Descriptor,
}

type _Vector2PropFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: Vector2Prop_ConditionalOptions }
	)?,
}

type _Vector2PropPartialFields = {
	kind: (
		{ type: "literal", value: string }
		| { type: "token", value: string }
		| { type: "conditional", value: Vector2Prop_ConditionalOptions }
	)?,
}

export type Vector2Prop = typeof(setmetatable({} :: _Vector2PropFields, {} :: _Vector2PropImpl))
type _Vector2PropMessage = proto.Message<Vector2Prop, _Vector2PropPartialFields>

type _Vector2Prop_ConditionalOptionImpl = {
	__index: _Vector2Prop_ConditionalOptionImpl,
	new: (fields: _Vector2Prop_ConditionalOptionPartialFields?) -> Vector2Prop_ConditionalOption,
	encode: (self: Vector2Prop_ConditionalOption) -> buffer,
	decode: (input: buffer) -> Vector2Prop_ConditionalOption,
	jsonEncode: (self: Vector2Prop_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Vector2Prop_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _Vector2Prop_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "literal", value: string } | { type: "token", value: string })?,
}

type _Vector2Prop_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "literal", value: string } | { type: "token", value: string })?,
}

export type Vector2Prop_ConditionalOption = typeof(setmetatable(
	{} :: _Vector2Prop_ConditionalOptionFields,
	{} :: _Vector2Prop_ConditionalOptionImpl
))
type _Vector2Prop_ConditionalOptionMessage = proto.Message<
	Vector2Prop_ConditionalOption,
	_Vector2Prop_ConditionalOptionPartialFields
>

type _Vector2Prop_ConditionalOptionsImpl = {
	__index: _Vector2Prop_ConditionalOptionsImpl,
	new: (fields: _Vector2Prop_ConditionalOptionsPartialFields?) -> Vector2Prop_ConditionalOptions,
	encode: (self: Vector2Prop_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> Vector2Prop_ConditionalOptions,
	jsonEncode: (self: Vector2Prop_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Vector2Prop_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _Vector2Prop_ConditionalOptionsFields = {
	option: { Vector2Prop_ConditionalOption },
}

type _Vector2Prop_ConditionalOptionsPartialFields = {
	option: { Vector2Prop_ConditionalOption }?,
}

export type Vector2Prop_ConditionalOptions = typeof(setmetatable(
	{} :: _Vector2Prop_ConditionalOptionsFields,
	{} :: _Vector2Prop_ConditionalOptionsImpl
))
type _Vector2Prop_ConditionalOptionsMessage = proto.Message<
	Vector2Prop_ConditionalOptions,
	_Vector2Prop_ConditionalOptionsPartialFields
>

type _TemplateArgImpl = {
	__index: _TemplateArgImpl,
	new: (fields: _TemplateArgPartialFields?) -> TemplateArg,
	encode: (self: TemplateArg) -> buffer,
	decode: (input: buffer) -> TemplateArg,
	jsonEncode: (self: TemplateArg) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> TemplateArg,
	descriptor: proto.Descriptor,
}

type _TemplateArgFields = {
	kind: ({ type: "literal", value: TemplateArg_LiteralValue } | { type: "binding_path", value: string })?,
}

type _TemplateArgPartialFields = {
	kind: ({ type: "literal", value: TemplateArg_LiteralValue } | { type: "binding_path", value: string })?,
}

export type TemplateArg = typeof(setmetatable({} :: _TemplateArgFields, {} :: _TemplateArgImpl))
type _TemplateArgMessage = proto.Message<TemplateArg, _TemplateArgPartialFields>

type _TemplateArg_LiteralValueImpl = {
	__index: _TemplateArg_LiteralValueImpl,
	new: (fields: _TemplateArg_LiteralValuePartialFields?) -> TemplateArg_LiteralValue,
	encode: (self: TemplateArg_LiteralValue) -> buffer,
	decode: (input: buffer) -> TemplateArg_LiteralValue,
	jsonEncode: (self: TemplateArg_LiteralValue) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> TemplateArg_LiteralValue,
	descriptor: proto.Descriptor,
}

type _TemplateArg_LiteralValueFields = {
	kind: (
		{ type: "string_value", value: string }
		| { type: "int32_value", value: number }
		| { type: "int64_value", value: number }
		| { type: "float_value", value: number }
		| { type: "double_value", value: number }
	)?,
}

type _TemplateArg_LiteralValuePartialFields = {
	kind: (
		{ type: "string_value", value: string }
		| { type: "int32_value", value: number }
		| { type: "int64_value", value: number }
		| { type: "float_value", value: number }
		| { type: "double_value", value: number }
	)?,
}

export type TemplateArg_LiteralValue = typeof(setmetatable(
	{} :: _TemplateArg_LiteralValueFields,
	{} :: _TemplateArg_LiteralValueImpl
))
type _TemplateArg_LiteralValueMessage = proto.Message<TemplateArg_LiteralValue, _TemplateArg_LiteralValuePartialFields>

type _NestedComponentPropImpl = {
	__index: _NestedComponentPropImpl,
	new: (fields: _NestedComponentPropPartialFields?) -> NestedComponentProp,
	encode: (self: NestedComponentProp) -> buffer,
	decode: (input: buffer) -> NestedComponentProp,
	jsonEncode: (self: NestedComponentProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> NestedComponentProp,
	descriptor: proto.Descriptor,
}

type _NestedComponentPropFields = {
	kind: (
		{ type: "literal", value: NestedComponentProp_TemplateData }
		| { type: "conditional", value: NestedComponentProp_ConditionalOptions }
	)?,
}

type _NestedComponentPropPartialFields = {
	kind: (
		{ type: "literal", value: NestedComponentProp_TemplateData }
		| { type: "conditional", value: NestedComponentProp_ConditionalOptions }
	)?,
}

export type NestedComponentProp = typeof(setmetatable({} :: _NestedComponentPropFields, {} :: _NestedComponentPropImpl))
type _NestedComponentPropMessage = proto.Message<NestedComponentProp, _NestedComponentPropPartialFields>

type _NestedComponentProp_ConditionalOptionImpl = {
	__index: _NestedComponentProp_ConditionalOptionImpl,
	new: (fields: _NestedComponentProp_ConditionalOptionPartialFields?) -> NestedComponentProp_ConditionalOption,
	encode: (self: NestedComponentProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> NestedComponentProp_ConditionalOption,
	jsonEncode: (self: NestedComponentProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> NestedComponentProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _NestedComponentProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	literal: NestedComponentProp_TemplateData?,
}

type _NestedComponentProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	literal: NestedComponentProp_TemplateData?,
}

export type NestedComponentProp_ConditionalOption = typeof(setmetatable(
	{} :: _NestedComponentProp_ConditionalOptionFields,
	{} :: _NestedComponentProp_ConditionalOptionImpl
))
type _NestedComponentProp_ConditionalOptionMessage = proto.Message<
	NestedComponentProp_ConditionalOption,
	_NestedComponentProp_ConditionalOptionPartialFields
>

type _NestedComponentProp_ConditionalOptionsImpl = {
	__index: _NestedComponentProp_ConditionalOptionsImpl,
	new: (fields: _NestedComponentProp_ConditionalOptionsPartialFields?) -> NestedComponentProp_ConditionalOptions,
	encode: (self: NestedComponentProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> NestedComponentProp_ConditionalOptions,
	jsonEncode: (self: NestedComponentProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> NestedComponentProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _NestedComponentProp_ConditionalOptionsFields = {
	option: { NestedComponentProp_ConditionalOption },
}

type _NestedComponentProp_ConditionalOptionsPartialFields = {
	option: { NestedComponentProp_ConditionalOption }?,
}

export type NestedComponentProp_ConditionalOptions = typeof(setmetatable(
	{} :: _NestedComponentProp_ConditionalOptionsFields,
	{} :: _NestedComponentProp_ConditionalOptionsImpl
))
type _NestedComponentProp_ConditionalOptionsMessage = proto.Message<
	NestedComponentProp_ConditionalOptions,
	_NestedComponentProp_ConditionalOptionsPartialFields
>

type _NestedComponentProp_TemplateDataImpl = {
	__index: _NestedComponentProp_TemplateDataImpl,
	new: (fields: _NestedComponentProp_TemplateDataPartialFields?) -> NestedComponentProp_TemplateData,
	encode: (self: NestedComponentProp_TemplateData) -> buffer,
	decode: (input: buffer) -> NestedComponentProp_TemplateData,
	jsonEncode: (self: NestedComponentProp_TemplateData) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> NestedComponentProp_TemplateData,
	descriptor: proto.Descriptor,
}

type _NestedComponentProp_TemplateDataFields = {
	inputs: { [string]: TemplateArg },
	roblox_component: _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType,
	template_id: string,
}

type _NestedComponentProp_TemplateDataPartialFields = {
	inputs: { [string]: TemplateArg }?,
	roblox_component: _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType?,
	template_id: string?,
}

export type NestedComponentProp_TemplateData = typeof(setmetatable(
	{} :: _NestedComponentProp_TemplateDataFields,
	{} :: _NestedComponentProp_TemplateDataImpl
))
type _NestedComponentProp_TemplateDataMessage = proto.Message<
	NestedComponentProp_TemplateData,
	_NestedComponentProp_TemplateDataPartialFields
>

type _NestedComponentProp_TemplateData_InputsEntryImpl = {
	__index: _NestedComponentProp_TemplateData_InputsEntryImpl,
	new: (
		fields: _NestedComponentProp_TemplateData_InputsEntryPartialFields?
	) -> NestedComponentProp_TemplateData_InputsEntry,
	encode: (self: NestedComponentProp_TemplateData_InputsEntry) -> buffer,
	decode: (input: buffer) -> NestedComponentProp_TemplateData_InputsEntry,
	jsonEncode: (self: NestedComponentProp_TemplateData_InputsEntry) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> NestedComponentProp_TemplateData_InputsEntry,
	descriptor: proto.Descriptor,
}

type _NestedComponentProp_TemplateData_InputsEntryFields = {
	key: string,
	value: TemplateArg?,
}

type _NestedComponentProp_TemplateData_InputsEntryPartialFields = {
	key: string?,
	value: TemplateArg?,
}

export type NestedComponentProp_TemplateData_InputsEntry = typeof(setmetatable(
	{} :: _NestedComponentProp_TemplateData_InputsEntryFields,
	{} :: _NestedComponentProp_TemplateData_InputsEntryImpl
))
type _NestedComponentProp_TemplateData_InputsEntryMessage = proto.Message<
	NestedComponentProp_TemplateData_InputsEntry,
	_NestedComponentProp_TemplateData_InputsEntryPartialFields
>

type _LazyNestedComponentListPropImpl = {
	__index: _LazyNestedComponentListPropImpl,
	new: (fields: _LazyNestedComponentListPropPartialFields?) -> LazyNestedComponentListProp,
	encode: (self: LazyNestedComponentListProp) -> buffer,
	decode: (input: buffer) -> LazyNestedComponentListProp,
	jsonEncode: (self: LazyNestedComponentListProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> LazyNestedComponentListProp,
	descriptor: proto.Descriptor,
}

type _LazyNestedComponentListPropFields = {
	kind: (
		{ type: "array_map", value: LazyNestedComponentListProp_TemplateData }
		| { type: "item_list", value: LazyNestedComponentListProp_TemplateDataList }
		| { type: "conditional", value: LazyNestedComponentListProp_ConditionalOptions }
	)?,
}

type _LazyNestedComponentListPropPartialFields = {
	kind: (
		{ type: "array_map", value: LazyNestedComponentListProp_TemplateData }
		| { type: "item_list", value: LazyNestedComponentListProp_TemplateDataList }
		| { type: "conditional", value: LazyNestedComponentListProp_ConditionalOptions }
	)?,
}

export type LazyNestedComponentListProp = typeof(setmetatable(
	{} :: _LazyNestedComponentListPropFields,
	{} :: _LazyNestedComponentListPropImpl
))
type _LazyNestedComponentListPropMessage = proto.Message<
	LazyNestedComponentListProp,
	_LazyNestedComponentListPropPartialFields
>

type _LazyNestedComponentListProp_ConditionalOptionImpl = {
	__index: _LazyNestedComponentListProp_ConditionalOptionImpl,
	new: (
		fields: _LazyNestedComponentListProp_ConditionalOptionPartialFields?
	) -> LazyNestedComponentListProp_ConditionalOption,
	encode: (self: LazyNestedComponentListProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> LazyNestedComponentListProp_ConditionalOption,
	jsonEncode: (self: LazyNestedComponentListProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> LazyNestedComponentListProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _LazyNestedComponentListProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: LazyNestedComponentListProp_TemplateData }
		| { type: "item_list", value: LazyNestedComponentListProp_TemplateDataList }
	)?,
}

type _LazyNestedComponentListProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: (
		{ type: "literal", value: LazyNestedComponentListProp_TemplateData }
		| { type: "item_list", value: LazyNestedComponentListProp_TemplateDataList }
	)?,
}

export type LazyNestedComponentListProp_ConditionalOption = typeof(setmetatable(
	{} :: _LazyNestedComponentListProp_ConditionalOptionFields,
	{} :: _LazyNestedComponentListProp_ConditionalOptionImpl
))
type _LazyNestedComponentListProp_ConditionalOptionMessage = proto.Message<
	LazyNestedComponentListProp_ConditionalOption,
	_LazyNestedComponentListProp_ConditionalOptionPartialFields
>

type _LazyNestedComponentListProp_ConditionalOptionsImpl = {
	__index: _LazyNestedComponentListProp_ConditionalOptionsImpl,
	new: (
		fields: _LazyNestedComponentListProp_ConditionalOptionsPartialFields?
	) -> LazyNestedComponentListProp_ConditionalOptions,
	encode: (self: LazyNestedComponentListProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> LazyNestedComponentListProp_ConditionalOptions,
	jsonEncode: (self: LazyNestedComponentListProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> LazyNestedComponentListProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _LazyNestedComponentListProp_ConditionalOptionsFields = {
	option: { LazyNestedComponentListProp_ConditionalOption },
}

type _LazyNestedComponentListProp_ConditionalOptionsPartialFields = {
	option: { LazyNestedComponentListProp_ConditionalOption }?,
}

export type LazyNestedComponentListProp_ConditionalOptions = typeof(setmetatable(
	{} :: _LazyNestedComponentListProp_ConditionalOptionsFields,
	{} :: _LazyNestedComponentListProp_ConditionalOptionsImpl
))
type _LazyNestedComponentListProp_ConditionalOptionsMessage = proto.Message<
	LazyNestedComponentListProp_ConditionalOptions,
	_LazyNestedComponentListProp_ConditionalOptionsPartialFields
>

type _LazyNestedComponentListProp_TemplateDataImpl = {
	__index: _LazyNestedComponentListProp_TemplateDataImpl,
	new: (fields: _LazyNestedComponentListProp_TemplateDataPartialFields?) -> LazyNestedComponentListProp_TemplateData,
	encode: (self: LazyNestedComponentListProp_TemplateData) -> buffer,
	decode: (input: buffer) -> LazyNestedComponentListProp_TemplateData,
	jsonEncode: (self: LazyNestedComponentListProp_TemplateData) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> LazyNestedComponentListProp_TemplateData,
	descriptor: proto.Descriptor,
}

type _LazyNestedComponentListProp_TemplateDataFields = {
	binding_path: string,
	roblox_component: _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType,
	inputs: { [string]: TemplateArg },
}

type _LazyNestedComponentListProp_TemplateDataPartialFields = {
	binding_path: string?,
	roblox_component: _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType?,
	inputs: { [string]: TemplateArg }?,
}

export type LazyNestedComponentListProp_TemplateData = typeof(setmetatable(
	{} :: _LazyNestedComponentListProp_TemplateDataFields,
	{} :: _LazyNestedComponentListProp_TemplateDataImpl
))
type _LazyNestedComponentListProp_TemplateDataMessage = proto.Message<
	LazyNestedComponentListProp_TemplateData,
	_LazyNestedComponentListProp_TemplateDataPartialFields
>

type _LazyNestedComponentListProp_TemplateData_InputsEntryImpl = {
	__index: _LazyNestedComponentListProp_TemplateData_InputsEntryImpl,
	new: (
		fields: _LazyNestedComponentListProp_TemplateData_InputsEntryPartialFields?
	) -> LazyNestedComponentListProp_TemplateData_InputsEntry,
	encode: (self: LazyNestedComponentListProp_TemplateData_InputsEntry) -> buffer,
	decode: (input: buffer) -> LazyNestedComponentListProp_TemplateData_InputsEntry,
	jsonEncode: (self: LazyNestedComponentListProp_TemplateData_InputsEntry) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> LazyNestedComponentListProp_TemplateData_InputsEntry,
	descriptor: proto.Descriptor,
}

type _LazyNestedComponentListProp_TemplateData_InputsEntryFields = {
	key: string,
	value: TemplateArg?,
}

type _LazyNestedComponentListProp_TemplateData_InputsEntryPartialFields = {
	key: string?,
	value: TemplateArg?,
}

export type LazyNestedComponentListProp_TemplateData_InputsEntry = typeof(setmetatable(
	{} :: _LazyNestedComponentListProp_TemplateData_InputsEntryFields,
	{} :: _LazyNestedComponentListProp_TemplateData_InputsEntryImpl
))
type _LazyNestedComponentListProp_TemplateData_InputsEntryMessage = proto.Message<
	LazyNestedComponentListProp_TemplateData_InputsEntry,
	_LazyNestedComponentListProp_TemplateData_InputsEntryPartialFields
>

type _LazyNestedComponentListProp_TemplateDataListImpl = {
	__index: _LazyNestedComponentListProp_TemplateDataListImpl,
	new: (
		fields: _LazyNestedComponentListProp_TemplateDataListPartialFields?
	) -> LazyNestedComponentListProp_TemplateDataList,
	encode: (self: LazyNestedComponentListProp_TemplateDataList) -> buffer,
	decode: (input: buffer) -> LazyNestedComponentListProp_TemplateDataList,
	jsonEncode: (self: LazyNestedComponentListProp_TemplateDataList) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> LazyNestedComponentListProp_TemplateDataList,
	descriptor: proto.Descriptor,
}

type _LazyNestedComponentListProp_TemplateDataListFields = {
	items: { LazyNestedComponentListProp_TemplateData },
}

type _LazyNestedComponentListProp_TemplateDataListPartialFields = {
	items: { LazyNestedComponentListProp_TemplateData }?,
}

export type LazyNestedComponentListProp_TemplateDataList = typeof(setmetatable(
	{} :: _LazyNestedComponentListProp_TemplateDataListFields,
	{} :: _LazyNestedComponentListProp_TemplateDataListImpl
))
type _LazyNestedComponentListProp_TemplateDataListMessage = proto.Message<
	LazyNestedComponentListProp_TemplateDataList,
	_LazyNestedComponentListProp_TemplateDataListPartialFields
>

type _IconPropImpl = {
	__index: _IconPropImpl,
	new: (fields: _IconPropPartialFields?) -> IconProp,
	encode: (self: IconProp) -> buffer,
	decode: (input: buffer) -> IconProp,
	jsonEncode: (self: IconProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> IconProp,
	descriptor: proto.Descriptor,
}

type _IconPropFields = {
	kind: (
		{ type: "icon_name", value: string }
		| { type: "legacy_icon_name", value: string }
		| { type: "conditional", value: IconProp_ConditionalOptions }
	)?,
}

type _IconPropPartialFields = {
	kind: (
		{ type: "icon_name", value: string }
		| { type: "legacy_icon_name", value: string }
		| { type: "conditional", value: IconProp_ConditionalOptions }
	)?,
}

export type IconProp = typeof(setmetatable({} :: _IconPropFields, {} :: _IconPropImpl))
type _IconPropMessage = proto.Message<IconProp, _IconPropPartialFields>

type _IconProp_ConditionalOptionImpl = {
	__index: _IconProp_ConditionalOptionImpl,
	new: (fields: _IconProp_ConditionalOptionPartialFields?) -> IconProp_ConditionalOption,
	encode: (self: IconProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> IconProp_ConditionalOption,
	jsonEncode: (self: IconProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> IconProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _IconProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "icon_name", value: string } | { type: "legacy_icon_name", value: string })?,
}

type _IconProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "icon_name", value: string } | { type: "legacy_icon_name", value: string })?,
}

export type IconProp_ConditionalOption = typeof(setmetatable(
	{} :: _IconProp_ConditionalOptionFields,
	{} :: _IconProp_ConditionalOptionImpl
))
type _IconProp_ConditionalOptionMessage = proto.Message<
	IconProp_ConditionalOption,
	_IconProp_ConditionalOptionPartialFields
>

type _IconProp_ConditionalOptionsImpl = {
	__index: _IconProp_ConditionalOptionsImpl,
	new: (fields: _IconProp_ConditionalOptionsPartialFields?) -> IconProp_ConditionalOptions,
	encode: (self: IconProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> IconProp_ConditionalOptions,
	jsonEncode: (self: IconProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> IconProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _IconProp_ConditionalOptionsFields = {
	option: { IconProp_ConditionalOption },
}

type _IconProp_ConditionalOptionsPartialFields = {
	option: { IconProp_ConditionalOption }?,
}

export type IconProp_ConditionalOptions = typeof(setmetatable(
	{} :: _IconProp_ConditionalOptionsFields,
	{} :: _IconProp_ConditionalOptionsImpl
))
type _IconProp_ConditionalOptionsMessage = proto.Message<
	IconProp_ConditionalOptions,
	_IconProp_ConditionalOptionsPartialFields
>

type _GradientPropImpl = {
	__index: _GradientPropImpl,
	new: (fields: _GradientPropPartialFields?) -> GradientProp,
	encode: (self: GradientProp) -> buffer,
	decode: (input: buffer) -> GradientProp,
	jsonEncode: (self: GradientProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> GradientProp,
	descriptor: proto.Descriptor,
}

type _GradientPropFields = {
	kind: (
		{ type: "literal", value: GradientProp_GradientData }
		| { type: "conditional", value: GradientProp_ConditionalOptions }
	)?,
}

type _GradientPropPartialFields = {
	kind: (
		{ type: "literal", value: GradientProp_GradientData }
		| { type: "conditional", value: GradientProp_ConditionalOptions }
	)?,
}

export type GradientProp = typeof(setmetatable({} :: _GradientPropFields, {} :: _GradientPropImpl))
type _GradientPropMessage = proto.Message<GradientProp, _GradientPropPartialFields>

type _GradientProp_ConditionalOptionImpl = {
	__index: _GradientProp_ConditionalOptionImpl,
	new: (fields: _GradientProp_ConditionalOptionPartialFields?) -> GradientProp_ConditionalOption,
	encode: (self: GradientProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> GradientProp_ConditionalOption,
	jsonEncode: (self: GradientProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> GradientProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _GradientProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	literal: GradientProp_GradientData?,
}

type _GradientProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	literal: GradientProp_GradientData?,
}

export type GradientProp_ConditionalOption = typeof(setmetatable(
	{} :: _GradientProp_ConditionalOptionFields,
	{} :: _GradientProp_ConditionalOptionImpl
))
type _GradientProp_ConditionalOptionMessage = proto.Message<
	GradientProp_ConditionalOption,
	_GradientProp_ConditionalOptionPartialFields
>

type _GradientProp_ConditionalOptionsImpl = {
	__index: _GradientProp_ConditionalOptionsImpl,
	new: (fields: _GradientProp_ConditionalOptionsPartialFields?) -> GradientProp_ConditionalOptions,
	encode: (self: GradientProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> GradientProp_ConditionalOptions,
	jsonEncode: (self: GradientProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> GradientProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _GradientProp_ConditionalOptionsFields = {
	option: { GradientProp_ConditionalOption },
}

type _GradientProp_ConditionalOptionsPartialFields = {
	option: { GradientProp_ConditionalOption }?,
}

export type GradientProp_ConditionalOptions = typeof(setmetatable(
	{} :: _GradientProp_ConditionalOptionsFields,
	{} :: _GradientProp_ConditionalOptionsImpl
))
type _GradientProp_ConditionalOptionsMessage = proto.Message<
	GradientProp_ConditionalOptions,
	_GradientProp_ConditionalOptionsPartialFields
>

type _GradientProp_GradientDataImpl = {
	__index: _GradientProp_GradientDataImpl,
	new: (fields: _GradientProp_GradientDataPartialFields?) -> GradientProp_GradientData,
	encode: (self: GradientProp_GradientData) -> buffer,
	decode: (input: buffer) -> GradientProp_GradientData,
	jsonEncode: (self: GradientProp_GradientData) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> GradientProp_GradientData,
	descriptor: proto.Descriptor,
}

type _GradientProp_GradientDataFields = {
	start_color: string,
	end_color: string,
	start_opacity: number,
	end_opacity: number,
	degree: number,
}

type _GradientProp_GradientDataPartialFields = {
	start_color: string?,
	end_color: string?,
	start_opacity: number?,
	end_opacity: number?,
	degree: number?,
}

export type GradientProp_GradientData = typeof(setmetatable(
	{} :: _GradientProp_GradientDataFields,
	{} :: _GradientProp_GradientDataImpl
))
type _GradientProp_GradientDataMessage = proto.Message<
	GradientProp_GradientData,
	_GradientProp_GradientDataPartialFields
>

type _ArrayOfStructPropImpl = {
	__index: _ArrayOfStructPropImpl,
	new: (fields: _ArrayOfStructPropPartialFields?) -> ArrayOfStructProp,
	encode: (self: ArrayOfStructProp) -> buffer,
	decode: (input: buffer) -> ArrayOfStructProp,
	jsonEncode: (self: ArrayOfStructProp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ArrayOfStructProp,
	descriptor: proto.Descriptor,
}

type _ArrayOfStructPropFields = {
	kind: (
		{ type: "literal", value: ArrayOfStructProp_ArrayOfStructs }
		| { type: "binding_path", value: string }
		| { type: "conditional", value: ArrayOfStructProp_ConditionalOptions }
	)?,
}

type _ArrayOfStructPropPartialFields = {
	kind: (
		{ type: "literal", value: ArrayOfStructProp_ArrayOfStructs }
		| { type: "binding_path", value: string }
		| { type: "conditional", value: ArrayOfStructProp_ConditionalOptions }
	)?,
}

export type ArrayOfStructProp = typeof(setmetatable({} :: _ArrayOfStructPropFields, {} :: _ArrayOfStructPropImpl))
type _ArrayOfStructPropMessage = proto.Message<ArrayOfStructProp, _ArrayOfStructPropPartialFields>

type _ArrayOfStructProp_ConditionalOptionImpl = {
	__index: _ArrayOfStructProp_ConditionalOptionImpl,
	new: (fields: _ArrayOfStructProp_ConditionalOptionPartialFields?) -> ArrayOfStructProp_ConditionalOption,
	encode: (self: ArrayOfStructProp_ConditionalOption) -> buffer,
	decode: (input: buffer) -> ArrayOfStructProp_ConditionalOption,
	jsonEncode: (self: ArrayOfStructProp_ConditionalOption) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ArrayOfStructProp_ConditionalOption,
	descriptor: proto.Descriptor,
}

type _ArrayOfStructProp_ConditionalOptionFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "literal", value: ArrayOfStructProp_ArrayOfStructs } | { type: "binding_path", value: string })?,
}

type _ArrayOfStructProp_ConditionalOptionPartialFields = {
	condition: _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition?,
	kind: ({ type: "literal", value: ArrayOfStructProp_ArrayOfStructs } | { type: "binding_path", value: string })?,
}

export type ArrayOfStructProp_ConditionalOption = typeof(setmetatable(
	{} :: _ArrayOfStructProp_ConditionalOptionFields,
	{} :: _ArrayOfStructProp_ConditionalOptionImpl
))
type _ArrayOfStructProp_ConditionalOptionMessage = proto.Message<
	ArrayOfStructProp_ConditionalOption,
	_ArrayOfStructProp_ConditionalOptionPartialFields
>

type _ArrayOfStructProp_ConditionalOptionsImpl = {
	__index: _ArrayOfStructProp_ConditionalOptionsImpl,
	new: (fields: _ArrayOfStructProp_ConditionalOptionsPartialFields?) -> ArrayOfStructProp_ConditionalOptions,
	encode: (self: ArrayOfStructProp_ConditionalOptions) -> buffer,
	decode: (input: buffer) -> ArrayOfStructProp_ConditionalOptions,
	jsonEncode: (self: ArrayOfStructProp_ConditionalOptions) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ArrayOfStructProp_ConditionalOptions,
	descriptor: proto.Descriptor,
}

type _ArrayOfStructProp_ConditionalOptionsFields = {
	option: { ArrayOfStructProp_ConditionalOption },
}

type _ArrayOfStructProp_ConditionalOptionsPartialFields = {
	option: { ArrayOfStructProp_ConditionalOption }?,
}

export type ArrayOfStructProp_ConditionalOptions = typeof(setmetatable(
	{} :: _ArrayOfStructProp_ConditionalOptionsFields,
	{} :: _ArrayOfStructProp_ConditionalOptionsImpl
))
type _ArrayOfStructProp_ConditionalOptionsMessage = proto.Message<
	ArrayOfStructProp_ConditionalOptions,
	_ArrayOfStructProp_ConditionalOptionsPartialFields
>

type _ArrayOfStructProp_ArrayOfStructsImpl = {
	__index: _ArrayOfStructProp_ArrayOfStructsImpl,
	new: (fields: _ArrayOfStructProp_ArrayOfStructsPartialFields?) -> ArrayOfStructProp_ArrayOfStructs,
	encode: (self: ArrayOfStructProp_ArrayOfStructs) -> buffer,
	decode: (input: buffer) -> ArrayOfStructProp_ArrayOfStructs,
	jsonEncode: (self: ArrayOfStructProp_ArrayOfStructs) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ArrayOfStructProp_ArrayOfStructs,
	descriptor: proto.Descriptor,
}

type _ArrayOfStructProp_ArrayOfStructsFields = {
	entry: { _google_protobuf_struct.Struct },
}

type _ArrayOfStructProp_ArrayOfStructsPartialFields = {
	entry: { _google_protobuf_struct.Struct }?,
}

export type ArrayOfStructProp_ArrayOfStructs = typeof(setmetatable(
	{} :: _ArrayOfStructProp_ArrayOfStructsFields,
	{} :: _ArrayOfStructProp_ArrayOfStructsImpl
))
type _ArrayOfStructProp_ArrayOfStructsMessage = proto.Message<
	ArrayOfStructProp_ArrayOfStructs,
	_ArrayOfStructProp_ArrayOfStructsPartialFields
>

do
	local _StringFormatImpl = {}
	_StringFormatImpl.__index = _StringFormatImpl

	function _StringFormatImpl.new(data: _StringFormatPartialFields?): StringFormat
		return setmetatable({
			str = if data == nil or data.str == nil then "" else data.str,
			args = if data == nil or data.args == nil then {} else data.args,
		}, _StringFormatImpl :: _StringFormatImpl)
	end

	function _StringFormatImpl.encode(self: StringFormat): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.str ~= nil and self.str ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.str)
		end

		if self.args ~= nil and next(self.args) ~= nil then
			for key, value in self.args do
				local mapBuffer = buffer.create(0)
				local mapCursor = 0
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 1, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeString(mapBuffer, mapCursor, key)
				local encoded = value:encode()
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 2, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeBuffer(mapBuffer, mapCursor, encoded, buffer.len(encoded))
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, mapBuffer, mapCursor)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _StringFormatImpl.decode(input: buffer): StringFormat
		local self = _StringFormatImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.str = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)

					local mapEntry = messages.StringFormat_ArgsEntry.decode(value)

					local keyDefault = ""
					local valueDefault = messages.StringFormat_FormatArg.new()

					self.args[mapEntry.key or keyDefault] = mapEntry.value or valueDefault

					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _StringFormatImpl.jsonEncode(self: StringFormat): any
		local output = {}

		if self.str ~= nil and self.str ~= "" then
			output.str = self.str
		end

		if self.args ~= nil and next(self.args) ~= nil then
			local newOutput = {}
			for key, value in self.args do
				newOutput[key] = value:jsonEncode()
			end
			output.args = newOutput
		end

		return output
	end

	function _StringFormatImpl.jsonDecode(input: { [string]: any }): StringFormat
		local self = _StringFormatImpl.new()

		if input.str ~= nil then
			self.str = input.str
		end

		if input.args ~= nil then
			local newOutput: { [string]: StringFormat_FormatArg } = {}
			for key, value in input.args do
				newOutput[key] = messages.StringFormat_FormatArg.jsonDecode(value)
			end

			self.args = newOutput
		end

		return self
	end

	_StringFormatImpl.descriptor = {
		name = "StringFormat",
		fullName = "roblox.apppageplatform.shared.v1beta1.StringFormat",
	}

	messages.StringFormat = _StringFormatImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.StringFormat)
end

do
	local _StringFormat_FormatArgImpl = {}
	_StringFormat_FormatArgImpl.__index = _StringFormat_FormatArgImpl

	function _StringFormat_FormatArgImpl.new(data: _StringFormat_FormatArgPartialFields?): StringFormat_FormatArg
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _StringFormat_FormatArgImpl :: _StringFormat_FormatArgImpl)
	end

	function _StringFormat_FormatArgImpl.encode(self: StringFormat_FormatArg): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _StringFormat_FormatArgImpl.decode(input: buffer): StringFormat_FormatArg
		local self = _StringFormat_FormatArgImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _StringFormat_FormatArgImpl.jsonEncode(self: StringFormat_FormatArg): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			end
		end

		return output
	end

	function _StringFormat_FormatArgImpl.jsonDecode(input: { [string]: any }): StringFormat_FormatArg
		local self = _StringFormat_FormatArgImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		return self
	end

	_StringFormat_FormatArgImpl.descriptor = {
		name = "StringFormat_FormatArg",
		fullName = "roblox.apppageplatform.shared.v1beta1.FormatArg",
	}

	messages.StringFormat_FormatArg = _StringFormat_FormatArgImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.StringFormat_FormatArg)
end

do
	local _StringFormat_ArgsEntryImpl = {}
	_StringFormat_ArgsEntryImpl.__index = _StringFormat_ArgsEntryImpl

	function _StringFormat_ArgsEntryImpl.new(data: _StringFormat_ArgsEntryPartialFields?): StringFormat_ArgsEntry
		return setmetatable({
			key = if data == nil or data.key == nil then "" else data.key,
			value = if data == nil or data.value == nil then nil else data.value,
		}, _StringFormat_ArgsEntryImpl :: _StringFormat_ArgsEntryImpl)
	end

	function _StringFormat_ArgsEntryImpl.encode(self: StringFormat_ArgsEntry): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.key ~= nil and self.key ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.key)
		end

		if self.value ~= nil then
			local encoded = self.value:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _StringFormat_ArgsEntryImpl.decode(input: buffer): StringFormat_ArgsEntry
		local self = _StringFormat_ArgsEntryImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.key = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = messages.StringFormat_FormatArg.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _StringFormat_ArgsEntryImpl.jsonEncode(self: StringFormat_ArgsEntry): any
		local output = {}

		if self.key ~= nil and self.key ~= "" then
			output.key = self.key
		end

		if self.value ~= nil then
			output.value = self.value:jsonEncode()
		end

		return output
	end

	function _StringFormat_ArgsEntryImpl.jsonDecode(input: { [string]: any }): StringFormat_ArgsEntry
		local self = _StringFormat_ArgsEntryImpl.new()

		if input.key ~= nil then
			self.key = input.key
		end

		if input.value ~= nil then
			self.value = messages.StringFormat_FormatArg.jsonDecode(input.value)
		end

		return self
	end

	_StringFormat_ArgsEntryImpl.descriptor = {
		name = "StringFormat_ArgsEntry",
		fullName = "roblox.apppageplatform.shared.v1beta1.ArgsEntry",
	}

	messages.StringFormat_ArgsEntry = _StringFormat_ArgsEntryImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.StringFormat_ArgsEntry)
end

do
	local _StringPropImpl = {}
	_StringPropImpl.__index = _StringPropImpl

	function _StringPropImpl.new(data: _StringPropPartialFields?): StringProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _StringPropImpl :: _StringPropImpl)
	end

	function _StringPropImpl.encode(self: StringProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "format" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _StringPropImpl.decode(input: buffer): StringProp
		local self = _StringPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "format", value = messages.StringFormat.decode(value) }
					continue
				elseif field == 5 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.StringProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _StringPropImpl.jsonEncode(self: StringProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			elseif self.kind.type == "format" then
				output.format = self.kind.value:jsonEncode()
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _StringPropImpl.jsonDecode(input: { [string]: any }): StringProp
		local self = _StringPropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		if input.format ~= nil then
			self.kind = { type = "format", value = messages.StringFormat.jsonDecode(input.format) }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.StringProp_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_StringPropImpl.descriptor = {
		name = "StringProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.StringProp",
	}

	messages.StringProp = _StringPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.StringProp)
end

do
	local _StringProp_ConditionalOptionImpl = {}
	_StringProp_ConditionalOptionImpl.__index = _StringProp_ConditionalOptionImpl

	function _StringProp_ConditionalOptionImpl.new(
		data: _StringProp_ConditionalOptionPartialFields?
	): StringProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _StringProp_ConditionalOptionImpl :: _StringProp_ConditionalOptionImpl)
	end

	function _StringProp_ConditionalOptionImpl.encode(self: StringProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "format" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _StringProp_ConditionalOptionImpl.decode(input: buffer): StringProp_ConditionalOption
		local self = _StringProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				elseif field == 5 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "format", value = messages.StringFormat.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _StringProp_ConditionalOptionImpl.jsonEncode(self: StringProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			elseif self.kind.type == "format" then
				output.format = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _StringProp_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): StringProp_ConditionalOption
		local self = _StringProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		if input.format ~= nil then
			self.kind = { type = "format", value = messages.StringFormat.jsonDecode(input.format) }
		end

		return self
	end

	_StringProp_ConditionalOptionImpl.descriptor = {
		name = "StringProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.StringProp_ConditionalOption = _StringProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.StringProp_ConditionalOption)
end

do
	local _StringProp_ConditionalOptionsImpl = {}
	_StringProp_ConditionalOptionsImpl.__index = _StringProp_ConditionalOptionsImpl

	function _StringProp_ConditionalOptionsImpl.new(
		data: _StringProp_ConditionalOptionsPartialFields?
	): StringProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _StringProp_ConditionalOptionsImpl :: _StringProp_ConditionalOptionsImpl)
	end

	function _StringProp_ConditionalOptionsImpl.encode(self: StringProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _StringProp_ConditionalOptionsImpl.decode(input: buffer): StringProp_ConditionalOptions
		local self = _StringProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.StringProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _StringProp_ConditionalOptionsImpl.jsonEncode(self: StringProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _StringProp_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): StringProp_ConditionalOptions
		local self = _StringProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { StringProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.StringProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_StringProp_ConditionalOptionsImpl.descriptor = {
		name = "StringProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.StringProp_ConditionalOptions = _StringProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.StringProp_ConditionalOptions)
end

do
	local _FloatPropImpl = {}
	_FloatPropImpl.__index = _FloatPropImpl

	function _FloatPropImpl.new(data: _FloatPropPartialFields?): FloatProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _FloatPropImpl :: _FloatPropImpl)
	end

	function _FloatPropImpl.encode(self: FloatProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.i32)
				output, cursor = proto.writeFloat(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _FloatPropImpl.decode(input: buffer): FloatProp
		local self = _FloatPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.FloatProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				if field == 1 then
					local value
					value, cursor = proto.readFloat(input, cursor)
					self.kind = { type = "literal", value = value }
					continue
				end

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _FloatPropImpl.jsonEncode(self: FloatProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = proto.json.serializeNumber(self.kind.value)
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _FloatPropImpl.jsonDecode(input: { [string]: any }): FloatProp
		local self = _FloatPropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = proto.json.deserializeNumber(input.literal) }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.FloatProp_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_FloatPropImpl.descriptor = {
		name = "FloatProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.FloatProp",
	}

	messages.FloatProp = _FloatPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.FloatProp)
end

do
	local _FloatProp_ConditionalOptionImpl = {}
	_FloatProp_ConditionalOptionImpl.__index = _FloatProp_ConditionalOptionImpl

	function _FloatProp_ConditionalOptionImpl.new(
		data: _FloatProp_ConditionalOptionPartialFields?
	): FloatProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _FloatProp_ConditionalOptionImpl :: _FloatProp_ConditionalOptionImpl)
	end

	function _FloatProp_ConditionalOptionImpl.encode(self: FloatProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.i32)
				output, cursor = proto.writeFloat(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _FloatProp_ConditionalOptionImpl.decode(input: buffer): FloatProp_ConditionalOption
		local self = _FloatProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				if field == 2 then
					local value
					value, cursor = proto.readFloat(input, cursor)
					self.kind = { type = "literal", value = value }
					continue
				end

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _FloatProp_ConditionalOptionImpl.jsonEncode(self: FloatProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = proto.json.serializeNumber(self.kind.value)
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			end
		end

		return output
	end

	function _FloatProp_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): FloatProp_ConditionalOption
		local self = _FloatProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = proto.json.deserializeNumber(input.literal) }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		return self
	end

	_FloatProp_ConditionalOptionImpl.descriptor = {
		name = "FloatProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.FloatProp_ConditionalOption = _FloatProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.FloatProp_ConditionalOption)
end

do
	local _FloatProp_ConditionalOptionsImpl = {}
	_FloatProp_ConditionalOptionsImpl.__index = _FloatProp_ConditionalOptionsImpl

	function _FloatProp_ConditionalOptionsImpl.new(
		data: _FloatProp_ConditionalOptionsPartialFields?
	): FloatProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _FloatProp_ConditionalOptionsImpl :: _FloatProp_ConditionalOptionsImpl)
	end

	function _FloatProp_ConditionalOptionsImpl.encode(self: FloatProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _FloatProp_ConditionalOptionsImpl.decode(input: buffer): FloatProp_ConditionalOptions
		local self = _FloatProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.FloatProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _FloatProp_ConditionalOptionsImpl.jsonEncode(self: FloatProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _FloatProp_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): FloatProp_ConditionalOptions
		local self = _FloatProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { FloatProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.FloatProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_FloatProp_ConditionalOptionsImpl.descriptor = {
		name = "FloatProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.FloatProp_ConditionalOptions = _FloatProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.FloatProp_ConditionalOptions)
end

do
	local _DoublePropImpl = {}
	_DoublePropImpl.__index = _DoublePropImpl

	function _DoublePropImpl.new(data: _DoublePropPartialFields?): DoubleProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _DoublePropImpl :: _DoublePropImpl)
	end

	function _DoublePropImpl.encode(self: DoubleProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.i64)
				output, cursor = proto.writeDouble(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _DoublePropImpl.decode(input: buffer): DoubleProp
		local self = _DoublePropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.DoubleProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				if field == 1 then
					local value
					value, cursor = proto.readDouble(input, cursor)
					self.kind = { type = "literal", value = value }
					continue
				end

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _DoublePropImpl.jsonEncode(self: DoubleProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = proto.json.serializeNumber(self.kind.value)
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _DoublePropImpl.jsonDecode(input: { [string]: any }): DoubleProp
		local self = _DoublePropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = proto.json.deserializeNumber(input.literal) }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.DoubleProp_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_DoublePropImpl.descriptor = {
		name = "DoubleProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.DoubleProp",
	}

	messages.DoubleProp = _DoublePropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.DoubleProp)
end

do
	local _DoubleProp_ConditionalOptionImpl = {}
	_DoubleProp_ConditionalOptionImpl.__index = _DoubleProp_ConditionalOptionImpl

	function _DoubleProp_ConditionalOptionImpl.new(
		data: _DoubleProp_ConditionalOptionPartialFields?
	): DoubleProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _DoubleProp_ConditionalOptionImpl :: _DoubleProp_ConditionalOptionImpl)
	end

	function _DoubleProp_ConditionalOptionImpl.encode(self: DoubleProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.i64)
				output, cursor = proto.writeDouble(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _DoubleProp_ConditionalOptionImpl.decode(input: buffer): DoubleProp_ConditionalOption
		local self = _DoubleProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				if field == 2 then
					local value
					value, cursor = proto.readDouble(input, cursor)
					self.kind = { type = "literal", value = value }
					continue
				end

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _DoubleProp_ConditionalOptionImpl.jsonEncode(self: DoubleProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = proto.json.serializeNumber(self.kind.value)
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			end
		end

		return output
	end

	function _DoubleProp_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): DoubleProp_ConditionalOption
		local self = _DoubleProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = proto.json.deserializeNumber(input.literal) }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		return self
	end

	_DoubleProp_ConditionalOptionImpl.descriptor = {
		name = "DoubleProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.DoubleProp_ConditionalOption = _DoubleProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.DoubleProp_ConditionalOption)
end

do
	local _DoubleProp_ConditionalOptionsImpl = {}
	_DoubleProp_ConditionalOptionsImpl.__index = _DoubleProp_ConditionalOptionsImpl

	function _DoubleProp_ConditionalOptionsImpl.new(
		data: _DoubleProp_ConditionalOptionsPartialFields?
	): DoubleProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _DoubleProp_ConditionalOptionsImpl :: _DoubleProp_ConditionalOptionsImpl)
	end

	function _DoubleProp_ConditionalOptionsImpl.encode(self: DoubleProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _DoubleProp_ConditionalOptionsImpl.decode(input: buffer): DoubleProp_ConditionalOptions
		local self = _DoubleProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.DoubleProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _DoubleProp_ConditionalOptionsImpl.jsonEncode(self: DoubleProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _DoubleProp_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): DoubleProp_ConditionalOptions
		local self = _DoubleProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { DoubleProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.DoubleProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_DoubleProp_ConditionalOptionsImpl.descriptor = {
		name = "DoubleProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.DoubleProp_ConditionalOptions = _DoubleProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.DoubleProp_ConditionalOptions)
end

do
	local _Int32PropImpl = {}
	_Int32PropImpl.__index = _Int32PropImpl

	function _Int32PropImpl.new(data: _Int32PropPartialFields?): Int32Prop
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _Int32PropImpl :: _Int32PropImpl)
	end

	function _Int32PropImpl.encode(self: Int32Prop): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
				output, cursor = proto.writeVarInt(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _Int32PropImpl.decode(input: buffer): Int32Prop
		local self = _Int32PropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.kind = { type = "literal", value = value }
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.Int32Prop_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _Int32PropImpl.jsonEncode(self: Int32Prop): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _Int32PropImpl.jsonDecode(input: { [string]: any }): Int32Prop
		local self = _Int32PropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.Int32Prop_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_Int32PropImpl.descriptor = {
		name = "Int32Prop",
		fullName = "roblox.apppageplatform.shared.v1beta1.Int32Prop",
	}

	messages.Int32Prop = _Int32PropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Int32Prop)
end

do
	local _Int32Prop_ConditionalOptionImpl = {}
	_Int32Prop_ConditionalOptionImpl.__index = _Int32Prop_ConditionalOptionImpl

	function _Int32Prop_ConditionalOptionImpl.new(
		data: _Int32Prop_ConditionalOptionPartialFields?
	): Int32Prop_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _Int32Prop_ConditionalOptionImpl :: _Int32Prop_ConditionalOptionImpl)
	end

	function _Int32Prop_ConditionalOptionImpl.encode(self: Int32Prop_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
				output, cursor = proto.writeVarInt(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _Int32Prop_ConditionalOptionImpl.decode(input: buffer): Int32Prop_ConditionalOption
		local self = _Int32Prop_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 2 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.kind = { type = "literal", value = value }
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _Int32Prop_ConditionalOptionImpl.jsonEncode(self: Int32Prop_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			end
		end

		return output
	end

	function _Int32Prop_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): Int32Prop_ConditionalOption
		local self = _Int32Prop_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		return self
	end

	_Int32Prop_ConditionalOptionImpl.descriptor = {
		name = "Int32Prop_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.Int32Prop_ConditionalOption = _Int32Prop_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Int32Prop_ConditionalOption)
end

do
	local _Int32Prop_ConditionalOptionsImpl = {}
	_Int32Prop_ConditionalOptionsImpl.__index = _Int32Prop_ConditionalOptionsImpl

	function _Int32Prop_ConditionalOptionsImpl.new(
		data: _Int32Prop_ConditionalOptionsPartialFields?
	): Int32Prop_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _Int32Prop_ConditionalOptionsImpl :: _Int32Prop_ConditionalOptionsImpl)
	end

	function _Int32Prop_ConditionalOptionsImpl.encode(self: Int32Prop_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _Int32Prop_ConditionalOptionsImpl.decode(input: buffer): Int32Prop_ConditionalOptions
		local self = _Int32Prop_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.Int32Prop_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _Int32Prop_ConditionalOptionsImpl.jsonEncode(self: Int32Prop_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _Int32Prop_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): Int32Prop_ConditionalOptions
		local self = _Int32Prop_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { Int32Prop_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.Int32Prop_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_Int32Prop_ConditionalOptionsImpl.descriptor = {
		name = "Int32Prop_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.Int32Prop_ConditionalOptions = _Int32Prop_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Int32Prop_ConditionalOptions)
end

do
	local _Int64PropImpl = {}
	_Int64PropImpl.__index = _Int64PropImpl

	function _Int64PropImpl.new(data: _Int64PropPartialFields?): Int64Prop
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _Int64PropImpl :: _Int64PropImpl)
	end

	function _Int64PropImpl.encode(self: Int64Prop): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
				output, cursor = proto.writeVarInt(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _Int64PropImpl.decode(input: buffer): Int64Prop
		local self = _Int64PropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI64(input, cursor)
					self.kind = { type = "literal", value = value }
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.Int64Prop_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _Int64PropImpl.jsonEncode(self: Int64Prop): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _Int64PropImpl.jsonDecode(input: { [string]: any }): Int64Prop
		local self = _Int64PropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.Int64Prop_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_Int64PropImpl.descriptor = {
		name = "Int64Prop",
		fullName = "roblox.apppageplatform.shared.v1beta1.Int64Prop",
	}

	messages.Int64Prop = _Int64PropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Int64Prop)
end

do
	local _Int64Prop_ConditionalOptionImpl = {}
	_Int64Prop_ConditionalOptionImpl.__index = _Int64Prop_ConditionalOptionImpl

	function _Int64Prop_ConditionalOptionImpl.new(
		data: _Int64Prop_ConditionalOptionPartialFields?
	): Int64Prop_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _Int64Prop_ConditionalOptionImpl :: _Int64Prop_ConditionalOptionImpl)
	end

	function _Int64Prop_ConditionalOptionImpl.encode(self: Int64Prop_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
				output, cursor = proto.writeVarInt(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _Int64Prop_ConditionalOptionImpl.decode(input: buffer): Int64Prop_ConditionalOption
		local self = _Int64Prop_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 2 then
					local value
					value, cursor = proto.readVarIntI64(input, cursor)
					self.kind = { type = "literal", value = value }
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _Int64Prop_ConditionalOptionImpl.jsonEncode(self: Int64Prop_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			end
		end

		return output
	end

	function _Int64Prop_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): Int64Prop_ConditionalOption
		local self = _Int64Prop_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		return self
	end

	_Int64Prop_ConditionalOptionImpl.descriptor = {
		name = "Int64Prop_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.Int64Prop_ConditionalOption = _Int64Prop_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Int64Prop_ConditionalOption)
end

do
	local _Int64Prop_ConditionalOptionsImpl = {}
	_Int64Prop_ConditionalOptionsImpl.__index = _Int64Prop_ConditionalOptionsImpl

	function _Int64Prop_ConditionalOptionsImpl.new(
		data: _Int64Prop_ConditionalOptionsPartialFields?
	): Int64Prop_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _Int64Prop_ConditionalOptionsImpl :: _Int64Prop_ConditionalOptionsImpl)
	end

	function _Int64Prop_ConditionalOptionsImpl.encode(self: Int64Prop_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _Int64Prop_ConditionalOptionsImpl.decode(input: buffer): Int64Prop_ConditionalOptions
		local self = _Int64Prop_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.Int64Prop_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _Int64Prop_ConditionalOptionsImpl.jsonEncode(self: Int64Prop_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _Int64Prop_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): Int64Prop_ConditionalOptions
		local self = _Int64Prop_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { Int64Prop_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.Int64Prop_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_Int64Prop_ConditionalOptionsImpl.descriptor = {
		name = "Int64Prop_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.Int64Prop_ConditionalOptions = _Int64Prop_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Int64Prop_ConditionalOptions)
end

do
	local _BoolPropImpl = {}
	_BoolPropImpl.__index = _BoolPropImpl

	function _BoolPropImpl.new(data: _BoolPropPartialFields?): BoolProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _BoolPropImpl :: _BoolPropImpl)
	end

	function _BoolPropImpl.encode(self: BoolProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
				output, cursor = proto.writeVarInt(output, cursor, if self.kind.value then 1 else 0)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _BoolPropImpl.decode(input: buffer): BoolProp
		local self = _BoolPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarInt(input, cursor)
					self.kind = { type = "literal", value = value ~= 0 }
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.BoolProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _BoolPropImpl.jsonEncode(self: BoolProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _BoolPropImpl.jsonDecode(input: { [string]: any }): BoolProp
		local self = _BoolPropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.BoolProp_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_BoolPropImpl.descriptor = {
		name = "BoolProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.BoolProp",
	}

	messages.BoolProp = _BoolPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.BoolProp)
end

do
	local _BoolProp_ConditionalOptionImpl = {}
	_BoolProp_ConditionalOptionImpl.__index = _BoolProp_ConditionalOptionImpl

	function _BoolProp_ConditionalOptionImpl.new(
		data: _BoolProp_ConditionalOptionPartialFields?
	): BoolProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _BoolProp_ConditionalOptionImpl :: _BoolProp_ConditionalOptionImpl)
	end

	function _BoolProp_ConditionalOptionImpl.encode(self: BoolProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
				output, cursor = proto.writeVarInt(output, cursor, if self.kind.value then 1 else 0)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _BoolProp_ConditionalOptionImpl.decode(input: buffer): BoolProp_ConditionalOption
		local self = _BoolProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 2 then
					local value
					value, cursor = proto.readVarInt(input, cursor)
					self.kind = { type = "literal", value = value ~= 0 }
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _BoolProp_ConditionalOptionImpl.jsonEncode(self: BoolProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			end
		end

		return output
	end

	function _BoolProp_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): BoolProp_ConditionalOption
		local self = _BoolProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		return self
	end

	_BoolProp_ConditionalOptionImpl.descriptor = {
		name = "BoolProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.BoolProp_ConditionalOption = _BoolProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.BoolProp_ConditionalOption)
end

do
	local _BoolProp_ConditionalOptionsImpl = {}
	_BoolProp_ConditionalOptionsImpl.__index = _BoolProp_ConditionalOptionsImpl

	function _BoolProp_ConditionalOptionsImpl.new(
		data: _BoolProp_ConditionalOptionsPartialFields?
	): BoolProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _BoolProp_ConditionalOptionsImpl :: _BoolProp_ConditionalOptionsImpl)
	end

	function _BoolProp_ConditionalOptionsImpl.encode(self: BoolProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _BoolProp_ConditionalOptionsImpl.decode(input: buffer): BoolProp_ConditionalOptions
		local self = _BoolProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.BoolProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _BoolProp_ConditionalOptionsImpl.jsonEncode(self: BoolProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _BoolProp_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): BoolProp_ConditionalOptions
		local self = _BoolProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { BoolProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.BoolProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_BoolProp_ConditionalOptionsImpl.descriptor = {
		name = "BoolProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.BoolProp_ConditionalOptions = _BoolProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.BoolProp_ConditionalOptions)
end

do
	local _StructPropImpl = {}
	_StructPropImpl.__index = _StructPropImpl

	function _StructPropImpl.new(data: _StructPropPartialFields?): StructProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _StructPropImpl :: _StructPropImpl)
	end

	function _StructPropImpl.encode(self: StructProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _StructPropImpl.decode(input: buffer): StructProp
		local self = _StructPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = _google_protobuf_struct.Struct.decode(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.StructProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _StructPropImpl.jsonEncode(self: StructProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value:jsonEncode()
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _StructPropImpl.jsonDecode(input: { [string]: any }): StructProp
		local self = _StructPropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = _google_protobuf_struct.Struct.jsonDecode(input.literal) }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.StructProp_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_StructPropImpl.descriptor = {
		name = "StructProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.StructProp",
	}

	messages.StructProp = _StructPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.StructProp)
end

do
	local _StructProp_ConditionalOptionImpl = {}
	_StructProp_ConditionalOptionImpl.__index = _StructProp_ConditionalOptionImpl

	function _StructProp_ConditionalOptionImpl.new(
		data: _StructProp_ConditionalOptionPartialFields?
	): StructProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _StructProp_ConditionalOptionImpl :: _StructProp_ConditionalOptionImpl)
	end

	function _StructProp_ConditionalOptionImpl.encode(self: StructProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _StructProp_ConditionalOptionImpl.decode(input: buffer): StructProp_ConditionalOption
		local self = _StructProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = _google_protobuf_struct.Struct.decode(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _StructProp_ConditionalOptionImpl.jsonEncode(self: StructProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value:jsonEncode()
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			end
		end

		return output
	end

	function _StructProp_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): StructProp_ConditionalOption
		local self = _StructProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = _google_protobuf_struct.Struct.jsonDecode(input.literal) }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		return self
	end

	_StructProp_ConditionalOptionImpl.descriptor = {
		name = "StructProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.StructProp_ConditionalOption = _StructProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.StructProp_ConditionalOption)
end

do
	local _StructProp_ConditionalOptionsImpl = {}
	_StructProp_ConditionalOptionsImpl.__index = _StructProp_ConditionalOptionsImpl

	function _StructProp_ConditionalOptionsImpl.new(
		data: _StructProp_ConditionalOptionsPartialFields?
	): StructProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _StructProp_ConditionalOptionsImpl :: _StructProp_ConditionalOptionsImpl)
	end

	function _StructProp_ConditionalOptionsImpl.encode(self: StructProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _StructProp_ConditionalOptionsImpl.decode(input: buffer): StructProp_ConditionalOptions
		local self = _StructProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.StructProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _StructProp_ConditionalOptionsImpl.jsonEncode(self: StructProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _StructProp_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): StructProp_ConditionalOptions
		local self = _StructProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { StructProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.StructProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_StructProp_ConditionalOptionsImpl.descriptor = {
		name = "StructProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.StructProp_ConditionalOptions = _StructProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.StructProp_ConditionalOptions)
end

do
	local _ImageStringPropImpl = {}
	_ImageStringPropImpl.__index = _ImageStringPropImpl

	function _ImageStringPropImpl.new(data: _ImageStringPropPartialFields?): ImageStringProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _ImageStringPropImpl :: _ImageStringPropImpl)
	end

	function _ImageStringPropImpl.encode(self: ImageStringProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "format" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ImageStringPropImpl.decode(input: buffer): ImageStringProp
		local self = _ImageStringPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "format", value = messages.StringFormat.decode(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind =
						{ type = "conditional", value = messages.ImageStringProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ImageStringPropImpl.jsonEncode(self: ImageStringProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "format" then
				output.format = self.kind.value:jsonEncode()
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _ImageStringPropImpl.jsonDecode(input: { [string]: any }): ImageStringProp
		local self = _ImageStringPropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.format ~= nil then
			self.kind = { type = "format", value = messages.StringFormat.jsonDecode(input.format) }
		end

		if input.conditional ~= nil then
			self.kind = {
				type = "conditional",
				value = messages.ImageStringProp_ConditionalOptions.jsonDecode(input.conditional),
			}
		end

		return self
	end

	_ImageStringPropImpl.descriptor = {
		name = "ImageStringProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.ImageStringProp",
	}

	messages.ImageStringProp = _ImageStringPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ImageStringProp)
end

do
	local _ImageStringProp_ConditionalOptionImpl = {}
	_ImageStringProp_ConditionalOptionImpl.__index = _ImageStringProp_ConditionalOptionImpl

	function _ImageStringProp_ConditionalOptionImpl.new(
		data: _ImageStringProp_ConditionalOptionPartialFields?
	): ImageStringProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _ImageStringProp_ConditionalOptionImpl :: _ImageStringProp_ConditionalOptionImpl)
	end

	function _ImageStringProp_ConditionalOptionImpl.encode(self: ImageStringProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "format" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ImageStringProp_ConditionalOptionImpl.decode(input: buffer): ImageStringProp_ConditionalOption
		local self = _ImageStringProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "format", value = messages.StringFormat.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ImageStringProp_ConditionalOptionImpl.jsonEncode(self: ImageStringProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "format" then
				output.format = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _ImageStringProp_ConditionalOptionImpl.jsonDecode(
		input: { [string]: any }
	): ImageStringProp_ConditionalOption
		local self = _ImageStringProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.format ~= nil then
			self.kind = { type = "format", value = messages.StringFormat.jsonDecode(input.format) }
		end

		return self
	end

	_ImageStringProp_ConditionalOptionImpl.descriptor = {
		name = "ImageStringProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.ImageStringProp_ConditionalOption = _ImageStringProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ImageStringProp_ConditionalOption)
end

do
	local _ImageStringProp_ConditionalOptionsImpl = {}
	_ImageStringProp_ConditionalOptionsImpl.__index = _ImageStringProp_ConditionalOptionsImpl

	function _ImageStringProp_ConditionalOptionsImpl.new(
		data: _ImageStringProp_ConditionalOptionsPartialFields?
	): ImageStringProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _ImageStringProp_ConditionalOptionsImpl :: _ImageStringProp_ConditionalOptionsImpl)
	end

	function _ImageStringProp_ConditionalOptionsImpl.encode(self: ImageStringProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ImageStringProp_ConditionalOptionsImpl.decode(input: buffer): ImageStringProp_ConditionalOptions
		local self = _ImageStringProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.ImageStringProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ImageStringProp_ConditionalOptionsImpl.jsonEncode(self: ImageStringProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _ImageStringProp_ConditionalOptionsImpl.jsonDecode(
		input: { [string]: any }
	): ImageStringProp_ConditionalOptions
		local self = _ImageStringProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { ImageStringProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.ImageStringProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_ImageStringProp_ConditionalOptionsImpl.descriptor = {
		name = "ImageStringProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.ImageStringProp_ConditionalOptions = _ImageStringProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ImageStringProp_ConditionalOptions)
end

do
	local _ImageSetPropImpl = {}
	_ImageSetPropImpl.__index = _ImageSetPropImpl

	function _ImageSetPropImpl.new(data: _ImageSetPropPartialFields?): ImageSetProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _ImageSetPropImpl :: _ImageSetPropImpl)
	end

	function _ImageSetPropImpl.encode(self: ImageSetProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "format" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ImageSetPropImpl.decode(input: buffer): ImageSetProp
		local self = _ImageSetPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "format", value = messages.StringFormat.decode(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.ImageSetProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ImageSetPropImpl.jsonEncode(self: ImageSetProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "format" then
				output.format = self.kind.value:jsonEncode()
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _ImageSetPropImpl.jsonDecode(input: { [string]: any }): ImageSetProp
		local self = _ImageSetPropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.format ~= nil then
			self.kind = { type = "format", value = messages.StringFormat.jsonDecode(input.format) }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.ImageSetProp_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_ImageSetPropImpl.descriptor = {
		name = "ImageSetProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.ImageSetProp",
	}

	messages.ImageSetProp = _ImageSetPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ImageSetProp)
end

do
	local _ImageSetProp_ConditionalOptionImpl = {}
	_ImageSetProp_ConditionalOptionImpl.__index = _ImageSetProp_ConditionalOptionImpl

	function _ImageSetProp_ConditionalOptionImpl.new(
		data: _ImageSetProp_ConditionalOptionPartialFields?
	): ImageSetProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _ImageSetProp_ConditionalOptionImpl :: _ImageSetProp_ConditionalOptionImpl)
	end

	function _ImageSetProp_ConditionalOptionImpl.encode(self: ImageSetProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "format" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ImageSetProp_ConditionalOptionImpl.decode(input: buffer): ImageSetProp_ConditionalOption
		local self = _ImageSetProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "format", value = messages.StringFormat.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ImageSetProp_ConditionalOptionImpl.jsonEncode(self: ImageSetProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "format" then
				output.format = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _ImageSetProp_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): ImageSetProp_ConditionalOption
		local self = _ImageSetProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.format ~= nil then
			self.kind = { type = "format", value = messages.StringFormat.jsonDecode(input.format) }
		end

		return self
	end

	_ImageSetProp_ConditionalOptionImpl.descriptor = {
		name = "ImageSetProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.ImageSetProp_ConditionalOption = _ImageSetProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ImageSetProp_ConditionalOption)
end

do
	local _ImageSetProp_ConditionalOptionsImpl = {}
	_ImageSetProp_ConditionalOptionsImpl.__index = _ImageSetProp_ConditionalOptionsImpl

	function _ImageSetProp_ConditionalOptionsImpl.new(
		data: _ImageSetProp_ConditionalOptionsPartialFields?
	): ImageSetProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _ImageSetProp_ConditionalOptionsImpl :: _ImageSetProp_ConditionalOptionsImpl)
	end

	function _ImageSetProp_ConditionalOptionsImpl.encode(self: ImageSetProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ImageSetProp_ConditionalOptionsImpl.decode(input: buffer): ImageSetProp_ConditionalOptions
		local self = _ImageSetProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.ImageSetProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ImageSetProp_ConditionalOptionsImpl.jsonEncode(self: ImageSetProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _ImageSetProp_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): ImageSetProp_ConditionalOptions
		local self = _ImageSetProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { ImageSetProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.ImageSetProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_ImageSetProp_ConditionalOptionsImpl.descriptor = {
		name = "ImageSetProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.ImageSetProp_ConditionalOptions = _ImageSetProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ImageSetProp_ConditionalOptions)
end

do
	local _ColorPropImpl = {}
	_ColorPropImpl.__index = _ColorPropImpl

	function _ColorPropImpl.new(data: _ColorPropPartialFields?): ColorProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _ColorPropImpl :: _ColorPropImpl)
	end

	function _ColorPropImpl.encode(self: ColorProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ColorPropImpl.decode(input: buffer): ColorProp
		local self = _ColorPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.ColorProp_ConditionalOptions.decode(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ColorPropImpl.jsonEncode(self: ColorProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			end
		end

		return output
	end

	function _ColorPropImpl.jsonDecode(input: { [string]: any }): ColorProp
		local self = _ColorPropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.ColorProp_ConditionalOptions.jsonDecode(input.conditional) }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		return self
	end

	_ColorPropImpl.descriptor = {
		name = "ColorProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.ColorProp",
	}

	messages.ColorProp = _ColorPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ColorProp)
end

do
	local _ColorProp_ConditionalOptionImpl = {}
	_ColorProp_ConditionalOptionImpl.__index = _ColorProp_ConditionalOptionImpl

	function _ColorProp_ConditionalOptionImpl.new(
		data: _ColorProp_ConditionalOptionPartialFields?
	): ColorProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _ColorProp_ConditionalOptionImpl :: _ColorProp_ConditionalOptionImpl)
	end

	function _ColorProp_ConditionalOptionImpl.encode(self: ColorProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ColorProp_ConditionalOptionImpl.decode(input: buffer): ColorProp_ConditionalOption
		local self = _ColorProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ColorProp_ConditionalOptionImpl.jsonEncode(self: ColorProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			end
		end

		return output
	end

	function _ColorProp_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): ColorProp_ConditionalOption
		local self = _ColorProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		return self
	end

	_ColorProp_ConditionalOptionImpl.descriptor = {
		name = "ColorProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.ColorProp_ConditionalOption = _ColorProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ColorProp_ConditionalOption)
end

do
	local _ColorProp_ConditionalOptionsImpl = {}
	_ColorProp_ConditionalOptionsImpl.__index = _ColorProp_ConditionalOptionsImpl

	function _ColorProp_ConditionalOptionsImpl.new(
		data: _ColorProp_ConditionalOptionsPartialFields?
	): ColorProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _ColorProp_ConditionalOptionsImpl :: _ColorProp_ConditionalOptionsImpl)
	end

	function _ColorProp_ConditionalOptionsImpl.encode(self: ColorProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ColorProp_ConditionalOptionsImpl.decode(input: buffer): ColorProp_ConditionalOptions
		local self = _ColorProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.ColorProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ColorProp_ConditionalOptionsImpl.jsonEncode(self: ColorProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _ColorProp_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): ColorProp_ConditionalOptions
		local self = _ColorProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { ColorProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.ColorProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_ColorProp_ConditionalOptionsImpl.descriptor = {
		name = "ColorProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.ColorProp_ConditionalOptions = _ColorProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ColorProp_ConditionalOptions)
end

do
	local _TypographyPropImpl = {}
	_TypographyPropImpl.__index = _TypographyPropImpl

	function _TypographyPropImpl.new(data: _TypographyPropPartialFields?): TypographyProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _TypographyPropImpl :: _TypographyPropImpl)
	end

	function _TypographyPropImpl.encode(self: TypographyProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _TypographyPropImpl.decode(input: buffer): TypographyProp
		local self = _TypographyPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind =
						{ type = "conditional", value = messages.TypographyProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _TypographyPropImpl.jsonEncode(self: TypographyProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "token" then
				output.token = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _TypographyPropImpl.jsonDecode(input: { [string]: any }): TypographyProp
		local self = _TypographyPropImpl.new()

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		if input.conditional ~= nil then
			self.kind = {
				type = "conditional",
				value = messages.TypographyProp_ConditionalOptions.jsonDecode(input.conditional),
			}
		end

		return self
	end

	_TypographyPropImpl.descriptor = {
		name = "TypographyProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.TypographyProp",
	}

	messages.TypographyProp = _TypographyPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.TypographyProp)
end

do
	local _TypographyProp_ConditionalOptionImpl = {}
	_TypographyProp_ConditionalOptionImpl.__index = _TypographyProp_ConditionalOptionImpl

	function _TypographyProp_ConditionalOptionImpl.new(
		data: _TypographyProp_ConditionalOptionPartialFields?
	): TypographyProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			token = if data == nil or data.token == nil then "" else data.token,
		}, _TypographyProp_ConditionalOptionImpl :: _TypographyProp_ConditionalOptionImpl)
	end

	function _TypographyProp_ConditionalOptionImpl.encode(self: TypographyProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.token ~= nil and self.token ~= "" then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.token)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _TypographyProp_ConditionalOptionImpl.decode(input: buffer): TypographyProp_ConditionalOption
		local self = _TypographyProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.token = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _TypographyProp_ConditionalOptionImpl.jsonEncode(self: TypographyProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.token ~= nil and self.token ~= "" then
			output.token = self.token
		end

		return output
	end

	function _TypographyProp_ConditionalOptionImpl.jsonDecode(
		input: { [string]: any }
	): TypographyProp_ConditionalOption
		local self = _TypographyProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.token ~= nil then
			self.token = input.token
		end

		return self
	end

	_TypographyProp_ConditionalOptionImpl.descriptor = {
		name = "TypographyProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.TypographyProp_ConditionalOption = _TypographyProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.TypographyProp_ConditionalOption)
end

do
	local _TypographyProp_ConditionalOptionsImpl = {}
	_TypographyProp_ConditionalOptionsImpl.__index = _TypographyProp_ConditionalOptionsImpl

	function _TypographyProp_ConditionalOptionsImpl.new(
		data: _TypographyProp_ConditionalOptionsPartialFields?
	): TypographyProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _TypographyProp_ConditionalOptionsImpl :: _TypographyProp_ConditionalOptionsImpl)
	end

	function _TypographyProp_ConditionalOptionsImpl.encode(self: TypographyProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _TypographyProp_ConditionalOptionsImpl.decode(input: buffer): TypographyProp_ConditionalOptions
		local self = _TypographyProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.TypographyProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _TypographyProp_ConditionalOptionsImpl.jsonEncode(self: TypographyProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _TypographyProp_ConditionalOptionsImpl.jsonDecode(
		input: { [string]: any }
	): TypographyProp_ConditionalOptions
		local self = _TypographyProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { TypographyProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.TypographyProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_TypographyProp_ConditionalOptionsImpl.descriptor = {
		name = "TypographyProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.TypographyProp_ConditionalOptions = _TypographyProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.TypographyProp_ConditionalOptions)
end

do
	local _TypographyFontPropImpl = {}
	_TypographyFontPropImpl.__index = _TypographyFontPropImpl

	function _TypographyFontPropImpl.new(data: _TypographyFontPropPartialFields?): TypographyFontProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _TypographyFontPropImpl :: _TypographyFontPropImpl)
	end

	function _TypographyFontPropImpl.encode(self: TypographyFontProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _TypographyFontPropImpl.decode(input: buffer): TypographyFontProp
		local self = _TypographyFontPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind =
						{ type = "conditional", value = messages.TypographyFontProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _TypographyFontPropImpl.jsonEncode(self: TypographyFontProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "token" then
				output.token = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _TypographyFontPropImpl.jsonDecode(input: { [string]: any }): TypographyFontProp
		local self = _TypographyFontPropImpl.new()

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		if input.conditional ~= nil then
			self.kind = {
				type = "conditional",
				value = messages.TypographyFontProp_ConditionalOptions.jsonDecode(input.conditional),
			}
		end

		return self
	end

	_TypographyFontPropImpl.descriptor = {
		name = "TypographyFontProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.TypographyFontProp",
	}

	messages.TypographyFontProp = _TypographyFontPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.TypographyFontProp)
end

do
	local _TypographyFontProp_ConditionalOptionImpl = {}
	_TypographyFontProp_ConditionalOptionImpl.__index = _TypographyFontProp_ConditionalOptionImpl

	function _TypographyFontProp_ConditionalOptionImpl.new(
		data: _TypographyFontProp_ConditionalOptionPartialFields?
	): TypographyFontProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			token = if data == nil or data.token == nil then "" else data.token,
		}, _TypographyFontProp_ConditionalOptionImpl :: _TypographyFontProp_ConditionalOptionImpl)
	end

	function _TypographyFontProp_ConditionalOptionImpl.encode(self: TypographyFontProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.token ~= nil and self.token ~= "" then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.token)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _TypographyFontProp_ConditionalOptionImpl.decode(input: buffer): TypographyFontProp_ConditionalOption
		local self = _TypographyFontProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.token = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _TypographyFontProp_ConditionalOptionImpl.jsonEncode(self: TypographyFontProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.token ~= nil and self.token ~= "" then
			output.token = self.token
		end

		return output
	end

	function _TypographyFontProp_ConditionalOptionImpl.jsonDecode(
		input: { [string]: any }
	): TypographyFontProp_ConditionalOption
		local self = _TypographyFontProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.token ~= nil then
			self.token = input.token
		end

		return self
	end

	_TypographyFontProp_ConditionalOptionImpl.descriptor = {
		name = "TypographyFontProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.TypographyFontProp_ConditionalOption = _TypographyFontProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.TypographyFontProp_ConditionalOption)
end

do
	local _TypographyFontProp_ConditionalOptionsImpl = {}
	_TypographyFontProp_ConditionalOptionsImpl.__index = _TypographyFontProp_ConditionalOptionsImpl

	function _TypographyFontProp_ConditionalOptionsImpl.new(
		data: _TypographyFontProp_ConditionalOptionsPartialFields?
	): TypographyFontProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _TypographyFontProp_ConditionalOptionsImpl :: _TypographyFontProp_ConditionalOptionsImpl)
	end

	function _TypographyFontProp_ConditionalOptionsImpl.encode(self: TypographyFontProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _TypographyFontProp_ConditionalOptionsImpl.decode(input: buffer): TypographyFontProp_ConditionalOptions
		local self = _TypographyFontProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.TypographyFontProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _TypographyFontProp_ConditionalOptionsImpl.jsonEncode(self: TypographyFontProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _TypographyFontProp_ConditionalOptionsImpl.jsonDecode(
		input: { [string]: any }
	): TypographyFontProp_ConditionalOptions
		local self = _TypographyFontProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { TypographyFontProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.TypographyFontProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_TypographyFontProp_ConditionalOptionsImpl.descriptor = {
		name = "TypographyFontProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.TypographyFontProp_ConditionalOptions = _TypographyFontProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.TypographyFontProp_ConditionalOptions)
end

do
	local _UDimPropImpl = {}
	_UDimPropImpl.__index = _UDimPropImpl

	function _UDimPropImpl.new(data: _UDimPropPartialFields?): UDimProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _UDimPropImpl :: _UDimPropImpl)
	end

	function _UDimPropImpl.encode(self: UDimProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _UDimPropImpl.decode(input: buffer): UDimProp
		local self = _UDimPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.UDimProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _UDimPropImpl.jsonEncode(self: UDimProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _UDimPropImpl.jsonDecode(input: { [string]: any }): UDimProp
		local self = _UDimPropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.UDimProp_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_UDimPropImpl.descriptor = {
		name = "UDimProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.UDimProp",
	}

	messages.UDimProp = _UDimPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.UDimProp)
end

do
	local _UDimProp_ConditionalOptionImpl = {}
	_UDimProp_ConditionalOptionImpl.__index = _UDimProp_ConditionalOptionImpl

	function _UDimProp_ConditionalOptionImpl.new(
		data: _UDimProp_ConditionalOptionPartialFields?
	): UDimProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _UDimProp_ConditionalOptionImpl :: _UDimProp_ConditionalOptionImpl)
	end

	function _UDimProp_ConditionalOptionImpl.encode(self: UDimProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _UDimProp_ConditionalOptionImpl.decode(input: buffer): UDimProp_ConditionalOption
		local self = _UDimProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _UDimProp_ConditionalOptionImpl.jsonEncode(self: UDimProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			end
		end

		return output
	end

	function _UDimProp_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): UDimProp_ConditionalOption
		local self = _UDimProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		return self
	end

	_UDimProp_ConditionalOptionImpl.descriptor = {
		name = "UDimProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.UDimProp_ConditionalOption = _UDimProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.UDimProp_ConditionalOption)
end

do
	local _UDimProp_ConditionalOptionsImpl = {}
	_UDimProp_ConditionalOptionsImpl.__index = _UDimProp_ConditionalOptionsImpl

	function _UDimProp_ConditionalOptionsImpl.new(
		data: _UDimProp_ConditionalOptionsPartialFields?
	): UDimProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _UDimProp_ConditionalOptionsImpl :: _UDimProp_ConditionalOptionsImpl)
	end

	function _UDimProp_ConditionalOptionsImpl.encode(self: UDimProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _UDimProp_ConditionalOptionsImpl.decode(input: buffer): UDimProp_ConditionalOptions
		local self = _UDimProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.UDimProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _UDimProp_ConditionalOptionsImpl.jsonEncode(self: UDimProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _UDimProp_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): UDimProp_ConditionalOptions
		local self = _UDimProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { UDimProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.UDimProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_UDimProp_ConditionalOptionsImpl.descriptor = {
		name = "UDimProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.UDimProp_ConditionalOptions = _UDimProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.UDimProp_ConditionalOptions)
end

do
	local _UDim2PropImpl = {}
	_UDim2PropImpl.__index = _UDim2PropImpl

	function _UDim2PropImpl.new(data: _UDim2PropPartialFields?): UDim2Prop
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _UDim2PropImpl :: _UDim2PropImpl)
	end

	function _UDim2PropImpl.encode(self: UDim2Prop): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _UDim2PropImpl.decode(input: buffer): UDim2Prop
		local self = _UDim2PropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.UDim2Prop_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _UDim2PropImpl.jsonEncode(self: UDim2Prop): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _UDim2PropImpl.jsonDecode(input: { [string]: any }): UDim2Prop
		local self = _UDim2PropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.UDim2Prop_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_UDim2PropImpl.descriptor = {
		name = "UDim2Prop",
		fullName = "roblox.apppageplatform.shared.v1beta1.UDim2Prop",
	}

	messages.UDim2Prop = _UDim2PropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.UDim2Prop)
end

do
	local _UDim2Prop_ConditionalOptionImpl = {}
	_UDim2Prop_ConditionalOptionImpl.__index = _UDim2Prop_ConditionalOptionImpl

	function _UDim2Prop_ConditionalOptionImpl.new(
		data: _UDim2Prop_ConditionalOptionPartialFields?
	): UDim2Prop_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _UDim2Prop_ConditionalOptionImpl :: _UDim2Prop_ConditionalOptionImpl)
	end

	function _UDim2Prop_ConditionalOptionImpl.encode(self: UDim2Prop_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _UDim2Prop_ConditionalOptionImpl.decode(input: buffer): UDim2Prop_ConditionalOption
		local self = _UDim2Prop_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _UDim2Prop_ConditionalOptionImpl.jsonEncode(self: UDim2Prop_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			end
		end

		return output
	end

	function _UDim2Prop_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): UDim2Prop_ConditionalOption
		local self = _UDim2Prop_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		return self
	end

	_UDim2Prop_ConditionalOptionImpl.descriptor = {
		name = "UDim2Prop_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.UDim2Prop_ConditionalOption = _UDim2Prop_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.UDim2Prop_ConditionalOption)
end

do
	local _UDim2Prop_ConditionalOptionsImpl = {}
	_UDim2Prop_ConditionalOptionsImpl.__index = _UDim2Prop_ConditionalOptionsImpl

	function _UDim2Prop_ConditionalOptionsImpl.new(
		data: _UDim2Prop_ConditionalOptionsPartialFields?
	): UDim2Prop_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _UDim2Prop_ConditionalOptionsImpl :: _UDim2Prop_ConditionalOptionsImpl)
	end

	function _UDim2Prop_ConditionalOptionsImpl.encode(self: UDim2Prop_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _UDim2Prop_ConditionalOptionsImpl.decode(input: buffer): UDim2Prop_ConditionalOptions
		local self = _UDim2Prop_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.UDim2Prop_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _UDim2Prop_ConditionalOptionsImpl.jsonEncode(self: UDim2Prop_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _UDim2Prop_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): UDim2Prop_ConditionalOptions
		local self = _UDim2Prop_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { UDim2Prop_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.UDim2Prop_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_UDim2Prop_ConditionalOptionsImpl.descriptor = {
		name = "UDim2Prop_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.UDim2Prop_ConditionalOptions = _UDim2Prop_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.UDim2Prop_ConditionalOptions)
end

do
	local _Vector2PropImpl = {}
	_Vector2PropImpl.__index = _Vector2PropImpl

	function _Vector2PropImpl.new(data: _Vector2PropPartialFields?): Vector2Prop
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _Vector2PropImpl :: _Vector2PropImpl)
	end

	function _Vector2PropImpl.encode(self: Vector2Prop): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _Vector2PropImpl.decode(input: buffer): Vector2Prop
		local self = _Vector2PropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.Vector2Prop_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _Vector2PropImpl.jsonEncode(self: Vector2Prop): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _Vector2PropImpl.jsonDecode(input: { [string]: any }): Vector2Prop
		local self = _Vector2PropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.Vector2Prop_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_Vector2PropImpl.descriptor = {
		name = "Vector2Prop",
		fullName = "roblox.apppageplatform.shared.v1beta1.Vector2Prop",
	}

	messages.Vector2Prop = _Vector2PropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Vector2Prop)
end

do
	local _Vector2Prop_ConditionalOptionImpl = {}
	_Vector2Prop_ConditionalOptionImpl.__index = _Vector2Prop_ConditionalOptionImpl

	function _Vector2Prop_ConditionalOptionImpl.new(
		data: _Vector2Prop_ConditionalOptionPartialFields?
	): Vector2Prop_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _Vector2Prop_ConditionalOptionImpl :: _Vector2Prop_ConditionalOptionImpl)
	end

	function _Vector2Prop_ConditionalOptionImpl.encode(self: Vector2Prop_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "token" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _Vector2Prop_ConditionalOptionImpl.decode(input: buffer): Vector2Prop_ConditionalOption
		local self = _Vector2Prop_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "token", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _Vector2Prop_ConditionalOptionImpl.jsonEncode(self: Vector2Prop_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "token" then
				output.token = self.kind.value
			end
		end

		return output
	end

	function _Vector2Prop_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): Vector2Prop_ConditionalOption
		local self = _Vector2Prop_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.token ~= nil then
			self.kind = { type = "token", value = input.token }
		end

		return self
	end

	_Vector2Prop_ConditionalOptionImpl.descriptor = {
		name = "Vector2Prop_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.Vector2Prop_ConditionalOption = _Vector2Prop_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Vector2Prop_ConditionalOption)
end

do
	local _Vector2Prop_ConditionalOptionsImpl = {}
	_Vector2Prop_ConditionalOptionsImpl.__index = _Vector2Prop_ConditionalOptionsImpl

	function _Vector2Prop_ConditionalOptionsImpl.new(
		data: _Vector2Prop_ConditionalOptionsPartialFields?
	): Vector2Prop_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _Vector2Prop_ConditionalOptionsImpl :: _Vector2Prop_ConditionalOptionsImpl)
	end

	function _Vector2Prop_ConditionalOptionsImpl.encode(self: Vector2Prop_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _Vector2Prop_ConditionalOptionsImpl.decode(input: buffer): Vector2Prop_ConditionalOptions
		local self = _Vector2Prop_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.Vector2Prop_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _Vector2Prop_ConditionalOptionsImpl.jsonEncode(self: Vector2Prop_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _Vector2Prop_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): Vector2Prop_ConditionalOptions
		local self = _Vector2Prop_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { Vector2Prop_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.Vector2Prop_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_Vector2Prop_ConditionalOptionsImpl.descriptor = {
		name = "Vector2Prop_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.Vector2Prop_ConditionalOptions = _Vector2Prop_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Vector2Prop_ConditionalOptions)
end

do
	local _TemplateArgImpl = {}
	_TemplateArgImpl.__index = _TemplateArgImpl

	function _TemplateArgImpl.new(data: _TemplateArgPartialFields?): TemplateArg
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _TemplateArgImpl :: _TemplateArgImpl)
	end

	function _TemplateArgImpl.encode(self: TemplateArg): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _TemplateArgImpl.decode(input: buffer): TemplateArg
		local self = _TemplateArgImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = messages.TemplateArg_LiteralValue.decode(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _TemplateArgImpl.jsonEncode(self: TemplateArg): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value:jsonEncode()
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			end
		end

		return output
	end

	function _TemplateArgImpl.jsonDecode(input: { [string]: any }): TemplateArg
		local self = _TemplateArgImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = messages.TemplateArg_LiteralValue.jsonDecode(input.literal) }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		return self
	end

	_TemplateArgImpl.descriptor = {
		name = "TemplateArg",
		fullName = "roblox.apppageplatform.shared.v1beta1.TemplateArg",
	}

	messages.TemplateArg = _TemplateArgImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.TemplateArg)
end

do
	local _TemplateArg_LiteralValueImpl = {}
	_TemplateArg_LiteralValueImpl.__index = _TemplateArg_LiteralValueImpl

	function _TemplateArg_LiteralValueImpl.new(data: _TemplateArg_LiteralValuePartialFields?): TemplateArg_LiteralValue
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _TemplateArg_LiteralValueImpl :: _TemplateArg_LiteralValueImpl)
	end

	function _TemplateArg_LiteralValueImpl.encode(self: TemplateArg_LiteralValue): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "string_value" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "int32_value" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
				output, cursor = proto.writeVarInt(output, cursor, self.kind.value)
			elseif self.kind.type == "int64_value" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.varint)
				output, cursor = proto.writeVarInt(output, cursor, self.kind.value)
			elseif self.kind.type == "float_value" then
				output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.i32)
				output, cursor = proto.writeFloat(output, cursor, self.kind.value)
			elseif self.kind.type == "double_value" then
				output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.i64)
				output, cursor = proto.writeDouble(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _TemplateArg_LiteralValueImpl.decode(input: buffer): TemplateArg_LiteralValue
		local self = _TemplateArg_LiteralValueImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 2 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.kind = { type = "int32_value", value = value }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readVarIntI64(input, cursor)
					self.kind = { type = "int64_value", value = value }
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "string_value", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				if field == 4 then
					local value
					value, cursor = proto.readFloat(input, cursor)
					self.kind = { type = "float_value", value = value }
					continue
				end

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				if field == 5 then
					local value
					value, cursor = proto.readDouble(input, cursor)
					self.kind = { type = "double_value", value = value }
					continue
				end

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _TemplateArg_LiteralValueImpl.jsonEncode(self: TemplateArg_LiteralValue): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "string_value" then
				output.stringValue = self.kind.value
			elseif self.kind.type == "int32_value" then
				output.int32Value = self.kind.value
			elseif self.kind.type == "int64_value" then
				output.int64Value = self.kind.value
			elseif self.kind.type == "float_value" then
				output.floatValue = proto.json.serializeNumber(self.kind.value)
			elseif self.kind.type == "double_value" then
				output.doubleValue = proto.json.serializeNumber(self.kind.value)
			end
		end

		return output
	end

	function _TemplateArg_LiteralValueImpl.jsonDecode(input: { [string]: any }): TemplateArg_LiteralValue
		local self = _TemplateArg_LiteralValueImpl.new()

		if input.string_value ~= nil then
			self.kind = { type = "string_value", value = input.string_value }
		end

		if input.stringValue ~= nil then
			self.kind = { type = "string_value", value = input.stringValue }
		end

		if input.int32_value ~= nil then
			self.kind = { type = "int32_value", value = input.int32_value }
		end

		if input.int32Value ~= nil then
			self.kind = { type = "int32_value", value = input.int32Value }
		end

		if input.int64_value ~= nil then
			self.kind = { type = "int64_value", value = input.int64_value }
		end

		if input.int64Value ~= nil then
			self.kind = { type = "int64_value", value = input.int64Value }
		end

		if input.float_value ~= nil then
			self.kind = { type = "float_value", value = proto.json.deserializeNumber(input.float_value) }
		end

		if input.floatValue ~= nil then
			self.kind = { type = "float_value", value = proto.json.deserializeNumber(input.floatValue) }
		end

		if input.double_value ~= nil then
			self.kind = { type = "double_value", value = proto.json.deserializeNumber(input.double_value) }
		end

		if input.doubleValue ~= nil then
			self.kind = { type = "double_value", value = proto.json.deserializeNumber(input.doubleValue) }
		end

		return self
	end

	_TemplateArg_LiteralValueImpl.descriptor = {
		name = "TemplateArg_LiteralValue",
		fullName = "roblox.apppageplatform.shared.v1beta1.LiteralValue",
	}

	messages.TemplateArg_LiteralValue = _TemplateArg_LiteralValueImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.TemplateArg_LiteralValue)
end

do
	local _NestedComponentPropImpl = {}
	_NestedComponentPropImpl.__index = _NestedComponentPropImpl

	function _NestedComponentPropImpl.new(data: _NestedComponentPropPartialFields?): NestedComponentProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _NestedComponentPropImpl :: _NestedComponentPropImpl)
	end

	function _NestedComponentPropImpl.encode(self: NestedComponentProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _NestedComponentPropImpl.decode(input: buffer): NestedComponentProp
		local self = _NestedComponentPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = messages.NestedComponentProp_TemplateData.decode(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind =
						{ type = "conditional", value = messages.NestedComponentProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _NestedComponentPropImpl.jsonEncode(self: NestedComponentProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value:jsonEncode()
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _NestedComponentPropImpl.jsonDecode(input: { [string]: any }): NestedComponentProp
		local self = _NestedComponentPropImpl.new()

		if input.literal ~= nil then
			self.kind =
				{ type = "literal", value = messages.NestedComponentProp_TemplateData.jsonDecode(input.literal) }
		end

		if input.conditional ~= nil then
			self.kind = {
				type = "conditional",
				value = messages.NestedComponentProp_ConditionalOptions.jsonDecode(input.conditional),
			}
		end

		return self
	end

	_NestedComponentPropImpl.descriptor = {
		name = "NestedComponentProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.NestedComponentProp",
	}

	messages.NestedComponentProp = _NestedComponentPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.NestedComponentProp)
end

do
	local _NestedComponentProp_ConditionalOptionImpl = {}
	_NestedComponentProp_ConditionalOptionImpl.__index = _NestedComponentProp_ConditionalOptionImpl

	function _NestedComponentProp_ConditionalOptionImpl.new(
		data: _NestedComponentProp_ConditionalOptionPartialFields?
	): NestedComponentProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			literal = if data == nil or data.literal == nil then nil else data.literal,
		}, _NestedComponentProp_ConditionalOptionImpl :: _NestedComponentProp_ConditionalOptionImpl)
	end

	function _NestedComponentProp_ConditionalOptionImpl.encode(self: NestedComponentProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.literal ~= nil then
			local encoded = self.literal:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _NestedComponentProp_ConditionalOptionImpl.decode(input: buffer): NestedComponentProp_ConditionalOption
		local self = _NestedComponentProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.literal = messages.NestedComponentProp_TemplateData.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _NestedComponentProp_ConditionalOptionImpl.jsonEncode(self: NestedComponentProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.literal ~= nil then
			output.literal = self.literal:jsonEncode()
		end

		return output
	end

	function _NestedComponentProp_ConditionalOptionImpl.jsonDecode(
		input: { [string]: any }
	): NestedComponentProp_ConditionalOption
		local self = _NestedComponentProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.literal = messages.NestedComponentProp_TemplateData.jsonDecode(input.literal)
		end

		return self
	end

	_NestedComponentProp_ConditionalOptionImpl.descriptor = {
		name = "NestedComponentProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.NestedComponentProp_ConditionalOption = _NestedComponentProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.NestedComponentProp_ConditionalOption)
end

do
	local _NestedComponentProp_ConditionalOptionsImpl = {}
	_NestedComponentProp_ConditionalOptionsImpl.__index = _NestedComponentProp_ConditionalOptionsImpl

	function _NestedComponentProp_ConditionalOptionsImpl.new(
		data: _NestedComponentProp_ConditionalOptionsPartialFields?
	): NestedComponentProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _NestedComponentProp_ConditionalOptionsImpl :: _NestedComponentProp_ConditionalOptionsImpl)
	end

	function _NestedComponentProp_ConditionalOptionsImpl.encode(self: NestedComponentProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _NestedComponentProp_ConditionalOptionsImpl.decode(input: buffer): NestedComponentProp_ConditionalOptions
		local self = _NestedComponentProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.NestedComponentProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _NestedComponentProp_ConditionalOptionsImpl.jsonEncode(self: NestedComponentProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _NestedComponentProp_ConditionalOptionsImpl.jsonDecode(
		input: { [string]: any }
	): NestedComponentProp_ConditionalOptions
		local self = _NestedComponentProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { NestedComponentProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.NestedComponentProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_NestedComponentProp_ConditionalOptionsImpl.descriptor = {
		name = "NestedComponentProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.NestedComponentProp_ConditionalOptions = _NestedComponentProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.NestedComponentProp_ConditionalOptions)
end

do
	local _NestedComponentProp_TemplateDataImpl = {}
	_NestedComponentProp_TemplateDataImpl.__index = _NestedComponentProp_TemplateDataImpl

	function _NestedComponentProp_TemplateDataImpl.new(
		data: _NestedComponentProp_TemplateDataPartialFields?
	): NestedComponentProp_TemplateData
		return setmetatable({
			inputs = if data == nil or data.inputs == nil then {} else data.inputs,
			roblox_component = if data == nil or data.roblox_component == nil
				then assert(
					_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(0),
					"Enum has no 0 default"
				)
				else data.roblox_component,
			template_id = if data == nil or data.template_id == nil then "" else data.template_id,
		}, _NestedComponentProp_TemplateDataImpl :: _NestedComponentProp_TemplateDataImpl)
	end

	function _NestedComponentProp_TemplateDataImpl.encode(self: NestedComponentProp_TemplateData): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.inputs ~= nil and next(self.inputs) ~= nil then
			for key, value in self.inputs do
				local mapBuffer = buffer.create(0)
				local mapCursor = 0
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 1, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeString(mapBuffer, mapCursor, key)
				local encoded = value:encode()
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 2, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeBuffer(mapBuffer, mapCursor, encoded, buffer.len(encoded))
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, mapBuffer, mapCursor)
			end
		end

		if
			self.roblox_component ~= nil
			and (
				self.roblox_component ~= nil and self.roblox_component ~= 0
				or self.roblox_component
					~= _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(
				output,
				cursor,
				_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.toNumber(
					self.roblox_component :: any
				)
			)
		end

		if self.template_id ~= nil and self.template_id ~= "" then
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.template_id)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _NestedComponentProp_TemplateDataImpl.decode(input: buffer): NestedComponentProp_TemplateData
		local self = _NestedComponentProp_TemplateDataImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 2 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.roblox_component = (
						_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(
							value
						) or value
					) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)

					local mapEntry = messages.NestedComponentProp_TemplateData_InputsEntry.decode(value)

					local keyDefault = ""
					local valueDefault = messages.TemplateArg.new()

					self.inputs[mapEntry.key or keyDefault] = mapEntry.value or valueDefault

					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.template_id = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _NestedComponentProp_TemplateDataImpl.jsonEncode(self: NestedComponentProp_TemplateData): any
		local output = {}

		if self.inputs ~= nil and next(self.inputs) ~= nil then
			local newOutput = {}
			for key, value in self.inputs do
				newOutput[key] = value:jsonEncode()
			end
			output.inputs = newOutput
		end

		if
			self.roblox_component ~= nil
			and (
				self.roblox_component ~= nil and self.roblox_component ~= 0
				or self.roblox_component
					~= _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(0)
			)
		then
			output.robloxComponent = if typeof(self.roblox_component) == "number"
				then self.roblox_component
				else _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.toNumber(
					self.roblox_component :: any
				)
		end

		if self.template_id ~= nil and self.template_id ~= "" then
			output.templateId = self.template_id
		end

		return output
	end

	function _NestedComponentProp_TemplateDataImpl.jsonDecode(
		input: { [string]: any }
	): NestedComponentProp_TemplateData
		local self = _NestedComponentProp_TemplateDataImpl.new()

		if input.inputs ~= nil then
			local newOutput: { [string]: TemplateArg } = {}
			for key, value in input.inputs do
				newOutput[key] = messages.TemplateArg.jsonDecode(value)
			end

			self.inputs = newOutput
		end

		if input.roblox_component ~= nil then
			self.roblox_component = if typeof(input.roblox_component) == "number"
				then (_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(
					input.roblox_component
				) or input.roblox_component)
				else (_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromName(
					input.roblox_component
				) or input.roblox_component)
		end

		if input.robloxComponent ~= nil then
			self.roblox_component = if typeof(input.robloxComponent) == "number"
				then (_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(
					input.robloxComponent
				) or input.robloxComponent)
				else (_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromName(
					input.robloxComponent
				) or input.robloxComponent)
		end

		if input.template_id ~= nil then
			self.template_id = input.template_id
		end

		if input.templateId ~= nil then
			self.template_id = input.templateId
		end

		return self
	end

	_NestedComponentProp_TemplateDataImpl.descriptor = {
		name = "NestedComponentProp_TemplateData",
		fullName = "roblox.apppageplatform.shared.v1beta1.TemplateData",
	}

	messages.NestedComponentProp_TemplateData = _NestedComponentProp_TemplateDataImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.NestedComponentProp_TemplateData)
end

do
	local _NestedComponentProp_TemplateData_InputsEntryImpl = {}
	_NestedComponentProp_TemplateData_InputsEntryImpl.__index = _NestedComponentProp_TemplateData_InputsEntryImpl

	function _NestedComponentProp_TemplateData_InputsEntryImpl.new(
		data: _NestedComponentProp_TemplateData_InputsEntryPartialFields?
	): NestedComponentProp_TemplateData_InputsEntry
		return setmetatable({
			key = if data == nil or data.key == nil then "" else data.key,
			value = if data == nil or data.value == nil then nil else data.value,
		}, _NestedComponentProp_TemplateData_InputsEntryImpl :: _NestedComponentProp_TemplateData_InputsEntryImpl)
	end

	function _NestedComponentProp_TemplateData_InputsEntryImpl.encode(
		self: NestedComponentProp_TemplateData_InputsEntry
	): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.key ~= nil and self.key ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.key)
		end

		if self.value ~= nil then
			local encoded = self.value:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _NestedComponentProp_TemplateData_InputsEntryImpl.decode(
		input: buffer
	): NestedComponentProp_TemplateData_InputsEntry
		local self = _NestedComponentProp_TemplateData_InputsEntryImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.key = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = messages.TemplateArg.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _NestedComponentProp_TemplateData_InputsEntryImpl.jsonEncode(
		self: NestedComponentProp_TemplateData_InputsEntry
	): any
		local output = {}

		if self.key ~= nil and self.key ~= "" then
			output.key = self.key
		end

		if self.value ~= nil then
			output.value = self.value:jsonEncode()
		end

		return output
	end

	function _NestedComponentProp_TemplateData_InputsEntryImpl.jsonDecode(
		input: { [string]: any }
	): NestedComponentProp_TemplateData_InputsEntry
		local self = _NestedComponentProp_TemplateData_InputsEntryImpl.new()

		if input.key ~= nil then
			self.key = input.key
		end

		if input.value ~= nil then
			self.value = messages.TemplateArg.jsonDecode(input.value)
		end

		return self
	end

	_NestedComponentProp_TemplateData_InputsEntryImpl.descriptor = {
		name = "NestedComponentProp_TemplateData_InputsEntry",
		fullName = "roblox.apppageplatform.shared.v1beta1.InputsEntry",
	}

	messages.NestedComponentProp_TemplateData_InputsEntry = _NestedComponentProp_TemplateData_InputsEntryImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.NestedComponentProp_TemplateData_InputsEntry)
end

do
	local _LazyNestedComponentListPropImpl = {}
	_LazyNestedComponentListPropImpl.__index = _LazyNestedComponentListPropImpl

	function _LazyNestedComponentListPropImpl.new(
		data: _LazyNestedComponentListPropPartialFields?
	): LazyNestedComponentListProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _LazyNestedComponentListPropImpl :: _LazyNestedComponentListPropImpl)
	end

	function _LazyNestedComponentListPropImpl.encode(self: LazyNestedComponentListProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "array_map" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "item_list" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _LazyNestedComponentListPropImpl.decode(input: buffer): LazyNestedComponentListProp
		local self = _LazyNestedComponentListPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind =
						{ type = "array_map", value = messages.LazyNestedComponentListProp_TemplateData.decode(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = {
						type = "item_list",
						value = messages.LazyNestedComponentListProp_TemplateDataList.decode(value),
					}
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = {
						type = "conditional",
						value = messages.LazyNestedComponentListProp_ConditionalOptions.decode(value),
					}
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _LazyNestedComponentListPropImpl.jsonEncode(self: LazyNestedComponentListProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "array_map" then
				output.arrayMap = self.kind.value:jsonEncode()
			elseif self.kind.type == "item_list" then
				output.itemList = self.kind.value:jsonEncode()
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _LazyNestedComponentListPropImpl.jsonDecode(input: { [string]: any }): LazyNestedComponentListProp
		local self = _LazyNestedComponentListPropImpl.new()

		if input.array_map ~= nil then
			self.kind = {
				type = "array_map",
				value = messages.LazyNestedComponentListProp_TemplateData.jsonDecode(input.array_map),
			}
		end

		if input.arrayMap ~= nil then
			self.kind = {
				type = "array_map",
				value = messages.LazyNestedComponentListProp_TemplateData.jsonDecode(input.arrayMap),
			}
		end

		if input.item_list ~= nil then
			self.kind = {
				type = "item_list",
				value = messages.LazyNestedComponentListProp_TemplateDataList.jsonDecode(input.item_list),
			}
		end

		if input.itemList ~= nil then
			self.kind = {
				type = "item_list",
				value = messages.LazyNestedComponentListProp_TemplateDataList.jsonDecode(input.itemList),
			}
		end

		if input.conditional ~= nil then
			self.kind = {
				type = "conditional",
				value = messages.LazyNestedComponentListProp_ConditionalOptions.jsonDecode(input.conditional),
			}
		end

		return self
	end

	_LazyNestedComponentListPropImpl.descriptor = {
		name = "LazyNestedComponentListProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.LazyNestedComponentListProp",
	}

	messages.LazyNestedComponentListProp = _LazyNestedComponentListPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.LazyNestedComponentListProp)
end

do
	local _LazyNestedComponentListProp_ConditionalOptionImpl = {}
	_LazyNestedComponentListProp_ConditionalOptionImpl.__index = _LazyNestedComponentListProp_ConditionalOptionImpl

	function _LazyNestedComponentListProp_ConditionalOptionImpl.new(
		data: _LazyNestedComponentListProp_ConditionalOptionPartialFields?
	): LazyNestedComponentListProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _LazyNestedComponentListProp_ConditionalOptionImpl :: _LazyNestedComponentListProp_ConditionalOptionImpl)
	end

	function _LazyNestedComponentListProp_ConditionalOptionImpl.encode(
		self: LazyNestedComponentListProp_ConditionalOption
	): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "item_list" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _LazyNestedComponentListProp_ConditionalOptionImpl.decode(
		input: buffer
	): LazyNestedComponentListProp_ConditionalOption
		local self = _LazyNestedComponentListProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind =
						{ type = "literal", value = messages.LazyNestedComponentListProp_TemplateData.decode(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = {
						type = "item_list",
						value = messages.LazyNestedComponentListProp_TemplateDataList.decode(value),
					}
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _LazyNestedComponentListProp_ConditionalOptionImpl.jsonEncode(
		self: LazyNestedComponentListProp_ConditionalOption
	): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value:jsonEncode()
			elseif self.kind.type == "item_list" then
				output.itemList = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _LazyNestedComponentListProp_ConditionalOptionImpl.jsonDecode(
		input: { [string]: any }
	): LazyNestedComponentListProp_ConditionalOption
		local self = _LazyNestedComponentListProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind = {
				type = "literal",
				value = messages.LazyNestedComponentListProp_TemplateData.jsonDecode(input.literal),
			}
		end

		if input.item_list ~= nil then
			self.kind = {
				type = "item_list",
				value = messages.LazyNestedComponentListProp_TemplateDataList.jsonDecode(input.item_list),
			}
		end

		if input.itemList ~= nil then
			self.kind = {
				type = "item_list",
				value = messages.LazyNestedComponentListProp_TemplateDataList.jsonDecode(input.itemList),
			}
		end

		return self
	end

	_LazyNestedComponentListProp_ConditionalOptionImpl.descriptor = {
		name = "LazyNestedComponentListProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.LazyNestedComponentListProp_ConditionalOption = _LazyNestedComponentListProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.LazyNestedComponentListProp_ConditionalOption)
end

do
	local _LazyNestedComponentListProp_ConditionalOptionsImpl = {}
	_LazyNestedComponentListProp_ConditionalOptionsImpl.__index = _LazyNestedComponentListProp_ConditionalOptionsImpl

	function _LazyNestedComponentListProp_ConditionalOptionsImpl.new(
		data: _LazyNestedComponentListProp_ConditionalOptionsPartialFields?
	): LazyNestedComponentListProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _LazyNestedComponentListProp_ConditionalOptionsImpl :: _LazyNestedComponentListProp_ConditionalOptionsImpl)
	end

	function _LazyNestedComponentListProp_ConditionalOptionsImpl.encode(
		self: LazyNestedComponentListProp_ConditionalOptions
	): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _LazyNestedComponentListProp_ConditionalOptionsImpl.decode(
		input: buffer
	): LazyNestedComponentListProp_ConditionalOptions
		local self = _LazyNestedComponentListProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.LazyNestedComponentListProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _LazyNestedComponentListProp_ConditionalOptionsImpl.jsonEncode(
		self: LazyNestedComponentListProp_ConditionalOptions
	): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _LazyNestedComponentListProp_ConditionalOptionsImpl.jsonDecode(
		input: { [string]: any }
	): LazyNestedComponentListProp_ConditionalOptions
		local self = _LazyNestedComponentListProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { LazyNestedComponentListProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.LazyNestedComponentListProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_LazyNestedComponentListProp_ConditionalOptionsImpl.descriptor = {
		name = "LazyNestedComponentListProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.LazyNestedComponentListProp_ConditionalOptions = _LazyNestedComponentListProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.LazyNestedComponentListProp_ConditionalOptions)
end

do
	local _LazyNestedComponentListProp_TemplateDataImpl = {}
	_LazyNestedComponentListProp_TemplateDataImpl.__index = _LazyNestedComponentListProp_TemplateDataImpl

	function _LazyNestedComponentListProp_TemplateDataImpl.new(
		data: _LazyNestedComponentListProp_TemplateDataPartialFields?
	): LazyNestedComponentListProp_TemplateData
		return setmetatable({
			binding_path = if data == nil or data.binding_path == nil then "" else data.binding_path,
			roblox_component = if data == nil or data.roblox_component == nil
				then assert(
					_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(0),
					"Enum has no 0 default"
				)
				else data.roblox_component,
			inputs = if data == nil or data.inputs == nil then {} else data.inputs,
		}, _LazyNestedComponentListProp_TemplateDataImpl :: _LazyNestedComponentListProp_TemplateDataImpl)
	end

	function _LazyNestedComponentListProp_TemplateDataImpl.encode(
		self: LazyNestedComponentListProp_TemplateData
	): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.binding_path ~= nil and self.binding_path ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.binding_path)
		end

		if
			self.roblox_component ~= nil
			and (
				self.roblox_component ~= nil and self.roblox_component ~= 0
				or self.roblox_component
					~= _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(
				output,
				cursor,
				_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.toNumber(
					self.roblox_component :: any
				)
			)
		end

		if self.inputs ~= nil and next(self.inputs) ~= nil then
			for key, value in self.inputs do
				local mapBuffer = buffer.create(0)
				local mapCursor = 0
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 1, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeString(mapBuffer, mapCursor, key)
				local encoded = value:encode()
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 2, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeBuffer(mapBuffer, mapCursor, encoded, buffer.len(encoded))
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, mapBuffer, mapCursor)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _LazyNestedComponentListProp_TemplateDataImpl.decode(
		input: buffer
	): LazyNestedComponentListProp_TemplateData
		local self = _LazyNestedComponentListProp_TemplateDataImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 2 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.roblox_component = (
						_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(
							value
						) or value
					) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.binding_path = buffer.tostring(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)

					local mapEntry = messages.LazyNestedComponentListProp_TemplateData_InputsEntry.decode(value)

					local keyDefault = ""
					local valueDefault = messages.TemplateArg.new()

					self.inputs[mapEntry.key or keyDefault] = mapEntry.value or valueDefault

					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _LazyNestedComponentListProp_TemplateDataImpl.jsonEncode(
		self: LazyNestedComponentListProp_TemplateData
	): any
		local output = {}

		if self.binding_path ~= nil and self.binding_path ~= "" then
			output.bindingPath = self.binding_path
		end

		if
			self.roblox_component ~= nil
			and (
				self.roblox_component ~= nil and self.roblox_component ~= 0
				or self.roblox_component
					~= _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(0)
			)
		then
			output.robloxComponent = if typeof(self.roblox_component) == "number"
				then self.roblox_component
				else _roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.toNumber(
					self.roblox_component :: any
				)
		end

		if self.inputs ~= nil and next(self.inputs) ~= nil then
			local newOutput = {}
			for key, value in self.inputs do
				newOutput[key] = value:jsonEncode()
			end
			output.inputs = newOutput
		end

		return output
	end

	function _LazyNestedComponentListProp_TemplateDataImpl.jsonDecode(
		input: { [string]: any }
	): LazyNestedComponentListProp_TemplateData
		local self = _LazyNestedComponentListProp_TemplateDataImpl.new()

		if input.binding_path ~= nil then
			self.binding_path = input.binding_path
		end

		if input.bindingPath ~= nil then
			self.binding_path = input.bindingPath
		end

		if input.roblox_component ~= nil then
			self.roblox_component = if typeof(input.roblox_component) == "number"
				then (_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(
					input.roblox_component
				) or input.roblox_component)
				else (_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromName(
					input.roblox_component
				) or input.roblox_component)
		end

		if input.robloxComponent ~= nil then
			self.roblox_component = if typeof(input.robloxComponent) == "number"
				then (_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromNumber(
					input.robloxComponent
				) or input.robloxComponent)
				else (_roblox_apppageplatform_shared_v1beta1_roblox_component_type.RobloxComponentType.fromName(
					input.robloxComponent
				) or input.robloxComponent)
		end

		if input.inputs ~= nil then
			local newOutput: { [string]: TemplateArg } = {}
			for key, value in input.inputs do
				newOutput[key] = messages.TemplateArg.jsonDecode(value)
			end

			self.inputs = newOutput
		end

		return self
	end

	_LazyNestedComponentListProp_TemplateDataImpl.descriptor = {
		name = "LazyNestedComponentListProp_TemplateData",
		fullName = "roblox.apppageplatform.shared.v1beta1.TemplateData",
	}

	messages.LazyNestedComponentListProp_TemplateData = _LazyNestedComponentListProp_TemplateDataImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.LazyNestedComponentListProp_TemplateData)
end

do
	local _LazyNestedComponentListProp_TemplateData_InputsEntryImpl = {}
	_LazyNestedComponentListProp_TemplateData_InputsEntryImpl.__index =
		_LazyNestedComponentListProp_TemplateData_InputsEntryImpl

	function _LazyNestedComponentListProp_TemplateData_InputsEntryImpl.new(
		data: _LazyNestedComponentListProp_TemplateData_InputsEntryPartialFields?
	): LazyNestedComponentListProp_TemplateData_InputsEntry
		return setmetatable(
			{
				key = if data == nil or data.key == nil then "" else data.key,
				value = if data == nil or data.value == nil then nil else data.value,
			},
			_LazyNestedComponentListProp_TemplateData_InputsEntryImpl :: _LazyNestedComponentListProp_TemplateData_InputsEntryImpl
		)
	end

	function _LazyNestedComponentListProp_TemplateData_InputsEntryImpl.encode(
		self: LazyNestedComponentListProp_TemplateData_InputsEntry
	): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.key ~= nil and self.key ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.key)
		end

		if self.value ~= nil then
			local encoded = self.value:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _LazyNestedComponentListProp_TemplateData_InputsEntryImpl.decode(
		input: buffer
	): LazyNestedComponentListProp_TemplateData_InputsEntry
		local self = _LazyNestedComponentListProp_TemplateData_InputsEntryImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.key = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = messages.TemplateArg.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _LazyNestedComponentListProp_TemplateData_InputsEntryImpl.jsonEncode(
		self: LazyNestedComponentListProp_TemplateData_InputsEntry
	): any
		local output = {}

		if self.key ~= nil and self.key ~= "" then
			output.key = self.key
		end

		if self.value ~= nil then
			output.value = self.value:jsonEncode()
		end

		return output
	end

	function _LazyNestedComponentListProp_TemplateData_InputsEntryImpl.jsonDecode(
		input: { [string]: any }
	): LazyNestedComponentListProp_TemplateData_InputsEntry
		local self = _LazyNestedComponentListProp_TemplateData_InputsEntryImpl.new()

		if input.key ~= nil then
			self.key = input.key
		end

		if input.value ~= nil then
			self.value = messages.TemplateArg.jsonDecode(input.value)
		end

		return self
	end

	_LazyNestedComponentListProp_TemplateData_InputsEntryImpl.descriptor = {
		name = "LazyNestedComponentListProp_TemplateData_InputsEntry",
		fullName = "roblox.apppageplatform.shared.v1beta1.InputsEntry",
	}

	messages.LazyNestedComponentListProp_TemplateData_InputsEntry =
		_LazyNestedComponentListProp_TemplateData_InputsEntryImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.LazyNestedComponentListProp_TemplateData_InputsEntry)
end

do
	local _LazyNestedComponentListProp_TemplateDataListImpl = {}
	_LazyNestedComponentListProp_TemplateDataListImpl.__index = _LazyNestedComponentListProp_TemplateDataListImpl

	function _LazyNestedComponentListProp_TemplateDataListImpl.new(
		data: _LazyNestedComponentListProp_TemplateDataListPartialFields?
	): LazyNestedComponentListProp_TemplateDataList
		return setmetatable({
			items = if data == nil or data.items == nil then {} else data.items,
		}, _LazyNestedComponentListProp_TemplateDataListImpl :: _LazyNestedComponentListProp_TemplateDataListImpl)
	end

	function _LazyNestedComponentListProp_TemplateDataListImpl.encode(
		self: LazyNestedComponentListProp_TemplateDataList
	): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.items ~= nil and #self.items > 0 then
			for _, value in self.items do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _LazyNestedComponentListProp_TemplateDataListImpl.decode(
		input: buffer
	): LazyNestedComponentListProp_TemplateDataList
		local self = _LazyNestedComponentListProp_TemplateDataListImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.items, messages.LazyNestedComponentListProp_TemplateData.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _LazyNestedComponentListProp_TemplateDataListImpl.jsonEncode(
		self: LazyNestedComponentListProp_TemplateDataList
	): any
		local output = {}

		if self.items ~= nil and #self.items > 0 then
			local newOutput = {}
			for _, value in self.items do
				table.insert(newOutput, value:jsonEncode())
			end
			output.items = newOutput
		end

		return output
	end

	function _LazyNestedComponentListProp_TemplateDataListImpl.jsonDecode(
		input: { [string]: any }
	): LazyNestedComponentListProp_TemplateDataList
		local self = _LazyNestedComponentListProp_TemplateDataListImpl.new()

		if input.items ~= nil then
			local newOutput: { LazyNestedComponentListProp_TemplateData } = {}
			for _, value in input.items do
				table.insert(newOutput, messages.LazyNestedComponentListProp_TemplateData.jsonDecode(value))
			end

			self.items = newOutput
		end

		return self
	end

	_LazyNestedComponentListProp_TemplateDataListImpl.descriptor = {
		name = "LazyNestedComponentListProp_TemplateDataList",
		fullName = "roblox.apppageplatform.shared.v1beta1.TemplateDataList",
	}

	messages.LazyNestedComponentListProp_TemplateDataList = _LazyNestedComponentListProp_TemplateDataListImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.LazyNestedComponentListProp_TemplateDataList)
end

do
	local _IconPropImpl = {}
	_IconPropImpl.__index = _IconPropImpl

	function _IconPropImpl.new(data: _IconPropPartialFields?): IconProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _IconPropImpl :: _IconPropImpl)
	end

	function _IconPropImpl.encode(self: IconProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "icon_name" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "legacy_icon_name" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _IconPropImpl.decode(input: buffer): IconProp
		local self = _IconPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "icon_name", value = buffer.tostring(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "legacy_icon_name", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.IconProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _IconPropImpl.jsonEncode(self: IconProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "icon_name" then
				output.iconName = self.kind.value
			elseif self.kind.type == "legacy_icon_name" then
				output.legacyIconName = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _IconPropImpl.jsonDecode(input: { [string]: any }): IconProp
		local self = _IconPropImpl.new()

		if input.icon_name ~= nil then
			self.kind = { type = "icon_name", value = input.icon_name }
		end

		if input.iconName ~= nil then
			self.kind = { type = "icon_name", value = input.iconName }
		end

		if input.legacy_icon_name ~= nil then
			self.kind = { type = "legacy_icon_name", value = input.legacy_icon_name }
		end

		if input.legacyIconName ~= nil then
			self.kind = { type = "legacy_icon_name", value = input.legacyIconName }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.IconProp_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_IconPropImpl.descriptor = {
		name = "IconProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.IconProp",
	}

	messages.IconProp = _IconPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.IconProp)
end

do
	local _IconProp_ConditionalOptionImpl = {}
	_IconProp_ConditionalOptionImpl.__index = _IconProp_ConditionalOptionImpl

	function _IconProp_ConditionalOptionImpl.new(
		data: _IconProp_ConditionalOptionPartialFields?
	): IconProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _IconProp_ConditionalOptionImpl :: _IconProp_ConditionalOptionImpl)
	end

	function _IconProp_ConditionalOptionImpl.encode(self: IconProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "icon_name" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "legacy_icon_name" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _IconProp_ConditionalOptionImpl.decode(input: buffer): IconProp_ConditionalOption
		local self = _IconProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "icon_name", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "legacy_icon_name", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _IconProp_ConditionalOptionImpl.jsonEncode(self: IconProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "icon_name" then
				output.iconName = self.kind.value
			elseif self.kind.type == "legacy_icon_name" then
				output.legacyIconName = self.kind.value
			end
		end

		return output
	end

	function _IconProp_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): IconProp_ConditionalOption
		local self = _IconProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.icon_name ~= nil then
			self.kind = { type = "icon_name", value = input.icon_name }
		end

		if input.iconName ~= nil then
			self.kind = { type = "icon_name", value = input.iconName }
		end

		if input.legacy_icon_name ~= nil then
			self.kind = { type = "legacy_icon_name", value = input.legacy_icon_name }
		end

		if input.legacyIconName ~= nil then
			self.kind = { type = "legacy_icon_name", value = input.legacyIconName }
		end

		return self
	end

	_IconProp_ConditionalOptionImpl.descriptor = {
		name = "IconProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.IconProp_ConditionalOption = _IconProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.IconProp_ConditionalOption)
end

do
	local _IconProp_ConditionalOptionsImpl = {}
	_IconProp_ConditionalOptionsImpl.__index = _IconProp_ConditionalOptionsImpl

	function _IconProp_ConditionalOptionsImpl.new(
		data: _IconProp_ConditionalOptionsPartialFields?
	): IconProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _IconProp_ConditionalOptionsImpl :: _IconProp_ConditionalOptionsImpl)
	end

	function _IconProp_ConditionalOptionsImpl.encode(self: IconProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _IconProp_ConditionalOptionsImpl.decode(input: buffer): IconProp_ConditionalOptions
		local self = _IconProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.IconProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _IconProp_ConditionalOptionsImpl.jsonEncode(self: IconProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _IconProp_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): IconProp_ConditionalOptions
		local self = _IconProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { IconProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.IconProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_IconProp_ConditionalOptionsImpl.descriptor = {
		name = "IconProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.IconProp_ConditionalOptions = _IconProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.IconProp_ConditionalOptions)
end

do
	local _GradientPropImpl = {}
	_GradientPropImpl.__index = _GradientPropImpl

	function _GradientPropImpl.new(data: _GradientPropPartialFields?): GradientProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _GradientPropImpl :: _GradientPropImpl)
	end

	function _GradientPropImpl.encode(self: GradientProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _GradientPropImpl.decode(input: buffer): GradientProp
		local self = _GradientPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = messages.GradientProp_GradientData.decode(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "conditional", value = messages.GradientProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _GradientPropImpl.jsonEncode(self: GradientProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value:jsonEncode()
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _GradientPropImpl.jsonDecode(input: { [string]: any }): GradientProp
		local self = _GradientPropImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = messages.GradientProp_GradientData.jsonDecode(input.literal) }
		end

		if input.conditional ~= nil then
			self.kind =
				{ type = "conditional", value = messages.GradientProp_ConditionalOptions.jsonDecode(input.conditional) }
		end

		return self
	end

	_GradientPropImpl.descriptor = {
		name = "GradientProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.GradientProp",
	}

	messages.GradientProp = _GradientPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.GradientProp)
end

do
	local _GradientProp_ConditionalOptionImpl = {}
	_GradientProp_ConditionalOptionImpl.__index = _GradientProp_ConditionalOptionImpl

	function _GradientProp_ConditionalOptionImpl.new(
		data: _GradientProp_ConditionalOptionPartialFields?
	): GradientProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			literal = if data == nil or data.literal == nil then nil else data.literal,
		}, _GradientProp_ConditionalOptionImpl :: _GradientProp_ConditionalOptionImpl)
	end

	function _GradientProp_ConditionalOptionImpl.encode(self: GradientProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.literal ~= nil then
			local encoded = self.literal:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _GradientProp_ConditionalOptionImpl.decode(input: buffer): GradientProp_ConditionalOption
		local self = _GradientProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.literal = messages.GradientProp_GradientData.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _GradientProp_ConditionalOptionImpl.jsonEncode(self: GradientProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.literal ~= nil then
			output.literal = self.literal:jsonEncode()
		end

		return output
	end

	function _GradientProp_ConditionalOptionImpl.jsonDecode(input: { [string]: any }): GradientProp_ConditionalOption
		local self = _GradientProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.literal = messages.GradientProp_GradientData.jsonDecode(input.literal)
		end

		return self
	end

	_GradientProp_ConditionalOptionImpl.descriptor = {
		name = "GradientProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.GradientProp_ConditionalOption = _GradientProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.GradientProp_ConditionalOption)
end

do
	local _GradientProp_ConditionalOptionsImpl = {}
	_GradientProp_ConditionalOptionsImpl.__index = _GradientProp_ConditionalOptionsImpl

	function _GradientProp_ConditionalOptionsImpl.new(
		data: _GradientProp_ConditionalOptionsPartialFields?
	): GradientProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _GradientProp_ConditionalOptionsImpl :: _GradientProp_ConditionalOptionsImpl)
	end

	function _GradientProp_ConditionalOptionsImpl.encode(self: GradientProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _GradientProp_ConditionalOptionsImpl.decode(input: buffer): GradientProp_ConditionalOptions
		local self = _GradientProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.GradientProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _GradientProp_ConditionalOptionsImpl.jsonEncode(self: GradientProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _GradientProp_ConditionalOptionsImpl.jsonDecode(input: { [string]: any }): GradientProp_ConditionalOptions
		local self = _GradientProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { GradientProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.GradientProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_GradientProp_ConditionalOptionsImpl.descriptor = {
		name = "GradientProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.GradientProp_ConditionalOptions = _GradientProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.GradientProp_ConditionalOptions)
end

do
	local _GradientProp_GradientDataImpl = {}
	_GradientProp_GradientDataImpl.__index = _GradientProp_GradientDataImpl

	function _GradientProp_GradientDataImpl.new(
		data: _GradientProp_GradientDataPartialFields?
	): GradientProp_GradientData
		return setmetatable({
			start_color = if data == nil or data.start_color == nil then "" else data.start_color,
			end_color = if data == nil or data.end_color == nil then "" else data.end_color,
			start_opacity = if data == nil or data.start_opacity == nil then 0 else data.start_opacity,
			end_opacity = if data == nil or data.end_opacity == nil then 0 else data.end_opacity,
			degree = if data == nil or data.degree == nil then 0 else data.degree,
		}, _GradientProp_GradientDataImpl :: _GradientProp_GradientDataImpl)
	end

	function _GradientProp_GradientDataImpl.encode(self: GradientProp_GradientData): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.start_color ~= nil and self.start_color ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.start_color)
		end

		if self.end_color ~= nil and self.end_color ~= "" then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.end_color)
		end

		if self.start_opacity ~= nil and self.start_opacity ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.i32)
			output, cursor = proto.writeFloat(output, cursor, self.start_opacity)
		end

		if self.end_opacity ~= nil and self.end_opacity ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.i32)
			output, cursor = proto.writeFloat(output, cursor, self.end_opacity)
		end

		if self.degree ~= nil and self.degree ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.degree)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _GradientProp_GradientDataImpl.decode(input: buffer): GradientProp_GradientData
		local self = _GradientProp_GradientDataImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 5 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.degree = value
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.start_color = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.end_color = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				if field == 3 then
					local value
					value, cursor = proto.readFloat(input, cursor)
					self.start_opacity = value
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readFloat(input, cursor)
					self.end_opacity = value
					continue
				end

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _GradientProp_GradientDataImpl.jsonEncode(self: GradientProp_GradientData): any
		local output = {}

		if self.start_color ~= nil and self.start_color ~= "" then
			output.startColor = self.start_color
		end

		if self.end_color ~= nil and self.end_color ~= "" then
			output.endColor = self.end_color
		end

		if self.start_opacity ~= nil and self.start_opacity ~= 0 then
			output.startOpacity = proto.json.serializeNumber(self.start_opacity)
		end

		if self.end_opacity ~= nil and self.end_opacity ~= 0 then
			output.endOpacity = proto.json.serializeNumber(self.end_opacity)
		end

		if self.degree ~= nil and self.degree ~= 0 then
			output.degree = self.degree
		end

		return output
	end

	function _GradientProp_GradientDataImpl.jsonDecode(input: { [string]: any }): GradientProp_GradientData
		local self = _GradientProp_GradientDataImpl.new()

		if input.start_color ~= nil then
			self.start_color = input.start_color
		end

		if input.startColor ~= nil then
			self.start_color = input.startColor
		end

		if input.end_color ~= nil then
			self.end_color = input.end_color
		end

		if input.endColor ~= nil then
			self.end_color = input.endColor
		end

		if input.start_opacity ~= nil then
			self.start_opacity = proto.json.deserializeNumber(input.start_opacity)
		end

		if input.startOpacity ~= nil then
			self.start_opacity = proto.json.deserializeNumber(input.startOpacity)
		end

		if input.end_opacity ~= nil then
			self.end_opacity = proto.json.deserializeNumber(input.end_opacity)
		end

		if input.endOpacity ~= nil then
			self.end_opacity = proto.json.deserializeNumber(input.endOpacity)
		end

		if input.degree ~= nil then
			self.degree = input.degree
		end

		return self
	end

	_GradientProp_GradientDataImpl.descriptor = {
		name = "GradientProp_GradientData",
		fullName = "roblox.apppageplatform.shared.v1beta1.GradientData",
	}

	messages.GradientProp_GradientData = _GradientProp_GradientDataImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.GradientProp_GradientData)
end

do
	local _ArrayOfStructPropImpl = {}
	_ArrayOfStructPropImpl.__index = _ArrayOfStructPropImpl

	function _ArrayOfStructPropImpl.new(data: _ArrayOfStructPropPartialFields?): ArrayOfStructProp
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _ArrayOfStructPropImpl :: _ArrayOfStructPropImpl)
	end

	function _ArrayOfStructPropImpl.encode(self: ArrayOfStructProp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "conditional" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ArrayOfStructPropImpl.decode(input: buffer): ArrayOfStructProp
		local self = _ArrayOfStructPropImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = messages.ArrayOfStructProp_ArrayOfStructs.decode(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind =
						{ type = "conditional", value = messages.ArrayOfStructProp_ConditionalOptions.decode(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ArrayOfStructPropImpl.jsonEncode(self: ArrayOfStructProp): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value:jsonEncode()
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			elseif self.kind.type == "conditional" then
				output.conditional = self.kind.value:jsonEncode()
			end
		end

		return output
	end

	function _ArrayOfStructPropImpl.jsonDecode(input: { [string]: any }): ArrayOfStructProp
		local self = _ArrayOfStructPropImpl.new()

		if input.literal ~= nil then
			self.kind =
				{ type = "literal", value = messages.ArrayOfStructProp_ArrayOfStructs.jsonDecode(input.literal) }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		if input.conditional ~= nil then
			self.kind = {
				type = "conditional",
				value = messages.ArrayOfStructProp_ConditionalOptions.jsonDecode(input.conditional),
			}
		end

		return self
	end

	_ArrayOfStructPropImpl.descriptor = {
		name = "ArrayOfStructProp",
		fullName = "roblox.apppageplatform.shared.v1beta1.ArrayOfStructProp",
	}

	messages.ArrayOfStructProp = _ArrayOfStructPropImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ArrayOfStructProp)
end

do
	local _ArrayOfStructProp_ConditionalOptionImpl = {}
	_ArrayOfStructProp_ConditionalOptionImpl.__index = _ArrayOfStructProp_ConditionalOptionImpl

	function _ArrayOfStructProp_ConditionalOptionImpl.new(
		data: _ArrayOfStructProp_ConditionalOptionPartialFields?
	): ArrayOfStructProp_ConditionalOption
		return setmetatable({
			condition = if data == nil or data.condition == nil then nil else data.condition,
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _ArrayOfStructProp_ConditionalOptionImpl :: _ArrayOfStructProp_ConditionalOptionImpl)
	end

	function _ArrayOfStructProp_ConditionalOptionImpl.encode(self: ArrayOfStructProp_ConditionalOption): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.condition ~= nil then
			local encoded = self.condition:encode()
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				local encoded = self.kind.value:encode()
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			elseif self.kind.type == "binding_path" then
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ArrayOfStructProp_ConditionalOptionImpl.decode(input: buffer): ArrayOfStructProp_ConditionalOption
		local self = _ArrayOfStructProp_ConditionalOptionImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.condition = _roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.decode(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = messages.ArrayOfStructProp_ArrayOfStructs.decode(value) }
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "binding_path", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ArrayOfStructProp_ConditionalOptionImpl.jsonEncode(self: ArrayOfStructProp_ConditionalOption): any
		local output = {}

		if self.condition ~= nil then
			output.condition = self.condition:jsonEncode()
		end

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value:jsonEncode()
			elseif self.kind.type == "binding_path" then
				output.bindingPath = self.kind.value
			end
		end

		return output
	end

	function _ArrayOfStructProp_ConditionalOptionImpl.jsonDecode(
		input: { [string]: any }
	): ArrayOfStructProp_ConditionalOption
		local self = _ArrayOfStructProp_ConditionalOptionImpl.new()

		if input.condition ~= nil then
			self.condition =
				_roblox_apppageplatform_shared_v1beta1_prop_condition.PropCondition.jsonDecode(input.condition)
		end

		if input.literal ~= nil then
			self.kind =
				{ type = "literal", value = messages.ArrayOfStructProp_ArrayOfStructs.jsonDecode(input.literal) }
		end

		if input.binding_path ~= nil then
			self.kind = { type = "binding_path", value = input.binding_path }
		end

		if input.bindingPath ~= nil then
			self.kind = { type = "binding_path", value = input.bindingPath }
		end

		return self
	end

	_ArrayOfStructProp_ConditionalOptionImpl.descriptor = {
		name = "ArrayOfStructProp_ConditionalOption",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOption",
	}

	messages.ArrayOfStructProp_ConditionalOption = _ArrayOfStructProp_ConditionalOptionImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ArrayOfStructProp_ConditionalOption)
end

do
	local _ArrayOfStructProp_ConditionalOptionsImpl = {}
	_ArrayOfStructProp_ConditionalOptionsImpl.__index = _ArrayOfStructProp_ConditionalOptionsImpl

	function _ArrayOfStructProp_ConditionalOptionsImpl.new(
		data: _ArrayOfStructProp_ConditionalOptionsPartialFields?
	): ArrayOfStructProp_ConditionalOptions
		return setmetatable({
			option = if data == nil or data.option == nil then {} else data.option,
		}, _ArrayOfStructProp_ConditionalOptionsImpl :: _ArrayOfStructProp_ConditionalOptionsImpl)
	end

	function _ArrayOfStructProp_ConditionalOptionsImpl.encode(self: ArrayOfStructProp_ConditionalOptions): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.option ~= nil and #self.option > 0 then
			for _, value in self.option do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ArrayOfStructProp_ConditionalOptionsImpl.decode(input: buffer): ArrayOfStructProp_ConditionalOptions
		local self = _ArrayOfStructProp_ConditionalOptionsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.option, messages.ArrayOfStructProp_ConditionalOption.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ArrayOfStructProp_ConditionalOptionsImpl.jsonEncode(self: ArrayOfStructProp_ConditionalOptions): any
		local output = {}

		if self.option ~= nil and #self.option > 0 then
			local newOutput = {}
			for _, value in self.option do
				table.insert(newOutput, value:jsonEncode())
			end
			output.option = newOutput
		end

		return output
	end

	function _ArrayOfStructProp_ConditionalOptionsImpl.jsonDecode(
		input: { [string]: any }
	): ArrayOfStructProp_ConditionalOptions
		local self = _ArrayOfStructProp_ConditionalOptionsImpl.new()

		if input.option ~= nil then
			local newOutput: { ArrayOfStructProp_ConditionalOption } = {}
			for _, value in input.option do
				table.insert(newOutput, messages.ArrayOfStructProp_ConditionalOption.jsonDecode(value))
			end

			self.option = newOutput
		end

		return self
	end

	_ArrayOfStructProp_ConditionalOptionsImpl.descriptor = {
		name = "ArrayOfStructProp_ConditionalOptions",
		fullName = "roblox.apppageplatform.shared.v1beta1.ConditionalOptions",
	}

	messages.ArrayOfStructProp_ConditionalOptions = _ArrayOfStructProp_ConditionalOptionsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ArrayOfStructProp_ConditionalOptions)
end

do
	local _ArrayOfStructProp_ArrayOfStructsImpl = {}
	_ArrayOfStructProp_ArrayOfStructsImpl.__index = _ArrayOfStructProp_ArrayOfStructsImpl

	function _ArrayOfStructProp_ArrayOfStructsImpl.new(
		data: _ArrayOfStructProp_ArrayOfStructsPartialFields?
	): ArrayOfStructProp_ArrayOfStructs
		return setmetatable({
			entry = if data == nil or data.entry == nil then {} else data.entry,
		}, _ArrayOfStructProp_ArrayOfStructsImpl :: _ArrayOfStructProp_ArrayOfStructsImpl)
	end

	function _ArrayOfStructProp_ArrayOfStructsImpl.encode(self: ArrayOfStructProp_ArrayOfStructs): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.entry ~= nil and #self.entry > 0 then
			for _, value in self.entry do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ArrayOfStructProp_ArrayOfStructsImpl.decode(input: buffer): ArrayOfStructProp_ArrayOfStructs
		local self = _ArrayOfStructProp_ArrayOfStructsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.entry, _google_protobuf_struct.Struct.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ArrayOfStructProp_ArrayOfStructsImpl.jsonEncode(self: ArrayOfStructProp_ArrayOfStructs): any
		local output = {}

		if self.entry ~= nil and #self.entry > 0 then
			local newOutput = {}
			for _, value in self.entry do
				table.insert(newOutput, value:jsonEncode())
			end
			output.entry = newOutput
		end

		return output
	end

	function _ArrayOfStructProp_ArrayOfStructsImpl.jsonDecode(
		input: { [string]: any }
	): ArrayOfStructProp_ArrayOfStructs
		local self = _ArrayOfStructProp_ArrayOfStructsImpl.new()

		if input.entry ~= nil then
			local newOutput: { _google_protobuf_struct.Struct } = {}
			for _, value in input.entry do
				table.insert(newOutput, _google_protobuf_struct.Struct.jsonDecode(value))
			end

			self.entry = newOutput
		end

		return self
	end

	_ArrayOfStructProp_ArrayOfStructsImpl.descriptor = {
		name = "ArrayOfStructProp_ArrayOfStructs",
		fullName = "roblox.apppageplatform.shared.v1beta1.ArrayOfStructs",
	}

	messages.ArrayOfStructProp_ArrayOfStructs = _ArrayOfStructProp_ArrayOfStructsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ArrayOfStructProp_ArrayOfStructs)
end

return {
	StringFormat = messages.StringFormat,
	StringFormat_FormatArg = messages.StringFormat_FormatArg,
	StringProp = messages.StringProp,
	StringProp_ConditionalOption = messages.StringProp_ConditionalOption,
	StringProp_ConditionalOptions = messages.StringProp_ConditionalOptions,
	FloatProp = messages.FloatProp,
	FloatProp_ConditionalOption = messages.FloatProp_ConditionalOption,
	FloatProp_ConditionalOptions = messages.FloatProp_ConditionalOptions,
	DoubleProp = messages.DoubleProp,
	DoubleProp_ConditionalOption = messages.DoubleProp_ConditionalOption,
	DoubleProp_ConditionalOptions = messages.DoubleProp_ConditionalOptions,
	Int32Prop = messages.Int32Prop,
	Int32Prop_ConditionalOption = messages.Int32Prop_ConditionalOption,
	Int32Prop_ConditionalOptions = messages.Int32Prop_ConditionalOptions,
	Int64Prop = messages.Int64Prop,
	Int64Prop_ConditionalOption = messages.Int64Prop_ConditionalOption,
	Int64Prop_ConditionalOptions = messages.Int64Prop_ConditionalOptions,
	BoolProp = messages.BoolProp,
	BoolProp_ConditionalOption = messages.BoolProp_ConditionalOption,
	BoolProp_ConditionalOptions = messages.BoolProp_ConditionalOptions,
	StructProp = messages.StructProp,
	StructProp_ConditionalOption = messages.StructProp_ConditionalOption,
	StructProp_ConditionalOptions = messages.StructProp_ConditionalOptions,
	ImageStringProp = messages.ImageStringProp,
	ImageStringProp_ConditionalOption = messages.ImageStringProp_ConditionalOption,
	ImageStringProp_ConditionalOptions = messages.ImageStringProp_ConditionalOptions,
	ImageSetProp = messages.ImageSetProp,
	ImageSetProp_ConditionalOption = messages.ImageSetProp_ConditionalOption,
	ImageSetProp_ConditionalOptions = messages.ImageSetProp_ConditionalOptions,
	ColorProp = messages.ColorProp,
	ColorProp_ConditionalOption = messages.ColorProp_ConditionalOption,
	ColorProp_ConditionalOptions = messages.ColorProp_ConditionalOptions,
	TypographyProp = messages.TypographyProp,
	TypographyProp_ConditionalOption = messages.TypographyProp_ConditionalOption,
	TypographyProp_ConditionalOptions = messages.TypographyProp_ConditionalOptions,
	TypographyFontProp = messages.TypographyFontProp,
	TypographyFontProp_ConditionalOption = messages.TypographyFontProp_ConditionalOption,
	TypographyFontProp_ConditionalOptions = messages.TypographyFontProp_ConditionalOptions,
	UDimProp = messages.UDimProp,
	UDimProp_ConditionalOption = messages.UDimProp_ConditionalOption,
	UDimProp_ConditionalOptions = messages.UDimProp_ConditionalOptions,
	UDim2Prop = messages.UDim2Prop,
	UDim2Prop_ConditionalOption = messages.UDim2Prop_ConditionalOption,
	UDim2Prop_ConditionalOptions = messages.UDim2Prop_ConditionalOptions,
	Vector2Prop = messages.Vector2Prop,
	Vector2Prop_ConditionalOption = messages.Vector2Prop_ConditionalOption,
	Vector2Prop_ConditionalOptions = messages.Vector2Prop_ConditionalOptions,
	TemplateArg = messages.TemplateArg,
	TemplateArg_LiteralValue = messages.TemplateArg_LiteralValue,
	NestedComponentProp = messages.NestedComponentProp,
	NestedComponentProp_ConditionalOption = messages.NestedComponentProp_ConditionalOption,
	NestedComponentProp_ConditionalOptions = messages.NestedComponentProp_ConditionalOptions,
	NestedComponentProp_TemplateData = messages.NestedComponentProp_TemplateData,
	LazyNestedComponentListProp = messages.LazyNestedComponentListProp,
	LazyNestedComponentListProp_ConditionalOption = messages.LazyNestedComponentListProp_ConditionalOption,
	LazyNestedComponentListProp_ConditionalOptions = messages.LazyNestedComponentListProp_ConditionalOptions,
	LazyNestedComponentListProp_TemplateData = messages.LazyNestedComponentListProp_TemplateData,
	LazyNestedComponentListProp_TemplateDataList = messages.LazyNestedComponentListProp_TemplateDataList,
	IconProp = messages.IconProp,
	IconProp_ConditionalOption = messages.IconProp_ConditionalOption,
	IconProp_ConditionalOptions = messages.IconProp_ConditionalOptions,
	GradientProp = messages.GradientProp,
	GradientProp_ConditionalOption = messages.GradientProp_ConditionalOption,
	GradientProp_ConditionalOptions = messages.GradientProp_ConditionalOptions,
	GradientProp_GradientData = messages.GradientProp_GradientData,
	ArrayOfStructProp = messages.ArrayOfStructProp,
	ArrayOfStructProp_ConditionalOption = messages.ArrayOfStructProp_ConditionalOption,
	ArrayOfStructProp_ConditionalOptions = messages.ArrayOfStructProp_ConditionalOptions,
	ArrayOfStructProp_ArrayOfStructs = messages.ArrayOfStructProp_ArrayOfStructs,
}
