--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require(script.Parent.Parent.Parent.Parent.Parent.proto)
local typeRegistry = require(script.Parent.Parent.Parent.Parent.Parent.proto.typeRegistry)

type _Messages = {
	HydrationDataSpec: _HydrationDataSpecMessage,
	IdBinding: _IdBindingMessage,
}
local messages: _Messages = {} :: _Messages

local _roblox_apppageplatform_shared_v1beta1_hydration_content_type = require(script.Parent.hydration_content_type)

type _HydrationDataSpecImpl = {
	__index: _HydrationDataSpecImpl,
	new: (fields: _HydrationDataSpecPartialFields?) -> HydrationDataSpec,
	encode: (self: HydrationDataSpec) -> buffer,
	decode: (input: buffer) -> HydrationDataSpec,
	jsonEncode: (self: HydrationDataSpec) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> HydrationDataSpec,
	descriptor: proto.Descriptor,
}

type _HydrationDataSpecFields = {
	content_type: _roblox_apppageplatform_shared_v1beta1_hydration_content_type.HydrationContentType,
	id_binding: IdBinding?,
	alias: string,
}

type _HydrationDataSpecPartialFields = {
	content_type: _roblox_apppageplatform_shared_v1beta1_hydration_content_type.HydrationContentType?,
	id_binding: IdBinding?,
	alias: string?,
}

export type HydrationDataSpec = typeof(setmetatable({} :: _HydrationDataSpecFields, {} :: _HydrationDataSpecImpl))
type _HydrationDataSpecMessage = proto.Message<HydrationDataSpec, _HydrationDataSpecPartialFields>

type _IdBindingImpl = {
	__index: _IdBindingImpl,
	new: (fields: _IdBindingPartialFields?) -> IdBinding,
	encode: (self: IdBinding) -> buffer,
	decode: (input: buffer) -> IdBinding,
	jsonEncode: (self: IdBinding) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> IdBinding,
	descriptor: proto.Descriptor,
}

type _IdBindingFields = {
	kind: ({ type: "literal", value: string } | { type: "input_path", value: string })?,
}

type _IdBindingPartialFields = {
	kind: ({ type: "literal", value: string } | { type: "input_path", value: string })?,
}

export type IdBinding = typeof(setmetatable({} :: _IdBindingFields, {} :: _IdBindingImpl))
type _IdBindingMessage = proto.Message<IdBinding, _IdBindingPartialFields>

do
	local _HydrationDataSpecImpl = {}
	_HydrationDataSpecImpl.__index = _HydrationDataSpecImpl

	function _HydrationDataSpecImpl.new(data: _HydrationDataSpecPartialFields?): HydrationDataSpec
		return setmetatable({
			content_type = if data == nil or data.content_type == nil
				then assert(
					_roblox_apppageplatform_shared_v1beta1_hydration_content_type.HydrationContentType.fromNumber(0),
					"Enum has no 0 default"
				)
				else data.content_type,
			id_binding = if data == nil or data.id_binding == nil then nil else data.id_binding,
			alias = if data == nil or data.alias == nil then "" else data.alias,
		}, _HydrationDataSpecImpl :: _HydrationDataSpecImpl)
	end

	function _HydrationDataSpecImpl.encode(self: HydrationDataSpec): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.content_type ~= nil
			and (
				self.content_type ~= nil and self.content_type ~= 0
				or self.content_type
					~= _roblox_apppageplatform_shared_v1beta1_hydration_content_type.HydrationContentType.fromNumber(0)
			)
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(
				output,
				cursor,
				_roblox_apppageplatform_shared_v1beta1_hydration_content_type.HydrationContentType.toNumber(
					self.content_type :: any
				)
			)
		end

		if self.id_binding ~= nil then
			local encoded = self.id_binding:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.alias ~= nil and self.alias ~= "" then
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.alias)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _HydrationDataSpecImpl.decode(input: buffer): HydrationDataSpec
		local self = _HydrationDataSpecImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.content_type = (
						_roblox_apppageplatform_shared_v1beta1_hydration_content_type.HydrationContentType.fromNumber(
							value
						) or value
					) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.id_binding = messages.IdBinding.decode(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.alias = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _HydrationDataSpecImpl.jsonEncode(self: HydrationDataSpec): any
		local output = {}

		if
			self.content_type ~= nil
			and (
				self.content_type ~= nil and self.content_type ~= 0
				or self.content_type
					~= _roblox_apppageplatform_shared_v1beta1_hydration_content_type.HydrationContentType.fromNumber(0)
			)
		then
			output.contentType = if typeof(self.content_type) == "number"
				then self.content_type
				else _roblox_apppageplatform_shared_v1beta1_hydration_content_type.HydrationContentType.toNumber(
					self.content_type :: any
				)
		end

		if self.id_binding ~= nil then
			output.idBinding = self.id_binding:jsonEncode()
		end

		if self.alias ~= nil and self.alias ~= "" then
			output.alias = self.alias
		end

		return output
	end

	function _HydrationDataSpecImpl.jsonDecode(input: { [string]: any }): HydrationDataSpec
		local self = _HydrationDataSpecImpl.new()

		if input.content_type ~= nil then
			self.content_type = if typeof(input.content_type) == "number"
				then (_roblox_apppageplatform_shared_v1beta1_hydration_content_type.HydrationContentType.fromNumber(
					input.content_type
				) or input.content_type)
				else (_roblox_apppageplatform_shared_v1beta1_hydration_content_type.HydrationContentType.fromName(
					input.content_type
				) or input.content_type)
		end

		if input.contentType ~= nil then
			self.content_type = if typeof(input.contentType) == "number"
				then (_roblox_apppageplatform_shared_v1beta1_hydration_content_type.HydrationContentType.fromNumber(
					input.contentType
				) or input.contentType)
				else (_roblox_apppageplatform_shared_v1beta1_hydration_content_type.HydrationContentType.fromName(
					input.contentType
				) or input.contentType)
		end

		if input.id_binding ~= nil then
			self.id_binding = messages.IdBinding.jsonDecode(input.id_binding)
		end

		if input.idBinding ~= nil then
			self.id_binding = messages.IdBinding.jsonDecode(input.idBinding)
		end

		if input.alias ~= nil then
			self.alias = input.alias
		end

		return self
	end

	_HydrationDataSpecImpl.descriptor = {
		name = "HydrationDataSpec",
		fullName = "roblox.apppageplatform.shared.v1beta1.HydrationDataSpec",
	}

	messages.HydrationDataSpec = _HydrationDataSpecImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.HydrationDataSpec)
end

do
	local _IdBindingImpl = {}
	_IdBindingImpl.__index = _IdBindingImpl

	function _IdBindingImpl.new(data: _IdBindingPartialFields?): IdBinding
		return setmetatable({
			kind = if data == nil or data.kind == nil then nil else data.kind,
		}, _IdBindingImpl :: _IdBindingImpl)
	end

	function _IdBindingImpl.encode(self: IdBinding): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			elseif self.kind.type == "input_path" then
				output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeString(output, cursor, self.kind.value)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _IdBindingImpl.decode(input: buffer): IdBinding
		local self = _IdBindingImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "literal", value = buffer.tostring(value) }
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.kind = { type = "input_path", value = buffer.tostring(value) }
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _IdBindingImpl.jsonEncode(self: IdBinding): any
		local output = {}

		if self.kind ~= nil then
			if self.kind.type == "literal" then
				output.literal = self.kind.value
			elseif self.kind.type == "input_path" then
				output.inputPath = self.kind.value
			end
		end

		return output
	end

	function _IdBindingImpl.jsonDecode(input: { [string]: any }): IdBinding
		local self = _IdBindingImpl.new()

		if input.literal ~= nil then
			self.kind = { type = "literal", value = input.literal }
		end

		if input.input_path ~= nil then
			self.kind = { type = "input_path", value = input.input_path }
		end

		if input.inputPath ~= nil then
			self.kind = { type = "input_path", value = input.inputPath }
		end

		return self
	end

	_IdBindingImpl.descriptor = {
		name = "IdBinding",
		fullName = "roblox.apppageplatform.shared.v1beta1.IdBinding",
	}

	messages.IdBinding = _IdBindingImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.IdBinding)
end

return {
	HydrationDataSpec = messages.HydrationDataSpec,
	IdBinding = messages.IdBinding,
}
